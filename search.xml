<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux常用命令集合</title>
    <url>/2024/06/27/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h3 id="Linux命令">Linux命令</h3>
<p>Linux 是一个功能强大的操作系统，它提供了大量的命令来执行各种任务。以下是一些常用的 Linux 命令及其简要说明</p>
<h4 id="vim编辑器：">vim编辑器：</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim a.java   	进入一般模式</span><br><span class="line">i(按键)   		进入插入模式(编辑模式)</span><br><span class="line">ESC(按键)  		退出</span><br><span class="line">:wq 			保存退出（shift+：调起输入框）</span><br><span class="line">:q！			不保存退出（shift+：调起输入框）（内容有更改）(强制退出，不保留更改内容)</span><br><span class="line">:q				不保存退出（shift+：调起输入框）（没有内容更改）</span><br></pre></td></tr></table></figure>
<h4 id="文件和目录操作：">文件和目录操作：</h4>
<h5 id="ls-列出目录内容"><code>ls</code>: 列出目录内容</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ll				查看当前目录下内容（LL的小写）</span><br></pre></td></tr></table></figure>
<h5 id="cd-更改目录"><code>cd</code>: 更改目录</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~			当前用户目录</span><br><span class="line"><span class="built_in">cd</span> /			根目录</span><br><span class="line"><span class="built_in">cd</span> -			上一次访问的目录</span><br><span class="line"><span class="built_in">cd</span> ..			上一级目录</span><br></pre></td></tr></table></figure>
<h5 id="pwd-显示当前目录路径"><code>pwd</code>: 显示当前目录路径</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span>				查看当前工作目录</span><br></pre></td></tr></table></figure>
<h5 id="mkdir-创建目录"><code>mkdir</code>: 创建目录</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> aaa		在当前目录下创建aaa目录，相对路径；</span><br><span class="line"><span class="built_in">mkdir</span> ./bbb		在当前目录下创建bbb目录，相对路径；</span><br><span class="line"><span class="built_in">mkdir</span> /ccc		在根目录下创建ccc目录，绝对路径；</span><br><span class="line"><span class="built_in">mkdir</span> -p temp/nginx    创建递归目录，创建里面没有的目录文件</span><br></pre></td></tr></table></figure>
<h5 id="rmdir-删除空目录"><code>rmdir</code>: 删除空目录</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="rm-删除文件或目录（需谨慎使用）"><code>rm</code>: 删除文件或目录（需谨慎使用）</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /bbb			强制删除/目录下的bbb目录。如果bbb目录中还有子目录，也会被强制删除，不会提示；</span><br><span class="line"><span class="built_in">rm</span> -r /bbb			普通删除。会询问你是否删除每一个文件</span><br><span class="line"><span class="built_in">rmdir</span> test01		目录的删除</span><br></pre></td></tr></table></figure>
<h5 id="cp-复制文件或目录"><code>cp</code>: 复制文件或目录</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r /aaa /bbb			将/目录下的aaa目录复制到/bbb目录下，在/bbb目录下的名称为aaa</span><br><span class="line"><span class="built_in">cp</span> -r /aa /bbb/aaa		将/目录下的aa目录复制到/bbb目录下，且修改名为aaa;</span><br></pre></td></tr></table></figure>
<h5 id="mv-移动或重命名文件或目录"><code>mv</code>: 移动或重命名文件或目录</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> 原先目录 文件的名称   <span class="built_in">mv</span> tomcat001 tomcat    重命名</span><br><span class="line"><span class="built_in">mv</span>	/aaa /bbb		    将根目录下的aaa目录，移动到bbb目录下(假如没有bbb目录，则重命名为bbb)；</span><br><span class="line"><span class="built_in">mv</span>	bbbb usr/bbb		将当前目录下的bbbb目录，移动到usr目录下，并且修改名称为bbb；</span><br><span class="line"><span class="built_in">mv</span>	bbb usr/aaa			将当前目录下的bbbb目录，移动到usr目录下，并且修改名称为aaa；</span><br></pre></td></tr></table></figure>
<h5 id="touch-创建空文件或更新文件时间戳"><code>touch</code>: 创建空文件或更新文件时间戳</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> testFile    创建文件</span><br></pre></td></tr></table></figure>
<h5 id="ln-创建链接文件（硬链接或符号链接）"><code>ln</code>: 创建链接文件（硬链接或符号链接）</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /usr/local/app /data  创建软连接时，data目录后不加 / (加上后是查找其下一级目录)</span><br></pre></td></tr></table></figure>
<h5 id="find-在文件系统中查找文件"><code>find</code>: 在文件系统中查找文件</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="文本操作">文本操作</h4>
<h5 id="cat-显示文件内容"><code>cat</code>: 显示文件内容</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> a.java		查看a.java文件的最后一页内容；</span><br></pre></td></tr></table></figure>
<h5 id="more-分页显示文件内容"><code>more</code>: 分页显示文件内容</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">more a.java		从第一页开始查看a.java文件内容，按回车键一行一行进行查看，</span><br><span class="line">                    按空格键一页一页进行查看，q退出；</span><br></pre></td></tr></table></figure>
<h5 id="less-与-more-类似，但功能更强大"><code>less</code>: 与 <code>more</code> 类似，但功能更强大</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">less a.java		从第一页开始查看a.java文件内容，按回车键一行一行的看，</span><br><span class="line">                按空格键一页一页的看，支持使用PageDown和PageUp翻页，q退出；</span><br></pre></td></tr></table></figure>
<h5 id="head-显示文件开头内容"><code>head</code>: 显示文件开头内容</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">head</span> a.java				查看a.java文件的前10行内容；</span><br><span class="line"><span class="built_in">head</span> -n 7 a.java		查看a.java文件的前7行内容；</span><br></pre></td></tr></table></figure>
<h5 id="tail-显示文件末尾内容"><code>tail</code>: 显示文件末尾内容</h5>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">tail -<span class="keyword">f</span> <span class="keyword">a</span>.java			查看<span class="keyword">a</span>.java文件的后<span class="number">10</span>行内容；</span><br><span class="line">tail -n <span class="number">7</span> <span class="keyword">a</span>.java		查看<span class="keyword">a</span>.java文件的后<span class="number">7</span>行内容；</span><br></pre></td></tr></table></figure>
<h5 id="grep-在文件中搜索匹配的行"><code>grep</code>: 在文件中搜索匹配的行</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep under 123.txt			在123.txt文件中搜索under字符串，大小写敏感，显示行；</span><br><span class="line">grep -n under 123.txt		在123.txt文件中搜索under字符串，大小写敏感，显示行及行号；</span><br><span class="line">grep -v under 123.txt		在123.txt文件中搜索under字符串，大小写敏感，显示没搜索到的行；</span><br><span class="line">grep -i under 123.txt		在123.txt文件中搜索under字符串，大小写敏感，显示行；</span><br><span class="line">grep -ni under 123.txt		在123.txt文件中搜索under字符串，大小写敏感，显示行及行号；</span><br></pre></td></tr></table></figure>
<h5 id="sed-流编辑器，用于对输入流（文件或管道）进行基本文本转换"><code>sed</code>: 流编辑器，用于对输入流（文件或管道）进行基本文本转换</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/Jack/me/g/ replace.java    全文将Jack替换为me(g是全部替换,不加只替换首个)</span></span><br></pre></td></tr></table></figure>
<h5 id="awk-用于文本和数据提取的工具"><code>awk</code>: 用于文本和数据提取的工具</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk [options] <span class="string">&#x27;cmd&#x27;</span> file</span><br></pre></td></tr></table></figure>
<h4 id="权限和用户管理：">权限和用户管理：</h4>
<h5 id="chmod-更改文件或目录的权限"><code>chmod</code>: 更改文件或目录的权限</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="chown-更改文件或目录的所有者和组"><code>chown</code>: 更改文件或目录的所有者和组</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">##### `chgrp`: 更改文件或目录的组</span></span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<h5 id="useradd-添加新用户"><code>useradd</code>: 添加新用户</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd –d /usr/sum -m <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>
<h5 id="userdel-删除用户"><code>userdel</code>: 删除用户</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">##### `groupadd`: 添加新组</span></span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">groupadd groupname</span><br></pre></td></tr></table></figure>
<h5 id="groupdel-删除组"><code>groupdel</code>: 删除组</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupdel groupname</span><br></pre></td></tr></table></figure>
<h5 id="id-显示当前用户或指定用户的实际和有效用户ID和组ID"><code>id</code>: 显示当前用户或指定用户的实际和有效用户ID和组ID</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#### `su`: 切换到另一个用户账户</span></span></span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<h5 id="sudo-以另一个用户的身份执行命令（通常用于超级用户）"><code>sudo</code>: 以另一个用户的身份执行命令（通常用于超级用户）</h5>
<h4 id="进程管理：">进程管理：</h4>
<h5 id="ps-显示当前进程的快照。"><code>ps</code>: 显示当前进程的快照。</h5>
<h5 id="top-动态显示进程信息（实时）。"><code>top</code>: 动态显示进程信息（实时）。</h5>
<h5 id="htop-一个增强的-top-命令，具有更多的功能和更好的界面。"><code>htop</code>: 一个增强的 top 命令，具有更多的功能和更好的界面。</h5>
<h5 id="kill-发送信号以终止、继续或停止进程。"><code>kill</code>: 发送信号以终止、继续或停止进程。</h5>
<h5 id="pkill-和-killall-根据名称发送信号给进程。"><code>pkill</code> 和 <code>killall</code>: 根据名称发送信号给进程。</h5>
<h5 id="nohup-运行命令，忽略挂起（HUP）信号。"><code>nohup</code>: 运行命令，忽略挂起（HUP）信号。</h5>
<h5 id="fg-和-bg-将作业放到前台或后台执行。"><code>fg</code> 和 <code>bg</code>: 将作业放到前台或后台执行。</h5>
<h5 id="jobs-列出当前-shell-会话中的作业。"><code>jobs</code>: 列出当前 shell 会话中的作业。</h5>
<h4 id="系统信息：">系统信息：</h4>
<h5 id="uname-显示系统信息（内核名称、主机名、内核版本号等）。"><code>uname</code>: 显示系统信息（内核名称、主机名、内核版本号等）。</h5>
<h5 id="uptime-显示系统运行时间、用户数、负载等。"><code>uptime</code>: 显示系统运行时间、用户数、负载等。</h5>
<h5 id="w-显示已登录的用户和他们正在执行的命令。"><code>w</code>: 显示已登录的用户和他们正在执行的命令。</h5>
<h5 id="who-显示已登录的用户。"><code>who</code>: 显示已登录的用户。</h5>
<h5 id="last-显示最近登录的用户列表。"><code>last</code>: 显示最近登录的用户列表。</h5>
<h5 id="dmidecode-显示硬件信息（需要-root-权限）。"><code>dmidecode</code>: 显示硬件信息（需要 root 权限）。</h5>
<h5 id="lscpu-和-lshw-显示-CPU-和硬件的详细信息。"><code>lscpu</code> 和 <code>lshw</code>: 显示 CPU 和硬件的详细信息。</h5>
<h5 id="free-显示内存使用情况。"><code>free</code>: 显示内存使用情况。</h5>
<h5 id="vmstat-报告关于进程、内存、分页、块-IO、陷阱和-CPU-活动的信息。"><code>vmstat</code>: 报告关于进程、内存、分页、块 IO、陷阱和 CPU 活动的信息。</h5>
<h4 id="网络管理：">网络管理：</h4>
<h5 id="ifconfig-或-ip-显示和配置网络接口。"><code>ifconfig</code> 或 <code>ip</code>: 显示和配置网络接口。</h5>
<h5 id="netstat-显示网络连接、路由表、接口统计等。"><code>netstat</code>: 显示网络连接、路由表、接口统计等。</h5>
<h5 id="ss-另一个用于查看系统套接字统计信息的工具（比-netstat-更快）。"><code>ss</code>: 另一个用于查看系统套接字统计信息的工具（比 netstat 更快）。</h5>
<h5 id="ping-发送-ICMP-ECHO-REQUEST-到网络主机。"><code>ping</code>: 发送 ICMP ECHO_REQUEST 到网络主机。</h5>
<h5 id="traceroute-或-tracert-显示数据包从源主机到目标主机之间的路由。"><code>traceroute</code> 或 <code>tracert</code>: 显示数据包从源主机到目标主机之间的路由。</h5>
<h5 id="nslookup-和-dig-查询-DNS-记录。"><code>nslookup</code> 和 <code>dig</code>: 查询 DNS 记录。</h5>
<h5 id="telnet-用于登录到远程主机的-TELNET-会话。"><code>telnet</code>: 用于登录到远程主机的 TELNET 会话。</h5>
<h5 id="nc-netcat-一个小巧但功能强大的网络工具，可以读写-TCP-和-UDP-数据。"><code>nc</code> (netcat): 一个小巧但功能强大的网络工具，可以读写 TCP 和 UDP 数据。</h5>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++编译和内存管理</title>
    <url>/2024/07/01/C-%E7%BC%96%E8%AF%91%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="C-编译和内存管理">C++编译和内存管理</h3>
<h4 id="内存管理">内存管理</h4>
<h5 id="ELF文件（可执行可链接文件）：">ELF文件（可执行可链接文件）：</h5>
<p>是Linux等类Unix操作系统中用于表示可执行文件、共享库、目标文件和核心转储文件的标准二进制文件格式。每个 ELFELF 文件都由一个 <code>ELF header</code> 和紧跟其后的文件数据部分组成。</p>
<h5 id="C-内存分区：">C++内存分区：</h5>
<p>C++内存分区在程序执行时，为了更有效地管理内存资源，通常将内存划分为不同的区域。</p>
<table>
<thead>
<tr>
<th>程序存储区</th>
<th>全局/静态存储</th>
<th>栈区</th>
<th>堆区</th>
<th>常量存储区</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统管理，运行期间不变</td>
<td>执行时已分配好，运行期间不变</td>
<td>编译器管理，分配和释放的效率很高</td>
<td>程序员管理，要自己要求和释放</td>
<td>存放常量，运行期间不变</td>
</tr>
</tbody>
</table>
<p>以下是C++内存分区的详细解释：</p>
<h6 id="程序存储区（程序代码区）">程序存储区（程序代码区）</h6>
<ul>
<li>功能：存放函数体的二进制代码，由操作系统进行管理。</li>
<li>特点：这部分内存主要存储了程序的指令和数据结构，它们在程序开始执行时就已经加载到内存中，并在程序运行期间保持不变</li>
</ul>
<h6 id="全局-静态存储区">全局/静态存储区</h6>
<ul>
<li>功能：存放全局变量和静态变量（包括全局静态变量和局部静态变量）。</li>
<li>特点：
<ul>
<li>在程序开始执行时，这部分内存就已经分配好了，并且它们的存储单元是固定的。</li>
<li>变量的生命周期与程序的运行时间相同，程序结束时才会释放这部分内存。</li>
<li>由于静态分配，其访问速度相对较快。</li>
</ul>
</li>
</ul>
<h6 id="栈区（Stack）">栈区（Stack）</h6>
<ul>
<li>功能：
<ul>
<li>由编译器自动分配和释放。</li>
<li>存放函数的参数值、局部变量等。</li>
</ul>
</li>
<li>特点：
<ul>
<li>栈区采用后进先出（LIFO）的管理方式。</li>
<li>分配和释放的效率非常高，因为栈内存分配运算内置于处理器的指令集中。</li>
<li>但栈区的空间大小是有限制的，过多的局部变量或递归调用可能导致栈溢出。</li>
</ul>
</li>
</ul>
<h6 id="堆区（Heap）">堆区（Heap）</h6>
<ul>
<li>功能：
<ul>
<li>由程序员分配和释放。</li>
<li>若程序员不释放，程序结束时由操作系统回收。</li>
</ul>
</li>
<li>特点：
<ul>
<li>堆区是动态内存分配的主要区域，程序员可以使用<code>new</code>和<code>delete</code>（或<code>new[]</code>和<code>delete[]</code>）来分配和释放内存。</li>
<li>堆区的空间大小相对较大，但在频繁地分配和释放内存时，可能会导致内存碎片。</li>
<li>使用堆区时要特别注意内存泄漏的问题，即分配的内存没有被正确释放。</li>
</ul>
</li>
</ul>
<h6 id="常量存储区">常量存储区</h6>
<ul>
<li>功能：存放常量字符串和其他常量值。</li>
<li>特点：
<ul>
<li>常量存储区中的值在程序运行期间不可修改。</li>
<li>常量字符串通常与其他只读数据一起存放在只读存储区，以防止程序意外修改它们。</li>
</ul>
</li>
</ul>
<h6 id="自由存储区">自由存储区</h6>
<ul>
<li>说明：自由存储区是一个相对抽象的概念，通常指的是通过<code>new</code>操作符分配的内存区域。虽然从技术上来说，这部分内存也属于堆区，但C++标准库允许程序员通过重载<code>new</code>和<code>delete</code>操作符来改变自由存储区的实现。</li>
</ul>
<h6 id="总结">总结</h6>
<p>C++内存分区是程序设计和内存管理的重要基础。了解不同内存分区的功能和特点有助于程序员更合理地使用和管理内存资源，从而提高程序的性能和稳定性。在编写C++程序时，应该尽量避免内存泄漏和栈溢出等问题，以确保程序的正确性和健壮性。</p>
<h4 id="堆和栈">堆和栈</h4>
<h5 id="栈">栈</h5>
<p>当我们讨论操作系统和内存管理时，我们更经常指的是进程或线程的调用栈（Call Stack）或执行栈（Execution Stack），这是一个由操作系统自动管理的内存区域。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动分配和释放</td>
<td>栈内存由系统自动分配和释放。当一个函数被调用时，它的参数和局部变量会在栈上被分配空间。当函数返回时，这些空间会被自动释放。</td>
</tr>
<tr>
<td>后进先出（LIFO）</td>
<td>栈遵循后进先出（Last In First Out）的原则。这意味着最后入栈的元素会最先出栈。</td>
</tr>
<tr>
<td>栈帧（Stack Frame）</td>
<td>每次函数调用时，都会在栈上分配一个栈帧（Stack Frame）。栈帧包含了函数的局部变量、参数、返回地址等信息。</td>
</tr>
<tr>
<td>栈溢出（Stack Overflow）</td>
<td>如果函数递归调用过深，或者局部变量占用了过多的栈空间，就可能导致栈溢出。栈溢出是一种严重的错误，通常会导致程序崩溃。</td>
</tr>
<tr>
<td>栈指针（Stack Pointer）</td>
<td>栈指针是一个指向栈顶的内存地址的指针。当数据入栈时，栈指针会向下移动（在大多数系统中，栈是向下增长的）；当数据出栈时，栈指针会向上移动。</td>
</tr>
<tr>
<td>局部变量和函数参数</td>
<td>在C++中，局部变量（包括自动存储期对象）和函数参数通常都存储在栈上。这意味着它们的生命周期与它们所在的函数或代码块相同。当函数返回或代码块结束时，这些变量就会被销毁。</td>
</tr>
<tr>
<td>返回地址</td>
<td>每次函数调用时，除了局部变量和参数外，还会在栈上保存一个返回地址。这个地址是函数执行完毕后应该跳转到的位置，通常是调用该函数之后的下一条指令。</td>
</tr>
</tbody>
</table>
<h5 id="堆">堆</h5>
<p>在C++中，堆（Heap）是一种重要的内存管理机制，它允许程序员在运行时动态地分配和释放内存。与栈（Stack）不同，堆内存是由程序员显式管理的，而不是由系统自动管理的。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>动态分配</td>
<td>堆内存允许程序在运行时根据需要动态地分配内存。这是通过使用诸如<code>new</code>和<code>delete</code>（在C++中）或<code>malloc</code>和<code>free</code>（在C中）等操作符或函数来实现的。</td>
</tr>
<tr>
<td>显示管理</td>
<td>与栈内存不同，程序员必须显式地管理堆内存。这意味着程序员需要负责在不再需要内存时释放它，以避免内存泄漏。</td>
</tr>
<tr>
<td>内存碎片</td>
<td>由于堆内存是动态分配的，因此可能会产生内存碎片。内存碎片是当小块内存被释放并留下未使用的空间时发生的，这些空间太小而无法容纳其他请求，但又无法合并成更大的连续块。</td>
</tr>
<tr>
<td>分配和释放时间</td>
<td>堆内存的分配和释放通常比栈内存慢，因为堆内存管理涉及到查找可用空间、跟踪分配和释放等复杂操作。</td>
</tr>
<tr>
<td>存储打对象或者长生命周期对象</td>
<td>由于堆内存是动态分配的，因此它通常用于存储大对象或具有长生命周期的对象。这些对象不适合在栈上分配，因为栈的大小通常是有限的。</td>
</tr>
<tr>
<td>异常安全性</td>
<td>在C++中，使用<code>new</code>操作符分配内存时，如果内存分配失败，会抛出<code>std::bad_alloc</code>异常。这使得堆内存分配具有更好的异常安全性，因为它允许程序员处理分配失败的情况。</td>
</tr>
<tr>
<td>智能指针</td>
<td>为了简化堆内存的管理，C++11引入了智能指针（如<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>）。智能指针能够自动管理堆内存的生命周期，减少内存泄漏的风险。</td>
</tr>
</tbody>
</table>
<h5 id="堆和栈的区别">堆和栈的区别</h5>
<p>简而言之，堆是程序员手动管理的动态内存区域，而栈是自动管理的静态内存区域。</p>
<h6 id="堆（Heap）">堆（Heap）</h6>
<ul>
<li>堆用于动态内存分配。程序员使用<code>new</code>或<code>malloc</code>等函数在堆上请求内存，并在不再需要时使用<code>delete</code>或<code>free</code>释放它。</li>
<li>堆内存的生命周期由程序员控制。</li>
<li>堆内存通常用于存储大型对象或对象数组。</li>
</ul>
<h6 id="栈（Stack）">栈（Stack）</h6>
<ul>
<li>栈是自动管理的内存区域，用于存储局部变量和函数调用的信息。</li>
<li>栈内存的生命周期与函数或代码块的执行周期相同。当函数返回时，栈上的内存会被自动释放。</li>
<li>栈内存通常用于存储小型对象和简单数据类型。</li>
</ul>
<h4 id="变量定义和生存周期">变量定义和生存周期</h4>
<h5 id="变量作用域">变量作用域</h5>
<p>在C++中，变量的作用域（Scope）指的是变量可以被访问的代码区域。这决定了变量的生命周期和可见性。C++中有几种不同的作用域：</p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>性质</th>
</tr>
</thead>
<tbody>
<tr>
<td>局部作用域（Local Scope）</td>
<td>局部作用域是在函数、代码块或循环内部定义的变量的作用域。这些变量在它们被声明的代码块内是可见的，一旦代码块结束，这些变量就会被销毁（对于非静态局部变量）。</td>
</tr>
<tr>
<td>全局作用域（Global Scope）</td>
<td>全局作用域是在所有函数外部定义的变量的作用域。这些变量在整个程序中都是可见的，从定义它们的文件开始到文件结束。如果它们被声明为<code>extern</code>，则可以在其他文件中通过包含适当的头文件来访问。</td>
</tr>
<tr>
<td>命名空间作用域（Namespace Scope）</td>
<td>命名空间作用域是在命名空间中定义的变量的作用域。命名空间用于将相关的标识符（如变量、函数、类等）组合在一起，以避免命名冲突。</td>
</tr>
<tr>
<td>类作用域（Class Scope）</td>
<td>类作用域是在类中定义的成员变量的作用域。这些变量是类的实例（对象）的一部分，并且只能通过类的对象或指针来访问。</td>
</tr>
</tbody>
</table>
<p>在下面这段代码中，我们定义了：</p>
<ul>
<li>一个全局变量 <code>globalVar</code>。</li>
<li>一个命名空间 <code>MyNamespace</code>，其中包含一个命名空间变量 <code>namespaceVar</code>。</li>
<li>一个类 <code>MyClass</code>，其中包含一个类成员变量 <code>classVar</code> 和一个成员函数 <code>printVar</code>。</li>
<li>一个函数 <code>foo</code>，其中包含一个局部变量 <code>localVar</code>，并访问了全局变量、命名空间变量和类实例的变量。</li>
<li>在 <code>main</code> 函数中，我们访问了全局变量、命名空间变量，并创建了一个 <code>MyClass</code> 的实例来访问其成员变量。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>    </span></span><br><span class="line"><span class="comment">// 全局作用域  </span></span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">100</span>;  </span><br><span class="line"><span class="comment">// 命名空间作用域  </span></span><br><span class="line"><span class="keyword">namespace</span> MyNamespace &#123;  </span><br><span class="line">    <span class="type">int</span> namespaceVar = <span class="number">200</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 类作用域  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="type">int</span> classVar = <span class="number">300</span>; <span class="comment">// 类成员变量（实例变量）  </span></span><br><span class="line">    <span class="comment">// 成员函数（也在类作用域内）  </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printVar</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;classVar: &quot;</span> &lt;&lt; classVar &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">// 函数作用域（包括局部作用域）  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">42</span>; <span class="comment">// 局部变量  </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;localVar: &quot;</span> &lt;&lt; localVar &lt;&lt; std::endl;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;globalVar: &quot;</span> &lt;&lt; globalVar &lt;&lt; std::endl;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MyNamespace::namespaceVar: &quot;</span> &lt;&lt; MyNamespace::namespaceVar &lt;&lt; std::endl;  </span><br><span class="line">    MyClass obj; <span class="comment">// 创建MyClass的实例  </span></span><br><span class="line">    obj.<span class="built_in">printVar</span>(); <span class="comment">// 调用成员函数打印classVar  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;globalVar: &quot;</span> &lt;&lt; globalVar &lt;&lt; std::endl;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MyNamespace::namespaceVar: &quot;</span> &lt;&lt; MyNamespace::namespaceVar &lt;&lt; std::endl;  </span><br><span class="line">    <span class="built_in">foo</span>(); <span class="comment">// 调用foo函数，该函数将打印其局部变量和全局/命名空间变量  </span></span><br><span class="line">    MyClass obj; <span class="comment">// 在main函数中创建MyClass的实例  </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj.classVar: &quot;</span> &lt;&lt; obj.classVar &lt;&lt; std::endl; <span class="comment">// 直接访问obj的classVar </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="变量生命周期">变量生命周期</h5>
<p>在C++中，变量的生命周期指的是变量从创建到销毁的时间段。这取决于变量在何处以及如何被声明。以下是C++中变量生命周期的几种主要情况：</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>局部变量（Local Variables）</td>
<td>局部变量在函数、代码块或循环内定义。它们的生命周期从定义点开始，到包含它们的代码块执行完毕时结束。一旦变量离开其作用域（即包含它的代码块），它就会被销毁，其占用的内存会被释放。</td>
</tr>
<tr>
<td>全局变量（Global Variables）</td>
<td>全局变量在函数外部定义，通常在所有函数外部的文件顶部。它们的生命周期是整个程序的执行期间，从程序开始执行到程序结束。</td>
</tr>
<tr>
<td>静态局部变量（Static Local Variables）</td>
<td>静态局部变量在函数内部定义，但它们的生命周期与全局变量类似。它们在第一次进入包含它们的函数时被初始化，并在程序执行期间一直存在，即使函数返回也不会被销毁。在下次函数调用时，静态局部变量的值保持不变。</td>
</tr>
<tr>
<td>动态分配的内存（Dynamically Allocated Memory）</td>
<td>使用<code>new</code>操作符在堆上动态分配的内存的生命周期是由程序员控制的。当使用<code>new</code>分配内存时，该内存会一直存在，直到显式地使用<code>delete</code>操作符释放它。忘记释放内存会导致内存泄漏。</td>
</tr>
<tr>
<td>类的成员变量（Class Member Variables）</td>
<td>类的成员变量（包括静态和非静态）的生命周期取决于类的实例（对象）的生命周期。非静态成员变量与对象一起创建和销毁，而静态成员变量在第一次创建类的对象时初始化，并在程序执行期间一直存在，即使所有对象都被销毁。</td>
</tr>
</tbody>
</table>
<p>在接下来这段代码中，我们有：</p>
<ul>
<li>一个全局变量<code>globalVar</code></li>
<li>一个类<code>MyClass</code>，它有一个非静态成员变量<code>instanceVar</code>和一个静态成员变量<code>staticVar</code>。</li>
<li>在<code>main</code>函数中，我们访问了全局变量并创建了一个<code>MyClass</code>的实例，然后通过这个实例访问了其成员变量。</li>
<li>我们还定义了一个函数<code>foo</code>，其中包含了静态局部变量<code>staticLocalVar</code>和局部变量<code>localVar</code>。</li>
<li>此外，我们还在<code>foo</code>函数中动态分配了一个整数，并在使用后立即释放了它。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="comment">// 全局变量  </span></span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">100</span>;  </span><br><span class="line"><span class="comment">// 类的声明  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="type">int</span> instanceVar; <span class="comment">// 类的非静态成员变量（实例变量）  </span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar; <span class="comment">// 类的静态成员变量  </span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">instanceVar</span>(value) &#123;&#125; <span class="comment">// 构造函数  </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printVars</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Instance variable: &quot;</span> &lt;&lt; instanceVar &lt;&lt; std::endl;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Static variable: &quot;</span> &lt;&lt; staticVar &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">// 类的静态成员变量的初始化  </span></span><br><span class="line"><span class="type">int</span> MyClass::staticVar = <span class="number">200</span>;  </span><br><span class="line"><span class="comment">// 函数定义  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 静态局部变量  </span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticLocalVar = <span class="number">0</span>;  </span><br><span class="line">    staticLocalVar++;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Static local variable: &quot;</span> &lt;&lt; staticLocalVar &lt;&lt; std::endl;  </span><br><span class="line">    <span class="comment">// 局部变量  </span></span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">42</span>;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Local variable: &quot;</span> &lt;&lt; localVar &lt;&lt; std::endl;  </span><br><span class="line">    <span class="comment">// 动态分配的内存  </span></span><br><span class="line">    <span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">84</span>);  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Dynamically allocated variable: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;  </span><br><span class="line">    <span class="keyword">delete</span> ptr; <span class="comment">// 释放内存  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 访问全局变量  </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Global variable: &quot;</span> &lt;&lt; globalVar &lt;&lt; std::endl;  </span><br><span class="line">    <span class="comment">// 创建MyClass的实例并访问其成员变量  </span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">300</span>)</span></span>;  </span><br><span class="line">    obj.<span class="built_in">printVars</span>();  </span><br><span class="line">    <span class="comment">// 调用foo函数，访问静态局部变量和局部变量  </span></span><br><span class="line">    <span class="built_in">foo</span>();  </span><br><span class="line">    <span class="comment">// 注意：在main函数结束时，全局变量和静态成员变量仍然存在，但局部变量（包括静态局部变量在foo函数外部）已经销毁  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内存对齐">内存对齐</h4>
<p>在C++中，内存对齐（Memory Alignment）是计算机内存访问性能优化的一种技术。当数据在内存中按照某种特定的规则对齐时，处理器可以更高效地访问这些数据。这是因为现代处理器在访问内存时，通常会一次性读取多个字节（比如4字节、8字节等），这种读取方式被称为“字”（word）或“双字”（doubleword）访问。如果数据没有正确对齐，那么处理器可能需要执行额外的操作来访问这些数据，这会降低访问速度。</p>
<h5 id="alignas关键字">alignas关键字</h5>
<p>在大多数情况下，最好让编译器自动处理内存对齐,你也可以使用特定的编译器指令或C++17引入的<code>alignas</code>关键字来指定对齐要求。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span>  </span></span><br><span class="line"><span class="comment">// 指定16字节对齐的结构体  </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">16</span>) AlignedStruct &#123;  </span><br><span class="line">    <span class="type">int32_t</span> a;  </span><br><span class="line">    <span class="type">double</span> b;  </span><br><span class="line">    <span class="comment">// ... 可能还有其他成员 ...  </span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    AlignedStruct s;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Alignment of s: &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(s) &lt;&lt; <span class="string">&quot; bytes\n&quot;</span>;  </span><br><span class="line">    <span class="comment">// 输出应该是 16 bytes（取决于平台和编译器）  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="智能指针">智能指针</h4>
<p>C++中的智能指针是一种特殊的指针，它们可以自动管理动态分配的内存的生命周期，从而避免内存泄漏和其他与内存管理相关的问题。C++11标准引入了三种主要的智能指针：<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>。需要注意的是，智能指针不能像普通指针那样支持加减运算。</p>
<table>
<thead>
<tr>
<th>指针</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>unique_ptr</td>
<td><code>unique_ptr</code> 独占其指向的对象。这意味着两个 <code>unique_ptr</code> 不能指向同一个对象。 当 <code>unique_ptr</code> 被销毁（例如，离开其作用域）时，它所指向的对象也会被自动删除。 <code>unique_ptr</code> 提供了对原始指针的独占所有权语义。</td>
</tr>
<tr>
<td>shared_ptr</td>
<td><code>shared_ptr</code> 实现共享所有权的语义。多个 <code>shared_ptr</code> 可以指向同一个对象，并且当最后一个拥有该对象的 <code>shared_ptr</code> 被销毁时，对象才会被删除。 <code>shared_ptr</code> 使用引用计数来跟踪有多少 <code>shared_ptr</code> 指向一个对象。当计数变为0时，对象会被删除。</td>
</tr>
<tr>
<td>weak_ptr</td>
<td><code>weak_ptr</code> 是对 <code>shared_ptr</code> 所管理对象的一个弱引用，它不会增加对象的引用计数。 <code>weak_ptr</code> 主要用于解决 <code>shared_ptr</code> 之间的循环引用问题。 <code>weak_ptr</code> 可以安全地用于检查一个对象是否仍然存在，并且可以通过它获取到 <code>shared_ptr</code>（如果对象仍然存在的话）。##### 指针建立</td>
</tr>
</tbody>
</table>
<h5 id="指针建立">指针建立</h5>
<ul>
<li>优先选用 <code>std::make_unique</code> 和 <code>std::make_shared</code>,而非直接 <code>new</code>。</li>
<li>make_unique：减少代码量，能够加快编译速度，定义两遍类型时，编译器需要进行类型推导会降低编译速度，某些意外意外情况下可能会导致内存泄漏。</li>
<li><code>make_shared</code>：这个主要是可以减少对堆中申请内存的次数，只需要申请一次即可，<code>make_share</code> 虽然效率高，但是同样不能自定义析构器。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; ptr=std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>);  </span><br><span class="line"><span class="comment">// ... 使用 ptr  </span></span><br><span class="line"><span class="comment">// 当 ptr 离开作用域时，它指向的 int 会被自动删除</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>);  </span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1;  <span class="comment">// ptr1 和 ptr2 现在共享同一个 int  </span></span><br><span class="line"><span class="comment">// ... 使用 ptr1 和 ptr2  </span></span><br><span class="line"><span class="comment">// 当 ptr1 和 ptr2 都离开作用域时，它们共享的 int 才会被删除</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; shared = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>);  </span><br><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; weak = shared;   </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> strong = weak.<span class="built_in">lock</span>()) &#123;  </span><br><span class="line">    <span class="comment">// strong 是一个有效的 shared_ptr，我们可以使用它  </span></span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">// 原始对象可能已经被删除了  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="代码示例">代码示例</h5>
<p>这段代码将会展示如何使用<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>来管理<code>MyClass</code>对象的生命周期。你可以看到，当智能指针离开其作用域时，它们会自动删除所指向的对象（除非有其他的<code>shared_ptr</code>仍然指向该对象）。<code>std::weak_ptr</code>用于避免循环引用问题，并允许你检查原始对象是否仍然存在。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  </span></span><br><span class="line"><span class="comment">// 一个简单的类  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">value_</span>(value) &#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass(&quot;</span> &lt;&lt; value_ &lt;&lt; <span class="string">&quot;) created.\n&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass(&quot;</span> &lt;&lt; value_ &lt;&lt; <span class="string">&quot;) destroyed.\n&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value_ &lt;&lt; <span class="string">&quot;\n&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> value_;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 使用std::unique_ptr  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="function">std::unique_ptr&lt;MyClass&gt; <span class="title">uniquePtr</span><span class="params">(<span class="keyword">new</span> MyClass(<span class="number">10</span>))</span></span>;  </span><br><span class="line">        uniquePtr-&gt;<span class="built_in">printValue</span>();  </span><br><span class="line">        <span class="comment">// 当uniquePtr离开作用域时，它指向的对象会被自动删除  </span></span><br><span class="line">    &#125; <span class="comment">// 这里MyClass(10)对象会被销毁  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使用std::shared_ptr  </span></span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; sharedPtr1 = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(<span class="number">20</span>);  </span><br><span class="line">    sharedPtr1-&gt;<span class="built_in">printValue</span>();  </span><br><span class="line">    &#123;  </span><br><span class="line">        std::shared_ptr&lt;MyClass&gt; sharedPtr2 = sharedPtr1; <span class="comment">// sharedPtr1和sharedPtr2现在共享同一个对象  </span></span><br><span class="line">        sharedPtr2-&gt;<span class="built_in">printValue</span>();  </span><br><span class="line">        <span class="comment">// 当sharedPtr2离开作用域时，它指向的对象不会被删除，因为sharedPtr1仍然指向它  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 当sharedPtr1离开作用域时，如果这是最后一个shared_ptr指向该对象，则对象会被删除  </span></span><br><span class="line">    <span class="comment">// 这里MyClass(20)对象会被销毁  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 尝试使用std::weak_ptr  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        std::shared_ptr&lt;MyClass&gt; sharedPtr3 = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(<span class="number">30</span>);  </span><br><span class="line">        std::weak_ptr&lt;MyClass&gt; weakPtr = sharedPtr3;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> shared = weakPtr.<span class="built_in">lock</span>()) &#123; <span class="comment">// 尝试获取shared_ptr  </span></span><br><span class="line">            shared-&gt;<span class="built_in">printValue</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 当sharedPtr3离开作用域时，它指向的对象会被删除  </span></span><br><span class="line">        <span class="comment">// 因为weakPtr只是一个弱引用，所以它不会影响对象的生命周期  </span></span><br><span class="line">    &#125; <span class="comment">// 这里MyClass(30)对象会被销毁  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译和链接">编译和链接</h4>
<p>在C++中，编译和链接是两个不同的步骤，尽管它们通常在一个命令中一起执行。可以分为四个阶段：</p>
<ul>
<li>预处理（Preprocessing）</li>
<li>编译（Compilation）</li>
<li>汇编（Assembly）</li>
<li>链接（Linking）</li>
</ul>
<h5 id="预处理">预处理</h5>
<ul>
<li>替换所有的宏定义（<code>#define</code>）。</li>
<li>插入包含的头文件内容（<code>#include</code>）。</li>
<li>删除注释。</li>
<li>添加行号和文件名信息（用于调试）。</li>
</ul>
<h5 id="编译">编译</h5>
<ul>
<li>检查代码中的语法错误。</li>
<li>将代码转换为更低级别的表示形式（通常称为“汇编代码”）。</li>
<li>简单来说编译的过程即为将 <code>.cpp</code> 源文件翻译成 <code>.s</code> 的汇编代码</li>
</ul>
<h5 id="汇编">汇编</h5>
<ul>
<li>将编译步骤中生成的汇编代码转换为机器码，这是计算机可以直接执行的指令。</li>
<li>将汇编代码 <code>.s</code> 翻译成机器指令 <code>.o</code> 文件，一个 <code>.cpp</code> 文件只会生成一个 <code>.o</code> 文件</li>
</ul>
<h5 id="链接">链接</h5>
<ul>
<li>合并程序中所有单独编译的部分（多个<code>.o</code>文件链接到一起）。</li>
<li>解决程序中引用的外部函数或变量（例如库函数）的地址。</li>
<li>生成一个可执行文件（例如<code>.exe</code>文件在Windows上），这个文件可以被计算机直接执行。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -c main.cpp -o main.o  #生成main.o文件，-c表示只进行编译步骤，并生成目标代码文件</span><br><span class="line">g++ -c utility.cpp -o utility.o#生成utility.o文件，如果使用外部库，要加-l +库名或-L +库路径</span><br><span class="line">g++ main.o utility.o -o my_program#链接成my_program可执行文件</span><br></pre></td></tr></table></figure>
<h6 id="静态链接与动态链接">静态链接与动态链接</h6>
<p>静态链接和动态链接是程序编译和链接过程中的两种不同方式，它们在程序运行时对外部库文件的依赖和处理方式上有所不同。静态链接和动态链接各有优缺点，具体选择哪种方式取决于实际需求和应用场景。</p>
<ul>
<li>如果对程序的独立性和安全性要求较高，可以选择静态链接</li>
<li>如果对程序的体积和升级方便性要求较高，可以选择动态链接。</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>静态链接</th>
<th>动态链接</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>定义</strong></td>
<td>编译时将外部库直接嵌入到可执行文件中</td>
<td>编译时只生成可执行文件和必要的资源文件，运行时加载外部库</td>
</tr>
<tr>
<td><strong>完整性</strong></td>
<td>包含所有代码和数据，无需额外加载</td>
<td>依赖外部库文件，运行时加载</td>
</tr>
<tr>
<td><strong>稳定性</strong></td>
<td>运行时库不会被卸载或替换，稳定性高</td>
<td>运行时库可以被卸载或替换，可能影响稳定性</td>
</tr>
<tr>
<td><strong>独立性</strong></td>
<td>与目标程序依赖性强，修改库需重新编译程序</td>
<td>与目标程序依赖性弱，修改库无需重新编译程序</td>
</tr>
<tr>
<td><strong>体积</strong></td>
<td>体积较大，包含所有代码和数据</td>
<td>体积较小，多个程序可共享同一个库</td>
</tr>
<tr>
<td><strong>资源占用</strong></td>
<td>磁盘和内存占用较大</td>
<td>磁盘和内存占用较小</td>
</tr>
<tr>
<td><strong>升级和维护</strong></td>
<td>升级或维护需要替换所有相关库并重新编译程序</td>
<td>升级或维护库时，无需重新编译程序，只需替换库文件</td>
</tr>
<tr>
<td><strong>兼容性</strong></td>
<td>不易出现兼容性问题，因为所有代码和数据都在一起</td>
<td>可能出现兼容性问题，特别是当多个程序共享同一个库时</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>安全性较高，因为不依赖于外部文件</td>
<td>安全性较低，可能受到外部文件的影响</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>对独立性和安全性要求较高的程序</td>
<td>对体积和升级方便性要求较高的程序</td>
</tr>
</tbody>
</table>
<h4 id="大端小端">大端小端</h4>
<h5 id="字节序">字节序</h5>
<p>字节序是指多字节数据在计算机内存中存储或者网络传输时各字节的存储顺序。具体来说，它决定了在一个多字节的数据项中，字节的哪一端存储在该数据项的起始地址处。</p>
<h5 id="大端-Big-Endian">大端(Big-Endian)</h5>
<p>高位字节在前，低位字节在后。即数据的高位字节存放在内存的低地址处，而数据的低位字节存放在内存的高地址处。例如，一个32位整数<code>0x12345678</code>在大端序系统中会被存储为<code>12 34 56 78</code>（十六进制表示）。</p>
<h5 id="小端-Little-Endian">小端(Little-Endian)</h5>
<p>低位字节在前，高位字节在后。与大端序相反，数据的低位字节存放在内存的低地址处，而数据的高位字节存放在内存的高地址处。同样以32位整数<code>0x12345678</code>为例，在小端序系统中它会被存储为<code>78 56 34 12</code>。</p>
<h5 id="影响">影响</h5>
<p>在网络编程中，网络字节序通常指的是大端序（Big-Endian）。因此，当数据需要在网络上进行传输时，如果主机字节序是小端序（Little-Endian），则需要在发送前将数据从主机字节序转换为网络字节序，接收端在接收到数据后也需要进行相应的转换。</p>
<h4 id="内存泄漏">内存泄漏</h4>
<p>内存泄漏（Memory Leak）是指程序在运行过程中，未能正确释放已经不再需要使用的内存空间，导致系统中的可用内存逐渐减少，直至耗尽所有可用内存并可能引发系统崩溃的严重问题。常见：</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义</td>
<td>程序在运行过程中未能正确释放不再使用的内存空间，导致系统可用内存减少，可能引发系统崩溃。</td>
</tr>
<tr>
<td>原因</td>
<td>程序员忘记释放内存、异常处理不当、循环引用、资源未关闭等。</td>
</tr>
<tr>
<td>类型</td>
<td>常发性、偶发性、一次性、隐式内存泄漏。</td>
</tr>
<tr>
<td>影响</td>
<td>系统性能下降、内存占用持续增加、可能导致系统崩溃。</td>
</tr>
<tr>
<td>解决办法</td>
<td>及时释放内存、正确处理异常、解除循环引用、正确关闭资源、使用检测工具、养成良好编程习惯。</td>
</tr>
<tr>
<td>重要性</td>
<td>内存泄漏是严重的编程错误，需要特别注意预防和修复。</td>
</tr>
</tbody>
</table>
<p>内存泄漏缺陷具有隐蔽性、积累性的特征，比其他内存非法访问错误更难检测。因此，程序员需要特别注意在编写代码时避免内存泄漏的发生，并定期检查代码以发现和修复可能存在的内存泄漏问题。</p>
<h4 id="include-与">#include&quot; &quot;与&lt; &gt;</h4>
<p>以下是一个表格，展示了 <code>#include</code> 指令中使用尖括号 <code>&lt; &gt;</code> 和双引号 <code>&quot;&quot;</code> 的区别：</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>尖括号 <code>&lt; &gt;</code></th>
<th>双引号 <code>&quot;&quot;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>用途</strong></td>
<td>通常用于包含编译器提供的标准库头文件</td>
<td>通常用于包含项目中的自定义头文件</td>
</tr>
<tr>
<td><strong>搜索路径</strong></td>
<td>编译器会在其标准库路径中查找文件</td>
<td>编译器首先在当前源文件所在的目录中查找文件，如果找不到，则会查找编译器设置的其他路径</td>
</tr>
<tr>
<td><strong>处理自定义头文件</strong></td>
<td>如果尝试使用尖括号来包含自定义头文件，并且该文件不在标准库路径中，编译器通常会报错</td>
<td>使用双引号可以包含当前目录或编译器设置的其他路径中的自定义头文件</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td><code>&lt;iostream&gt;</code>、<code>&lt;stdio.h&gt;</code></td>
<td><code>&quot;myheader.h&quot;</code>（假设 <code>myheader.h</code> 在当前目录或编译器设置的其他路径中）</td>
</tr>
<tr>
<td><strong>注意事项</strong></td>
<td>编译器可能会根据设置来改变默认行为</td>
<td>编译器可能会根据设置来改变默认行为，但通常优先查找当前目录</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编译和内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Per_FedAVG源码分析总领</title>
    <url>/2024/06/28/Per-FedAVG%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%80%BB%E9%A2%86/</url>
    <content><![CDATA[<h3 id="data-dataset-py">data_dataset.py</h3>
<p>这段代码定义了两个自定义的PyTorch数据集类：<code>MNISTDataset</code> 和 <code>CIFARDataset</code>。这两个类都继承自PyTorch提供的<code>Dataset</code>类，这使得它们能够与PyTorch的数据加载器一起使用。<br>
<code>MNISTDataset</code>是为MNIST数据集设计的，该数据集包含28x28像素的灰度手写数字图像。<code>CIFARDataset</code>是为CIFAR数据集设计的，该数据集包含32x32像素的彩色图像，分为10个不同的类别（飞机、汽车、鸟、猫、鹿、狗、青蛙、马、船和卡车）。<br>
这两个数据集的构造函数和方法都相同，唯一的区别是数据集的名称（这并不影响其功能）。构造函数接受数据子集和目标，或者单独的数据和目标张量。它还接受可选的transform和target_transform函数，这些函数可以在迭代数据集时用于对数据和目标应用变换。<br>
<code>__getitem__</code>方法为给定的索引返回一个数据样本及其相应的目标。如果提供了变换函数，它将应用于数据样本。如果提供了target_transform函数，它将应用于目标。<br>
<code>__len__</code>方法返回数据集中的样本数量。</p>
<h3 id="data-utils-py">data_utils.py</h3>
<p>这段代码提供了两个函数，<code>get_dataloader</code> 和 <code>get_client_id_indices</code>，用于加载预处理后的联邦学习数据集的数据加载器，以及获取客户端ID的索引。</p>
<ol>
<li><code>get_dataloader</code> 函数接受数据集名称（“mnist” 或 “cifar”）、客户端ID、批处理大小和验证集比例作为参数。它首先检查是否存在预处理的数据集pickle文件，如果没有，则抛出运行时错误。然后，它加载指定客户端的数据集，并将其随机划分为训练集和验证集。最后，它为训练集和验证集创建数据加载器，并返回它们。</li>
<li><code>get_client_id_indices</code> 函数接受数据集名称作为参数。它加载保存的客户端分离信息（“seperation.pkl”），并返回训练客户端、测试客户端和总客户端数的索引列表。<br>
这些函数允许在联邦学习设置中为每个客户端加载和分割数据集，以便进行模型训练和验证。使用这些函数，可以轻松地获取每个客户端的数据加载器，以及客户端的索引信息。</li>
</ol>
<h3 id="data-perprocess-py">data_perprocess.py</h3>
<p>这段代码是一个Python脚本，用于预处理MNIST或CIFAR10数据集，以适应联邦学习设置。它随机地为每个客户端分配类别，将数据集分为训练集和测试集，然后将这些数据集保存为磁盘上的pickle文件。它还将客户端数据分布的统计信息保存为JSON文件。<br>
以下是代码的详细说明：</p>
<ol>
<li>脚本导入了必要的库，包括PyTorch、<a href="http://xn--torchvisionpath-hb5z.py">torchvision和path.py</a>，用于文件系统操作。</li>
<li><code>DATASET</code>、<code>MEAN</code>和<code>STD</code>字典定义了数据集、平均值和标准差的信息，用于数据归一化。</li>
<li><code>preprocess</code>函数是主要的功能，负责处理数据：
<ul>
<li>它设置数据集目录和pickle目录。</li>
<li>它为随机数生成器设置种子，以确保可重复性。</li>
<li>它根据客户端总数和训练客户端的比例计算训练和测试客户端的数量。</li>
<li>它定义了用于归一化的数据转换。</li>
<li>它加载原始数据集，并使用<code>randomly_alloc_classes</code>函数为客户端分配类别。</li>
<li>它将各个客户端的数据集保存为pickle文件，并将客户端分为训练和测试的分离信息保存为&quot;seperation.pkl&quot;。</li>
<li>它将数据集分布的统计信息保存为&quot;all_stats.json&quot;。</li>
</ul>
</li>
<li><code>randomly_alloc_classes</code>函数接受原始数据集、目标数据集类、客户端数量、每个客户端的类别数量以及可选的转换。它使用<code>noniid_slicing</code>函数以非独立同分布的方式切分数据集，为每个客户端创建一个包含指定类别数量的数据集列表。它还计算并返回客户端数据分布的统计信息。</li>
<li><code>__main__</code>块解析命令行参数，包括数据集选择、客户端总数、训练客户端的比例、每个客户端的类别数量和随机种子，然后调用<code>preprocess</code>函数。<br>
要运行此脚本，通常会在命令行中执行它，并提供必要的参数。例如：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python preprocess.py --dataset mnist --client_num_in_total 100 --fraction 0.8 --classes 2 --seed 123</span><br></pre></td></tr></table></figure>
<p>这将预处理MNIST数据集，用于有100个客户端的联邦学习设置，其中80%是训练客户端，每个客户端有2个类别的数据，并使用随机种子123确保结果的可重复性。</p>
<h3 id="model-py"><a href="http://model.py">model.py</a></h3>
<p>这段代码定义了两个模型类，<code>MLP_MNIST</code> 和 <code>MLP_CIFAR10</code>，分别用于MNIST和CIFAR10数据集。这两个模型都是多层感知机（MLP），包含三个全连接层，每个层后面都有一个ELU激活函数。<br>
此外，代码还定义了一个<code>MODEL_DICT</code>字典，用于根据数据集名称获取相应的模型类。<br>
最后，<code>get_model</code>函数接受数据集名称和设备（CPU或GPU）作为参数，并返回相应的模型实例。<br>
以下是代码的详细说明：</p>
<ol>
<li><code>elu</code>类是一个自定义的ELU激活函数，它使用<code>torch.where</code>来判断输入是否大于0，并返回相应的值。对于小于0的输入，它使用0.2乘以指数函数减1的结果。</li>
<li><code>linear</code>类是一个自定义的全连接层，它包含权重矩阵<code>w</code>和偏置<code>b</code>。权重矩阵是通过随机初始化得到的，其标准差是输入特征数目的倒数。</li>
<li><code>MLP_MNIST</code>和<code>MLP_CIFAR10</code>类是MNIST和CIFAR10数据集的MLP模型。它们包含三个全连接层，每个层后面都跟着一个ELU激活函数。在MNIST模型中，输入特征是28x28像素的图像，而在CIFAR10模型中，输入特征是32x32x3的图像。</li>
<li><code>MODEL_DICT</code>字典包含两个模型类，分别对应MNIST和CIFAR10数据集。</li>
<li><code>get_model</code>函数根据传入的数据集名称和设备，从<code>MODEL_DICT</code>中获取相应的模型类，并实例化模型。如果设备是GPU，它将模型移动到GPU上；如果设备是CPU，它将模型移动到CPU上。</li>
</ol>
<h3 id="utils-py"><a href="http://utils.py">utils.py</a></h3>
<p>这段代码提供了一个命令行参数解析函数 <code>get_args</code>，以及两个用于模型评估和随机种子固定的辅助函数 <code>eval</code> 和 <code>fix_random_seed</code>。</p>
<ol>
<li><code>get_args</code> 函数使用 <code>ArgumentParser</code> 从命令行中解析参数。这些参数包括学习率、正则化参数、全局和局部训练轮次、个性化阶段的轮次、批处理大小、验证集比例、数据集名称、每轮训练的客户端数量、随机种子、是否使用GPU、是否在训练过程中进行评估，以及是否记录日志。</li>
<li><code>eval</code> 函数是一个用于评估模型的函数，它接受模型、数据加载器、损失函数和设备作为参数。该函数在评估模式下运行模型，并计算在数据加载器上的总损失和准确率。它返回总损失和准确率。</li>
<li><code>fix_random_seed</code> 函数用于固定PyTorch和其他库的随机种子，以确保实验的可重复性。它接受一个种子值作为参数，并设置相应的随机种子。此外，它还清空了GPU缓存，并设置了CUDA的确定性选项。<br>
这些函数为联邦学习实验提供了一个基础框架，用于处理命令行参数、评估模型和确保实验的可重复性。</li>
</ol>
<h3 id="perfedavg-py"><a href="http://perfedavg.py">perfedavg.py</a></h3>
<p>这段代码定义了一个名为 <code>PerFedAvgClient</code> 的类，用于在联邦学习中训练一个客户端的模型。该类支持两种不同的训练模式：<code>Per-FedAvg(FO)</code> 和 <code>Per-FedAvg(HF)</code>。<br>
以下是代码的详细说明：</p>
<ol>
<li><strong>初始化方法</strong>：
<ul>
<li>客户端ID（<code>client_id</code>）：标识客户端的唯一ID。</li>
<li><code>alpha</code> 和 <code>beta</code>：学习率和正则化参数。</li>
<li><code>global_model</code>：全局模型，即所有客户端共享的模型。</li>
<li><code>criterion</code>：损失函数。</li>
<li><code>batch_size</code>：批量大小。</li>
<li><code>dataset</code>：数据集名称，支持MNIST和CIFAR10。</li>
<li><code>local_epochs</code>：本地训练轮次。</li>
<li><code>valset_ratio</code>：验证集比例。</li>
<li><code>logger</code>：日志记录器。</li>
<li><code>gpu</code>：是否使用GPU。</li>
</ul>
</li>
<li><strong>训练方法</strong>：
<ul>
<li>首先，客户端加载全局模型的状态字典。</li>
<li>然后，客户端进行本地训练。对于 <code>Per-FedAvg(HF)</code> 模式，训练分为两个阶段，每个阶段都包含一个梯度计算和模型更新。对于 <code>Per-FedAvg(FO)</code> 模式，代码中包含了注释掉的联邦平均（FedAvg）训练步骤。</li>
<li>如果设置了 <code>eval_while_training</code>，客户端在本地训练前后都会进行评估。</li>
<li>训练完成后，客户端返回序列化的模型状态。</li>
</ul>
</li>
<li><strong>计算梯度方法</strong>：
<ul>
<li>该方法计算模型参数的梯度。</li>
<li>对于 <code>Per-FedAvg(HF)</code> 模式，它还会计算二阶导数。</li>
</ul>
</li>
<li><strong>个性化评估方法</strong>：
<ul>
<li>该方法用于个性化评估。客户端首先加载全局模型的状态字典，然后进行个性化训练和评估。</li>
<li>个性化训练包括一个梯度计算和模型更新。</li>
<li>评估完成后，客户端返回损失和准确率的变化。</li>
</ul>
</li>
<li><strong>辅助方法</strong>：
<ul>
<li><code>get_data_batch</code>：获取一个数据批量的方法。</li>
<li><code>utils.eval</code>：评估模型的方法，从 <code>utils</code> 模块导入。</li>
<li><code>SerializationTool.serialize_model</code>：序列化模型的方法，从 <code>SerializationTool</code> 模块导入。<br>
这个类为联邦学习中的客户端提供了训练和评估模型的功能，支持不同的训练模式和个性化评估。</li>
</ul>
</li>
</ol>
<h3 id="main-py"><a href="http://main.py">main.py</a></h3>
<p>这段代码是一个联邦学习实验的主程序，它负责初始化客户端、进行训练和评估，并记录日志。以下是代码的详细说明：</p>
<ol>
<li><strong>命令行参数解析</strong>：
<ul>
<li>代码首先使用 <code>get_args</code> 函数解析命令行参数，并使用 <code>fix_random_seed</code> 函数设置随机种子。</li>
<li>检查是否存在日志目录，如果不存在则创建。</li>
</ul>
</li>
<li><strong>设备选择</strong>：
<ul>
<li>如果指定了GPU并且GPU可用，则选择GPU作为设备；否则选择CPU。</li>
</ul>
</li>
<li><strong>全局模型初始化</strong>：
<ul>
<li>使用 <code>get_model</code> 函数根据数据集名称初始化全局模型。</li>
<li>创建日志记录器。</li>
</ul>
</li>
<li><strong>客户端初始化</strong>：
<ul>
<li>创建一个客户端列表，每个客户端都使用 <code>PerFedAvgClient</code> 类初始化。</li>
</ul>
</li>
<li><strong>训练循环</strong>：
<ul>
<li>使用 <code>track</code> 函数跟踪训练进度。</li>
<li>随机选择客户端进行本地训练，并将序列化的模型参数存储在 <code>model_params_cache</code> 中。</li>
<li>使用 <code>Aggregators.fedavg_aggregate</code> 函数聚合模型参数。</li>
<li>反序列化聚合后的模型参数到全局模型。</li>
</ul>
</li>
<li><strong>评估循环</strong>：
<ul>
<li>使用 <code>track</code> 函数跟踪评估进度。</li>
<li>对每个评估客户端执行个性化评估，并记录损失和准确率。</li>
</ul>
</li>
<li><strong>结果展示</strong>：
<ul>
<li>打印评估结果。</li>
</ul>
</li>
<li><strong>日志记录</strong>：
<ul>
<li>如果设置了日志记录，使用 <code>logger.save_html</code> 函数将日志保存为HTML文件。<br>
这个程序为联邦学习实验提供了一个完整的框架，包括客户端的初始化、模型的训练和评估，以及日志的记录和保存。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Per_FedAVG</tag>
      </tags>
  </entry>
  <entry>
    <title>c++关键字</title>
    <url>/2024/06/23/c-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="概述：">概述：</h3>
<p>C++ 是一种广泛使用的、通用的、面向对象的编程语言，它支持过程化编程、数据抽象、面向对象编程和泛型编程等多种编程范式。C++ 是在 C 语言的基础上发展起来的，它增加了许多新的特性，如类、继承、多态、模板、异常处理、命名空间等。</p>
<p>以下是 C++ 的一些基本特点：</p>
<table>
<thead>
<tr>
<th style="text-align:left">特点</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">面向对象</td>
<td style="text-align:left">C++ 支持面向对象编程（OOP），通过类（class）和对象（object）的概念。</td>
</tr>
<tr>
<td style="text-align:left">继承</td>
<td style="text-align:left">一个类可以从另一个类继承，从而重用代码并扩展功能。</td>
</tr>
<tr>
<td style="text-align:left">多态</td>
<td style="text-align:left">通过虚函数（virtual functions）和继承，C++ 支持运行时多态，允许不同的对象对同一消息做出不同的响应。</td>
</tr>
<tr>
<td style="text-align:left">模板</td>
<td style="text-align:left">C++ 提供了模板（templates），允许程序员编写适用于多种数据类型的通用代码。</td>
</tr>
<tr>
<td style="text-align:left">异常处理</td>
<td style="text-align:left">C++ 引入了异常处理机制，用于处理程序运行时的错误情况。</td>
</tr>
<tr>
<td style="text-align:left">命名空间</td>
<td style="text-align:left">C++ 支持命名空间（namespaces），用于避免名称冲突和组织代码。</td>
</tr>
<tr>
<td style="text-align:left">标准库</td>
<td style="text-align:left">C++ 标准库提供了大量的函数和类，用于处理常见的编程任务，如字符串处理、文件操作、内存管理等。</td>
</tr>
<tr>
<td style="text-align:left">与C语言兼容</td>
<td style="text-align:left">C++ 是 C 语言的超集，这意味着任何有效的 C 程序也是有效的 C++ 程序（但可能不是最优的 C++ 程序）。</td>
</tr>
</tbody>
</table>
<p>以下是一个简单的 C++ 程序示例，用于输出 “Hello, World!”：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该示例中，<code>#include &lt;iostream&gt;</code> 指令告诉编译器包含标准输入输出流库。<code>int main()</code> 是程序的入口点。<code>std::cout</code> 是一个输出流对象，用于将文本发送到标准输出（通常是屏幕）。<code>&lt;&lt;</code> 是一个插入运算符，用于将数据插入到输出流中。<code>std::endl</code> 是一个操纵符，用于在输出中插入一个新行。最后，<code>return 0;</code> 表示程序正常退出。</p>
<h3 id="对C的扩充：">对C的扩充：</h3>
<p>下面是一个简化的表格，展示了C++在非面向对象方面对C语言的主要扩充点：</p>
<table>
<thead>
<tr>
<th style="text-align:left">扩充点</th>
<th>C++特性</th>
<th>C语言对应/比较</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">类型安全性</td>
<td>强类型检查</td>
<td>弱类型检查，依赖程序员注意</td>
</tr>
<tr>
<td style="text-align:left">输入输出流</td>
<td><code>iostream</code>库</td>
<td>标准I/O库（如<code>stdio.h</code>）</td>
</tr>
<tr>
<td style="text-align:left">内存管理</td>
<td><code>new</code>和<code>delete</code></td>
<td><code>malloc</code>和<code>free</code></td>
</tr>
<tr>
<td style="text-align:left">引用（Reference）</td>
<td>变量别名</td>
<td>指针操作</td>
</tr>
<tr>
<td style="text-align:left">函数重载</td>
<td>允许同名不同参数函数</td>
<td>不支持</td>
</tr>
<tr>
<td style="text-align:left">缺省参数</td>
<td>允许函数参数有默认值</td>
<td>不支持</td>
</tr>
<tr>
<td style="text-align:left">内联函数</td>
<td>提高函数调用效率</td>
<td>无直接对应</td>
</tr>
<tr>
<td style="text-align:left">命名空间</td>
<td>组织代码，避免命名冲突</td>
<td>全局作用域，可能导致冲突</td>
</tr>
<tr>
<td style="text-align:left">运算符重载</td>
<td>允许重载运算符</td>
<td>不支持</td>
</tr>
<tr>
<td style="text-align:left">条件编译</td>
<td><code>#ifdef</code>, <code>#ifndef</code>等</td>
<td><code>#if</code>, <code>#else</code>, <code>#endif</code></td>
</tr>
<tr>
<td style="text-align:left">宏定义</td>
<td><code>#define</code></td>
<td><code>#define</code></td>
</tr>
<tr>
<td style="text-align:left">预处理撤销</td>
<td><code>#undef</code></td>
<td>无直接对应</td>
</tr>
<tr>
<td style="text-align:left">模板（Templates）</td>
<td>泛型编程</td>
<td>无直接对应</td>
</tr>
<tr>
<td style="text-align:left">异常处理</td>
<td><code>try</code>, <code>catch</code>, <code>throw</code></td>
<td>无直接对应，使用错误码</td>
</tr>
</tbody>
</table>
<p>C++的关键字是编程语言中预先保留的标识符，用于定义语言的结构和语法。在C++中，这些关键字不能被用作变量名、函数名或其他标识符的名称。以下是C++（不包括C++11新增的关键字）中的一部分主要关键字，按照不同的功能分类进行简述：</p>
<h3 id="数据类型关键字">数据类型关键字:</h3>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>布尔类型，用于表示逻辑值（true或false）</td>
</tr>
<tr>
<td>char</td>
<td>字符类型，用于存储字符值</td>
</tr>
<tr>
<td>int</td>
<td>整型，用于存储整数</td>
</tr>
<tr>
<td>float、double、long double</td>
<td>浮点型，用于存储小数</td>
</tr>
<tr>
<td>signed、unsigned</td>
<td>用于指定整数类型是有符号还是无符号的</td>
</tr>
<tr>
<td>short、long</td>
<td>用于指定整数类型的长度</td>
</tr>
<tr>
<td>void</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>复合数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>class</td>
<td>用于定义类</td>
</tr>
<tr>
<td>struct</td>
<td>用于定义结构体</td>
</tr>
<tr>
<td>union</td>
<td>用于定义联合体</td>
</tr>
<tr>
<td>enum</td>
<td>用于定义枚举类型</td>
</tr>
</tbody>
</table>
<h3 id="控制语句关键字">控制语句关键字:</h3>
<table>
<thead>
<tr>
<th>循环语句</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>for</td>
<td>用于执行固定次数的循环</td>
</tr>
<tr>
<td>while</td>
<td>用于在条件为真时重复执行代码块</td>
</tr>
<tr>
<td>do…while</td>
<td>与<code>while</code>类似，但循环体至少会执行一次</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>条件语句</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>if</td>
<td>用于根据条件执行不同的代码块</td>
</tr>
<tr>
<td>else</td>
<td>与<code>if</code>一起使用，用于指定条件为假时执行的代码块</td>
</tr>
<tr>
<td>switch</td>
<td>用于根据表达式的值选择不同的代码块执行</td>
</tr>
<tr>
<td>case</td>
<td>与<code>switch</code>一起使用，用于指定表达式可能的值</td>
</tr>
<tr>
<td>default</td>
<td>与<code>switch</code>一起使用，用于指定表达式不匹配任何<code>case</code>时执行的代码块</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>跳转语句</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>break</td>
<td>用于跳出当前循环或<code>switch</code>语句</td>
</tr>
<tr>
<td>continue</td>
<td>用于跳过当前循环的剩余部分，直接进入下一次循环</td>
</tr>
<tr>
<td>goto</td>
<td>无条件跳转到指定的标签位置（在现代编程中很少使用）</td>
</tr>
<tr>
<td>return</td>
<td>用于从函数中返回值并结束函数执行</td>
</tr>
</tbody>
</table>
<h3 id="存储类型关键字">存储类型关键字:</h3>
<table>
<thead>
<tr>
<th>存储关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>auto</td>
<td>尽管在C++11中有更多用途，但在C++98/03中主要用于自动存储期变量的声明</td>
</tr>
<tr>
<td>extern</td>
<td>用于声明在其他文件中定义的变量或函数</td>
</tr>
<tr>
<td>register</td>
<td>建议编译器将变量存储在寄存器中（但现代编译器通常忽略此建议）</td>
</tr>
<tr>
<td>static</td>
<td>用于声明静态变量或静态成员函数</td>
</tr>
</tbody>
</table>
<h3 id="其他关键字">其他关键字:</h3>
<table>
<thead>
<tr>
<th>另外的常用关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sizeof</td>
<td>用于计算数据类型或变量的大小（以字节为单位）</td>
</tr>
<tr>
<td>typedef</td>
<td>用于为数据类型定义别名</td>
</tr>
<tr>
<td>volatile</td>
<td>用于修饰变量，表示该变量可能在程序外部被意外地改变（如多线程或硬件操作）</td>
</tr>
<tr>
<td>namespace</td>
<td>用于定义命名空间，以避免命名冲突</td>
</tr>
<tr>
<td>using</td>
<td>用于在当前作用域中引入命名空间中的名称</td>
</tr>
<tr>
<td>friend</td>
<td>用于声明友元函数或友元类，它们可以访问类的私有和保护成员</td>
</tr>
<tr>
<td>explicit</td>
<td>用于防止类构造函数被用于隐式类型转换</td>
</tr>
<tr>
<td>mutable</td>
<td>用于修饰类的非静态成员变量，即使在<code>const</code>成员函数中也可以修改它</td>
</tr>
</tbody>
</table>
<h3 id="c-11新引入：">c++11新引入：</h3>
<table>
<thead>
<tr>
<th>关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>alignas</code></td>
<td>用于指定变量或类型的对齐要求</td>
</tr>
<tr>
<td><code>alignof</code></td>
<td>用于获取变量或类型的对齐要求</td>
</tr>
<tr>
<td><code>char16_t</code></td>
<td>16位字符类型</td>
</tr>
<tr>
<td><code>char32_t</code></td>
<td>32位字符类型</td>
</tr>
<tr>
<td><code>constexpr</code></td>
<td>声明编译时常量表达式</td>
</tr>
<tr>
<td><code>decltype</code></td>
<td>用于类型推导，返回表达式的类型</td>
</tr>
<tr>
<td><code>final</code></td>
<td>禁止类被继承，或禁止虚函数被重写</td>
</tr>
<tr>
<td><code>noexcept</code></td>
<td>指定函数不会抛出异常</td>
</tr>
<tr>
<td><code>nullptr</code></td>
<td>表示空指针常量</td>
</tr>
<tr>
<td><code>override</code></td>
<td>检查子类虚函数是否重写了某个基类虚函数</td>
</tr>
<tr>
<td><code>static_assert</code></td>
<td>在编译时进行断言</td>
</tr>
<tr>
<td><code>thread_local</code></td>
<td>声明变量的线程局部存储期</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Per_FedAVG源码分析</title>
    <url>/2024/06/27/Per-FedAVG%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="Per-FeAVG源码分析——根目录下：">Per_FeAVG源码分析——根目录下：</h3>
<p>KarhouTam的Per_FedAVG.源码链接：<a href="https://github.com/KarhouTam/Per-FedAvg">请使用到的点个star</a></p>
<h4 id="utils-py"><a href="http://utils.py">utils.py</a></h4>
<h5 id="函数：get-args（）">函数：get_args（）</h5>
<p>功能：用于加载参数:使用ArgumentParser()输入了<strong>联邦参数</strong>，<strong>模型参数</strong>，<strong>其他参数</strong>三类参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Iterator, <span class="type">Tuple</span>, <span class="type">Union</span></span><br><span class="line"><span class="keyword">from</span> argparse <span class="keyword">import</span> ArgumentParser</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_args</span>():</span><br><span class="line">    parser = ArgumentParser()</span><br><span class="line">    <span class="comment">##‘--alpha’表示参数名称，type代表参数类型，default代表默认值设置，help则是对alpha的描述性解释。</span></span><br><span class="line">    parser.add_argument(<span class="string">&quot;--alpha&quot;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">1e-2</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--beta&quot;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">1e-3</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--global_epochs&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">200</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--local_epochs&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">4</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--pers_epochs&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        default=<span class="number">1</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Indicate how many data batches would be used for personalization. Negatives means that equal to train phase.&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--hf&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        default=<span class="number">0</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;0 for performing Per-FedAvg(FO), others for Per-FedAvg(HF)&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--batch_size&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">40</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--valset_ratio&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">float</span>,</span><br><span class="line">        default=<span class="number">0.1</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Proportion of val set in the entire client local dataset&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--dataset&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, choices=[<span class="string">&quot;mnist&quot;</span>, <span class="string">&quot;cifar&quot;</span>], default=<span class="string">&quot;mnist&quot;</span></span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--client_num_per_round&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">10</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--seed&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">17</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--gpu&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        default=<span class="number">1</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Non-zero value for using gpu, 0 for using cpu&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--eval_while_training&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        default=<span class="number">1</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Non-zero value for performing local evaluation before and after local training&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--log&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> parser.parse_args() <span class="comment">#解析了命令行参数，并将解析结果作为函数的返回值，以便在其他地方可以使用参数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="函数：eval（）">函数：eval（）</h5>
<p>功能：用于在PyTorch中评估给定模型的性能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@torch.no_grad() </span><span class="comment">#这个装饰器确保在评估模型时不会计算梯度，从而节省内存和计算资源。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eval</span>(<span class="params"></span></span><br><span class="line"><span class="params">    model: torch.nn.Module,<span class="comment">#评价的模型</span></span></span><br><span class="line"><span class="params">    dataloader: torch.utils.data.DataLoader,<span class="comment">#数据集加载器</span></span></span><br><span class="line"><span class="params">    criterion: <span class="type">Union</span>[torch.nn.MSELoss, torch.nn.CrossEntropyLoss],<span class="comment">#损失函数，可以是均方误差（MSE）或交叉熵损失。</span></span></span><br><span class="line"><span class="params">    device=torch.device(<span class="params"><span class="string">&quot;cpu&quot;</span></span>),<span class="comment">#用于运行模型的设备（默认为cpu）</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="type">Tuple</span>[torch.Tensor, torch.Tensor]:</span><br><span class="line">    <span class="comment">#将模型设置为评估模式，确保如Dropout或BatchNorm这样的层在评估时以不同的方式工作。</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    total_loss = <span class="number">0</span></span><br><span class="line">    num_samples = <span class="number">0</span></span><br><span class="line">    acc = <span class="number">0</span></span><br><span class="line">    <span class="comment">#对于数据加载器中的每一批数据，计算损失和准确率。</span></span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> dataloader:</span><br><span class="line">        x, y = x.to(device), y.to(device)</span><br><span class="line">        logit = model(x)</span><br><span class="line">        <span class="comment"># total_loss += criterion(logit, y) / y.size(-1)</span></span><br><span class="line">        total_loss += criterion(logit, y) <span class="comment">#使用给定的损失函数计算预测（logit）和真实标签（y）之间的损失。</span></span><br><span class="line">        pred = torch.softmax(logit, -<span class="number">1</span>).argmax(-<span class="number">1</span>)<span class="comment">#使用 torch.softmax 和 argmax 获取预测的类别索引，然后与真实标签比较，统计正确的预测。</span></span><br><span class="line">        acc += torch.eq(pred, y).<span class="built_in">int</span>().<span class="built_in">sum</span>()</span><br><span class="line">        num_samples += y.size(-<span class="number">1</span>)</span><br><span class="line">    model.train()<span class="comment">#在评估结束后将模型重置为训练模式，尽管这通常不是必需的，因为下一个使用模型的操作可能会自动设置它。</span></span><br><span class="line">    <span class="keyword">return</span> total_loss, acc / num_samples</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="函数：fix-random-seed-seed-int">函数：fix_random_seed(seed: int)</h5>
<p>作用：设置随机种子以确保结果的可复现性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fix_random_seed</span>(<span class="params">seed: <span class="built_in">int</span></span>):</span><br><span class="line">    torch.cuda.empty_cache()<span class="comment">#这个函数会清空CUDA缓存。</span></span><br><span class="line">    torch.manual_seed(seed)</span><br><span class="line">    torch.cuda.manual_seed(seed)<span class="comment">#这分别设置CPU和GPU上的随机种子，以确保PyTorch操作的随机性是可复现的。这是正确的。</span></span><br><span class="line">    random.seed(seed)</span><br><span class="line">    np.random.seed(seed)<span class="comment">#这两个函数分别设置Python标准库中的random模块和NumPy库中的随机数生成器的种子。这也是为了确保其他库中的随机操作是可复现的。</span></span><br><span class="line">    torch.backends.cudnn.deterministic = <span class="literal">True</span><span class="comment">#当你设置deterministic=True时，你告诉cuDNN（CUDA Deep Neural Network library）在卷积操作中使用确定性的算法，而不是可能更快但不太确定的算法。这有助于确保即使在GPU上，结果也是可复现的。</span></span><br><span class="line">    torch.backends.cudnn.benchmark = <span class="literal">True</span><span class="comment">#这个设置告诉cuDNN为特定的配置自动寻找最快的卷积算法。但是，当benchmark=True时，cuDNN会尝试不同的算法并保留最佳的一个，这可能会导致结果不可复现，因为每次运行都可能选择不同的算法。</span></span><br></pre></td></tr></table></figure>
<h4 id="model-py"><a href="http://model.py">model.py</a></h4>
<h5 id="函数：elu-nn-Module">函数：elu(nn.Module)</h5>
<p>作用：它实现了指数线性单元（Exponential Linear Unit, ELU）激活函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">elu</span>(nn.Module):<span class="comment">#继承自nn.Module的类elu。</span></span><br><span class="line">    <span class="comment">#调用了父类nn.Module的__init__方法来确保基类的初始化。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>(elu, self).__init__()</span><br><span class="line">	<span class="comment">#实现了ELU激活函数。对于输入x，如果x大于或等于0，则返回x本身；否则，返回0.2 * (torch.exp(x) - 1)。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> torch.where(x &gt;= <span class="number">0</span>, x, <span class="number">0.2</span> * (torch.exp(x) - <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h5 id="类：linear-nn-Module">类：linear(nn.Module)</h5>
<p>作用：<code>__init__</code>方法用于初始化权重（<code>w</code>）和偏置（<code>b</code>），而<code>forward</code>方法定义了数据通过网络层的前向传播过程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">linear</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_c, out_c</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>(linear, self).__init__()</span><br><span class="line">        <span class="comment">#使用了torch.randn(out_c, in_c) * torch.sqrt(torch.tensor(2 / in_c))来初始化权重，这是He初始化（也称为Kaiming初始化）的一个变种，它通常用于ReLU或其变种激活函数。</span></span><br><span class="line">        self.w = nn.Parameter(</span><br><span class="line">            torch.randn(out_c, in_c) * torch.sqrt(torch.tensor(<span class="number">2</span> / in_c))</span><br><span class="line">        )</span><br><span class="line">        self.b = nn.Parameter(torch.randn(out_c))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> F.linear(x, self.w, self.b)</span><br></pre></td></tr></table></figure>
<h5 id="类：MLP-MNIST">类：MLP_MNIST</h5>
<p>作用：构建不同类型的神经网络模型，分别是MLP（多层感知机）、CNNMnist（用于MNIST手写数字数据集的卷积神经网络）和CNNCifar（用于CIFAR-10数据集的卷积神经网络）。实现了神经网络的前向传播过程，并用于分类任务。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MLP_MNIST</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>(MLP_MNIST, self).__init__()</span><br><span class="line">        self.fc1 = linear(<span class="number">28</span> * <span class="number">28</span>, <span class="number">80</span>)</span><br><span class="line">        self.fc2 = linear(<span class="number">80</span>, <span class="number">60</span>)</span><br><span class="line">        self.fc3 = linear(<span class="number">60</span>, <span class="number">10</span>)</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">        self.activation = elu()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.flatten(x)</span><br><span class="line"></span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = self.activation(x)</span><br><span class="line"></span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        x = self.activation(x)</span><br><span class="line"></span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        x = self.activation(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MLP_CIFAR10</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>(MLP_CIFAR10, self).__init__()</span><br><span class="line">        self.fc1 = linear(<span class="number">32</span> * <span class="number">32</span> * <span class="number">3</span>, <span class="number">80</span>)</span><br><span class="line">        self.fc2 = linear(<span class="number">80</span>, <span class="number">60</span>)</span><br><span class="line">        self.fc3 = linear(<span class="number">60</span>, <span class="number">10</span>)</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">        self.activation = elu()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.flatten(x)</span><br><span class="line"></span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = self.activation(x)</span><br><span class="line"></span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        x = self.activation(x)</span><br><span class="line"></span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        x = self.activation(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h5 id="类：MLP-CIFAR10">类：MLP_CIFAR10</h5>
<p>作用：构建不同类型的神经网络模型，分别是MLP（多层感知机）、CNNMnist（用于MNIST手写数字数据集的卷积神经网络）和CNNCifar（用于CIFAR-10数据集的卷积神经网络）。实现了神经网络的前向传播过程，并用于分类任务。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MLP_CIFAR10</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>(MLP_CIFAR10, self).__init__()</span><br><span class="line">        self.fc1 = linear(<span class="number">32</span> * <span class="number">32</span> * <span class="number">3</span>, <span class="number">80</span>)</span><br><span class="line">        self.fc2 = linear(<span class="number">80</span>, <span class="number">60</span>)</span><br><span class="line">        self.fc3 = linear(<span class="number">60</span>, <span class="number">10</span>)</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">        self.activation = elu()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.flatten(x)</span><br><span class="line"></span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = self.activation(x)</span><br><span class="line"></span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        x = self.activation(x)</span><br><span class="line"></span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        x = self.activation(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h5 id="字典：MODEL-DICT">字典：MODEL_DICT</h5>
<p>作用：关联键<code>&quot;mnist&quot;</code>和<code>&quot;cifar&quot;</code>到它们各自的多层感知机（MLP）模型类<code>MLP_MNIST</code>和<code>MLP_CIFAR10</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MODEL_DICT = &#123;<span class="string">&quot;mnist&quot;</span>: MLP_MNIST, <span class="string">&quot;cifar&quot;</span>: MLP_CIFAR10&#125;</span><br></pre></td></tr></table></figure>
<h5 id="函数：get-model-dataset-device">函数：get_model(dataset, device)</h5>
<p>作用：根据数据集名称从<code>MODEL_DICT</code>字典中获取相应的模型类，并实例化模型，然后将模型移动到指定的设备上（CPU或GPU）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_model</span>(<span class="params">dataset, device</span>):</span><br><span class="line">    <span class="keyword">return</span> MODEL_DICT[dataset]().to(device)</span><br></pre></td></tr></table></figure>
<h4 id="perfedavg-py"><a href="http://perfedavg.py">perfedavg.py</a></h4>
<h5 id="函数：init">函数：<strong>init</strong>()</h5>
<p>作用：类的初始化方法，用于配置和初始化类的实例变量。该方法接收多个参数，包括客户端ID、学习率参数（alpha和beta，可能是某种优化算法中的参数，如Momentum或Adam中的beta1和beta2）、全局模型、损失函数、批量大小、数据集名称、本地训练轮数、验证集比例、日志记录器和GPU设备ID。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">    self,</span></span><br><span class="line"><span class="params">    client_id: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">    alpha: <span class="built_in">float</span>,</span></span><br><span class="line"><span class="params">    beta: <span class="built_in">float</span>,</span></span><br><span class="line"><span class="params">    global_model: torch.nn.Module,</span></span><br><span class="line"><span class="params">    criterion: <span class="type">Union</span>[torch.nn.CrossEntropyLoss, torch.nn.MSELoss],</span></span><br><span class="line"><span class="params">    batch_size: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">    dataset: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    local_epochs: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">    valset_ratio: <span class="built_in">float</span>,</span></span><br><span class="line"><span class="params">    logger: rich.console.Console,</span></span><br><span class="line"><span class="params">    gpu: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="comment">#设备选择：根据传入的gpu参数和torch.cuda.is_available()的结果，选择使用CPU还是GPU进行计算。</span></span><br><span class="line">    <span class="keyword">if</span> gpu <span class="keyword">and</span> torch.cuda.is_available():</span><br><span class="line">        self.device = torch.device(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.device = torch.device(<span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">    <span class="comment">#日志记录器：将传入的logger实例保存在类的实例变量中，以便在类的其他方法中使用。</span></span><br><span class="line">    self.logger = logger</span><br><span class="line">	<span class="comment">#本地训练参数：保存了本地训练轮数（local_epochs）和损失函数（criterion）。</span></span><br><span class="line">    self.local_epochs = local_epochs</span><br><span class="line">    self.criterion = criterion</span><br><span class="line">    <span class="comment">#客户端ID和模型：保存了客户端ID（client_id）和全局模型的深拷贝（global_model）。</span></span><br><span class="line">    self.<span class="built_in">id</span> = client_id</span><br><span class="line">    self.model = deepcopy(global_model)</span><br><span class="line">    <span class="comment">#学习率参数：保存了alpha和beta参数，这些参数可能是优化算法的一部分。</span></span><br><span class="line">    self.alpha = alpha</span><br><span class="line">    self.beta = beta</span><br><span class="line">    <span class="comment">#数据加载器：调用get_dataloader函数来获取训练和验证的数据加载器（trainloader和valloader）。这个函数根据数据集名称、客户端ID、批量大小和验证集比例来返回相应的数据加载器。</span></span><br><span class="line">    self.trainloader, self.valloader = get_dataloader(</span><br><span class="line">        dataset, client_id, batch_size, valset_ratio</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">#迭代训练加载器：将训练数据加载器转换为迭代器并保存在iter_trainloader中。这样做可能是为了在类的其他方法中方便地从训练集中获取批量数据。</span></span><br><span class="line">    self.iter_trainloader = <span class="built_in">iter</span>(self.trainloader)</span><br></pre></td></tr></table></figure>
<h5 id="函数：get-data-batch-self">函数：get_data_batch(self)</h5>
<p>作用：用于从训练数据加载器中获取下一批数据，并处理<code>StopIteration</code>异常（当迭代器耗尽时触发）。当<code>iter_trainloader</code>中的数据被完全迭代一遍后，该方法会重新初始化迭代器并获取新的数据批次。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_data_batch</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment">#尝试获取数据：try块尝试从self.iter_trainloader（一个迭代器）中获取下一批数据（x为输入数据，y为标签）</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x, y = <span class="built_in">next</span>(self.iter_trainloader)</span><br><span class="line">     <span class="comment">#异常处理：</span></span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        self.iter_trainloader = <span class="built_in">iter</span>(self.trainloader)<span class="comment">#重新初始化iter_trainloader，通过调用iter(self.trainloader)来创建一个新的迭代器。</span></span><br><span class="line">        x, y = <span class="built_in">next</span>(self.iter_trainloader)<span class="comment">#再次尝试从新的迭代器中获取下一批数据。</span></span><br><span class="line">	<span class="comment">#无论数据是直接从原始迭代器中获取，还是通过重新初始化迭代器后获取，都会将数据（x和y）移动到self.device（即CPU或GPU）上，并返回它们。</span></span><br><span class="line">    <span class="keyword">return</span> x.to(self.device), y.to(self.device)</span><br></pre></td></tr></table></figure>
<h5 id="函数：train（）">函数：train（）</h5>
<p>作用：是一个用于在本地客户端上训练模型的函数。该方法接收全局模型、一个布尔值<code>hessian_free</code>（用于指示是否使用Hessian-free优化）和一个布尔值<code>eval_while_training</code>（用于指示是否在训练前后评估模型性能）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params"></span></span><br><span class="line"><span class="params">    self,</span></span><br><span class="line"><span class="params">    global_model: torch.nn.Module,</span></span><br><span class="line"><span class="params">    hessian_free=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params">    eval_while_training=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    self.model.load_state_dict(global_model.state_dict())</span><br><span class="line">    <span class="comment">#训练前评估（可选）：如果eval_while_training为True，则在训练开始前使用utils.eval函数评估模型在验证集上的性能，并保存损失和准确率。</span></span><br><span class="line">    <span class="keyword">if</span> eval_while_training:</span><br><span class="line">        loss_before, acc_before = utils.<span class="built_in">eval</span>(</span><br><span class="line">            self.model, self.valloader, self.criterion, self.device</span><br><span class="line">        )</span><br><span class="line">    <span class="comment">#执行训练：调用_train方法</span></span><br><span class="line">    self._train(hessian_free)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">#训练后评估（可选）：如果eval_while_training为True，则在训练结束后再次使用utils.eval函数评估模型在验证集上的性能，并保存损失和准确率。</span></span><br><span class="line">    <span class="keyword">if</span> eval_while_training:</span><br><span class="line">        loss_after, acc_after = utils.<span class="built_in">eval</span>(</span><br><span class="line">            self.model, self.valloader, self.criterion, self.device</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">#记录并返回模型：使用self.logger记录训练前后的损失和准确率变化。然后，使用SerializationTool.serialize_model方法将训练后的模型序列化为某种格式，并返回该序列化模型。</span></span><br><span class="line">        self.logger.log(</span><br><span class="line">            <span class="string">&quot;client [&#123;&#125;] [red]loss: &#123;:.4f&#125; -&gt; &#123;:.4f&#125;   [blue]acc: &#123;:.2f&#125;% -&gt; &#123;:.2f&#125;%&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                self.<span class="built_in">id</span>,</span><br><span class="line">                loss_before,</span><br><span class="line">                loss_after,</span><br><span class="line">                acc_before * <span class="number">100.0</span>,</span><br><span class="line">                acc_after * <span class="number">100.0</span>,</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> SerializationTool.serialize_model(self.model)</span><br></pre></td></tr></table></figure>
<h5 id="函数：-train">函数：_train()</h5>
<p>作用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_train</span>(<span class="params">self, hessian_free=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="comment">#使用Hessian-free方法的Per-FedAvg（HF）</span></span><br><span class="line">    <span class="comment">#当hessian_free为True时，该方法将执行Hessian-free的Per-FedAvg训练过程。这通常涉及计算二阶导数（Hessian）的近似，以优化模型参数。</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">if</span> hessian_free:  <span class="comment"># Per-FedAvg(HF)</span></span><br><span class="line">        <span class="comment">#对于每个本地训练周期（self.local_epochs），首先复制当前模型（self.model）到一个临时模型（temp_model）中。</span></span><br><span class="line">        <span class="comment">#使用get_data_batch方法获取第一批数据（data_batch_1），并计算关于临时模型的一阶梯度（grads）。</span></span><br><span class="line">        <span class="comment">#使用这些梯度来更新临时模型的参数（这里使用了简单的SGD更新，但学习率self.alpha可能需要根据实际情况调整）。</span></span><br><span class="line">        <span class="comment">#接着，获取第二批数据（data_batch_2），并再次计算关于临时模型的一阶梯度（grads_1st）。</span></span><br><span class="line">        <span class="comment">#然后，获取第三批数据（data_batch_3），但这次计算的是关于原始模型（self.model）的二阶梯度（Hessian向量积，即grads_2nd）。注意，这里的计算可能需要特定的函数或库，因为直接计算完整的Hessian矩阵是计算密集且不可行的。</span></span><br><span class="line">        <span class="comment">#最后，使用这些一阶梯度和二阶梯度来更新原始模型的参数。更新规则似乎结合了梯度下降和二阶优化方法（具体是哪种方法取决于self.beta和self.alpha的值）。</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.local_epochs):</span><br><span class="line">            temp_model = deepcopy(self.model)</span><br><span class="line">            data_batch_1 = self.get_data_batch()</span><br><span class="line">            grads = self.compute_grad(temp_model, data_batch_1)</span><br><span class="line">            <span class="keyword">for</span> param, grad <span class="keyword">in</span> <span class="built_in">zip</span>(temp_model.parameters(), grads):</span><br><span class="line">                param.data.sub_(self.alpha * grad)</span><br><span class="line"></span><br><span class="line">            data_batch_2 = self.get_data_batch()</span><br><span class="line">            grads_1st = self.compute_grad(temp_model, data_batch_2)</span><br><span class="line"></span><br><span class="line">            data_batch_3 = self.get_data_batch()</span><br><span class="line"></span><br><span class="line">            grads_2nd = self.compute_grad(</span><br><span class="line">                self.model, data_batch_3, v=grads_1st, second_order_grads=<span class="literal">True</span></span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># <span class="doctag">NOTE:</span> Go check https://github.com/KarhouTam/Per-FedAvg/issues/2 if you confuse about the model update.</span></span><br><span class="line">            <span class="keyword">for</span> param, grad1, grad2 <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">                self.model.parameters(), grads_1st, grads_2nd</span><br><span class="line">            ):</span><br><span class="line">                param.data.sub_(self.beta * grad1 - self.beta * self.alpha * grad2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># Per-FedAvg(FO）</span></span><br><span class="line">        	<span class="comment">#只使用一阶梯度的Per-FedAvg（FO）</span></span><br><span class="line">            <span class="comment">#首先在一个临时模型（temp_model）上计算第一个数据批次（data_batch_1）的梯度，并更新临时模型的参数。</span></span><br><span class="line">            <span class="comment">#然后，它获取第二个数据批次（data_batch_2）并计算梯度，但这次它直接在原始模型（self.model）上应用这些梯度的更新，而不是临时模型。</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.local_epochs):</span><br><span class="line">            <span class="comment"># ========================== FedAvg ==========================</span></span><br><span class="line">            <span class="comment"># <span class="doctag">NOTE:</span> You can uncomment those codes for running FedAvg.</span></span><br><span class="line">            <span class="comment">#       When you&#x27;re trying to run FedAvg, comment other codes in this branch.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># data_batch = self.get_data_batch()</span></span><br><span class="line">            <span class="comment"># grads = self.compute_grad(self.model, data_batch)</span></span><br><span class="line">            <span class="comment"># for param, grad in zip(self.model.parameters(), grads):</span></span><br><span class="line">            <span class="comment">#     param.data.sub_(self.beta * grad)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># ============================================================</span></span><br><span class="line"></span><br><span class="line">            temp_model = deepcopy(self.model)</span><br><span class="line">            data_batch_1 = self.get_data_batch()</span><br><span class="line">            grads = self.compute_grad(temp_model, data_batch_1)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> param, grad <span class="keyword">in</span> <span class="built_in">zip</span>(temp_model.parameters(), grads):</span><br><span class="line">                param.data.sub_(self.alpha * grad)</span><br><span class="line"></span><br><span class="line">            data_batch_2 = self.get_data_batch()</span><br><span class="line">            grads = self.compute_grad(temp_model, data_batch_2)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> param, grad <span class="keyword">in</span> <span class="built_in">zip</span>(self.model.parameters(), grads):</span><br><span class="line">                param.data.sub_(self.beta * grad)</span><br></pre></td></tr></table></figure>
<h5 id="函数：compute-grad">函数：compute_grad()</h5>
<p>作用：根据给定的数据批次<code>data_batch</code>计算模型<code>model</code>的梯度。如果<code>second_order_grads</code>为<code>True</code>，它将计算二阶梯度（Hessian-vector积的一个近似），否则，它将计算标准的一阶梯度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute_grad</span>(<span class="params"></span></span><br><span class="line"><span class="params">    self,</span></span><br><span class="line"><span class="params">    model: torch.nn.Module,</span></span><br><span class="line"><span class="params">    data_batch: <span class="type">Tuple</span>[torch.Tensor, torch.Tensor],</span></span><br><span class="line"><span class="params">    v: <span class="type">Union</span>[<span class="type">Tuple</span>[torch.Tensor, ...], <span class="literal">None</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    second_order_grads=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    x, y = data_batch</span><br><span class="line">    <span class="keyword">if</span> second_order_grads:</span><br><span class="line">        frz_model_params = deepcopy(model.state_dict())</span><br><span class="line">        delta = <span class="number">1e-3</span></span><br><span class="line">        dummy_model_params_1 = OrderedDict()</span><br><span class="line">        dummy_model_params_2 = OrderedDict()</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            <span class="keyword">for</span> (layer_name, param), grad <span class="keyword">in</span> <span class="built_in">zip</span>(model.named_parameters(), v):</span><br><span class="line">                dummy_model_params_1.update(&#123;layer_name: param + delta * grad&#125;)</span><br><span class="line">                dummy_model_params_2.update(&#123;layer_name: param - delta * grad&#125;)</span><br><span class="line"></span><br><span class="line">        model.load_state_dict(dummy_model_params_1, strict=<span class="literal">False</span>)</span><br><span class="line">        logit_1 = model(x)</span><br><span class="line">        loss_1 = self.criterion(logit_1, y)</span><br><span class="line">        grads_1 = torch.autograd.grad(loss_1, model.parameters())</span><br><span class="line"></span><br><span class="line">        model.load_state_dict(dummy_model_params_2, strict=<span class="literal">False</span>)</span><br><span class="line">        logit_2 = model(x)</span><br><span class="line">        loss_2 = self.criterion(logit_2, y)</span><br><span class="line">        grads_2 = torch.autograd.grad(loss_2, model.parameters())</span><br><span class="line"></span><br><span class="line">        model.load_state_dict(frz_model_params)</span><br><span class="line"></span><br><span class="line">        grads = []</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            <span class="keyword">for</span> g1, g2 <span class="keyword">in</span> <span class="built_in">zip</span>(grads_1, grads_2):</span><br><span class="line">                grads.append((g1 - g2) / (<span class="number">2</span> * delta))</span><br><span class="line">        <span class="keyword">return</span> grads</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logit = model(x)</span><br><span class="line">        loss = self.criterion(logit, y)</span><br><span class="line">        grads = torch.autograd.grad(loss, model.parameters())</span><br><span class="line">        <span class="keyword">return</span> grads</span><br></pre></td></tr></table></figure>
<h5 id="函数：pers-N-eval">函数：pers_N_eval()</h5>
<p>作用：在给定全局模型（<code>global_model</code>）和个性化训练轮次（<code>pers_epochs</code>）之后，该函数首先加载全局模型的参数到客户端的本地模型（<code>self.model</code>），然后在本地数据集上进行训练和评估。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pers_N_eval</span>(<span class="params">self, global_model: torch.nn.Module, pers_epochs: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="comment">#加载全局模型参数：</span></span><br><span class="line">    self.model.load_state_dict(global_model.state_dict())</span><br><span class="line">	</span><br><span class="line">    <span class="comment">#评估初始模型性能：</span></span><br><span class="line">    loss_before, acc_before = utils.<span class="built_in">eval</span>(</span><br><span class="line">        self.model, self.valloader, self.criterion, self.device</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">#定义优化器：</span></span><br><span class="line">    optimizer = torch.optim.SGD(self.model.parameters(), lr=self.alpha)</span><br><span class="line">    <span class="comment">#个性化训练：这部分代码执行了 pers_epochs 轮次的个性化训练。在每次迭代中，它首先从 self.get_data_batch() 获取一个数据批次，然后使用这个数据批次来更新模型的参数。</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(pers_epochs):</span><br><span class="line">        x, y = self.get_data_batch()</span><br><span class="line">        logit = self.model(x)</span><br><span class="line">        loss = self.criterion(logit, y)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">     <span class="comment">#评估训练后的模型性能：在个性化训练完成后，再次评估模型的性能。</span></span><br><span class="line">    loss_after, acc_after = utils.<span class="built_in">eval</span>(</span><br><span class="line">        self.model, self.valloader, self.criterion, self.device</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">#记录并输出日志：使用日志记录器（self.logger）来记录训练前后的损失和准确率。这里还使用了颜色代码（如 [red] 和 [blue]），但这些可能不会在纯文本日志中显示，除非日志记录器进</span></span><br><span class="line">    self.logger.log(</span><br><span class="line">        <span class="string">&quot;client [&#123;&#125;] [red]loss: &#123;:.4f&#125; -&gt; &#123;:.4f&#125;   [blue]acc: &#123;:.2f&#125;% -&gt; &#123;:.2f&#125;%&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            self.<span class="built_in">id</span>, loss_before, loss_after, acc_before * <span class="number">100.0</span>, acc_after * <span class="number">100.0</span></span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">#返回评估结果：</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;loss_before&quot;</span>: loss_before,</span><br><span class="line">        <span class="string">&quot;acc_before&quot;</span>: acc_before,</span><br><span class="line">        <span class="string">&quot;loss_after&quot;</span>: loss_after,</span><br><span class="line">        <span class="string">&quot;acc_after&quot;</span>: acc_after,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="main-py"><a href="http://main.py">main.py</a></h4>
<p>用于启动分布式或联邦学习中的客户端或服务器进程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    </span><br><span class="line">    args = get_args()<span class="comment">#使用get_args()从命令行获取参数，并将这些参数存储在一个对象中</span></span><br><span class="line">    fix_random_seed(args.seed)<span class="comment">#用于设置随机种子，确保实验的可重复性。</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(<span class="string">&quot;./log&quot;</span>) == <span class="literal">False</span>:<span class="comment">#这行代码检查当前目录下是否存在一个名为log的目录。如果不存在，则执行下一行代码。</span></span><br><span class="line">        os.mkdir(<span class="string">&quot;./log&quot;</span>)<span class="comment">#如果log目录不存在，这行代码会创建它。os.mkdir用于创建新目录。</span></span><br><span class="line">    <span class="comment">#首先，检查args对象中是否有gpu参数且其值为True；其次，检查是否有可用的CUDA设备（即是否有NVIDIA GPU并安装了适当的CUDA和PyTorch版本）。</span></span><br><span class="line">    <span class="keyword">if</span> args.gpu <span class="keyword">and</span> torch.cuda.is_available():</span><br><span class="line">        device = torch.device(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        device = torch.device(<span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">     </span><br><span class="line">    global_model = get_model(args.dataset, device)<span class="comment">#创建了一个日志记录器对象logger</span></span><br><span class="line">    logger = Console(record=args.log)</span><br><span class="line">    logger.log(<span class="string">f&quot;Arguments:&quot;</span>, <span class="built_in">dict</span>(args._get_kwargs()))</span><br><span class="line">    clients_4_training, clients_4_eval, client_num_in_total = get_client_id_indices(</span><br><span class="line">        args.dataset</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># init clients </span></span><br><span class="line">    <span class="comment">#初始化一个客户端列表，每个客户端都是PerFedAvgClient类的实例。</span></span><br><span class="line">    clients = [</span><br><span class="line">        PerFedAvgClient(</span><br><span class="line">            client_id=client_id,</span><br><span class="line">            alpha=args.alpha,</span><br><span class="line">            beta=args.beta,</span><br><span class="line">            global_model=global_model,</span><br><span class="line">            criterion=torch.nn.CrossEntropyLoss(),</span><br><span class="line">            batch_size=args.batch_size,</span><br><span class="line">            dataset=args.dataset,</span><br><span class="line">            local_epochs=args.local_epochs,</span><br><span class="line">            valset_ratio=args.valset_ratio,</span><br><span class="line">            logger=logger,</span><br><span class="line">            gpu=args.gpu,</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">for</span> client_id <span class="keyword">in</span> <span class="built_in">range</span>(client_num_in_total)</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment"># training</span></span><br><span class="line">    <span class="comment">#开始训练过程的，并且它使用了日志记录器（logger）来输出到log。</span></span><br><span class="line">    logger.log(<span class="string">&quot;=&quot;</span> * <span class="number">20</span>, <span class="string">&quot;TRAINING&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">20</span>, style=<span class="string">&quot;bold red&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> track(			<span class="comment">#全局训练循环:</span></span><br><span class="line">        <span class="built_in">range</span>(args.global_epochs), <span class="string">&quot;Training...&quot;</span>, console=logger, disable=args.log</span><br><span class="line">    ):</span><br><span class="line">        <span class="comment"># select clients   </span></span><br><span class="line">        <span class="comment">#选择客户端:在每次全局迭代中，代码从clients_4_training中随机选择args.client_num_per_round个客户端进行本地训练。</span></span><br><span class="line">        selected_clients = random.sample(clients_4_training, args.client_num_per_round)</span><br><span class="line"></span><br><span class="line">        model_params_cache = []</span><br><span class="line">        <span class="comment"># client local training 客户端本地训练</span></span><br><span class="line">        <span class="comment">#对于选定的每个客户端，代码执行train方法。该方法以当前的全局模型作为起点，并可能在本地数据集上进行训练。train方法返回序列化后的模型参数，这些参数被添加到model_params_cache列表中。</span></span><br><span class="line">        <span class="keyword">for</span> client_id <span class="keyword">in</span> selected_clients:</span><br><span class="line">            serialized_model_params = clients[client_id].train(</span><br><span class="line">                global_model=global_model,</span><br><span class="line">                hessian_free=args.hf,</span><br><span class="line">                eval_while_training=args.eval_while_training,</span><br><span class="line">            )</span><br><span class="line">            model_params_cache.append(serialized_model_params)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># aggregate model parameters聚合模型参数:</span></span><br><span class="line">        <span class="comment">#在所有选定的客户端完成本地训练后，代码使用fedavg_aggregate函数（来聚合模型参数。这个函数将model_params_cache列表中的模型参数进行聚合（通常使用FedAvg算法，即加权平均）。然后，使用deserialize_model函数将聚合后的模型参数反序列化并应用到global_model上，从而更新全局模型。</span></span><br><span class="line">        aggregated_model_params = Aggregators.fedavg_aggregate(model_params_cache)</span><br><span class="line">        SerializationTool.deserialize_model(global_model, aggregated_model_params)</span><br><span class="line">        <span class="comment">#分隔符日志:</span></span><br><span class="line">        <span class="comment">#最后，代码使用logger对象输出一个由60个等号字符组成的分隔符，可能用于在日志中分隔不同的全局迭代轮次</span></span><br><span class="line">        logger.log(<span class="string">&quot;=&quot;</span> * <span class="number">60</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#描述了联邦学习中的评估过程，并且它记录了模型在评估前后的性能。</span></span><br><span class="line">    <span class="comment"># eval</span></span><br><span class="line">    pers_epochs = args.local_epochs <span class="keyword">if</span> args.pers_epochs == -<span class="number">1</span> <span class="keyword">else</span> args.pers_epochs <span class="comment">#确定持久化轮次（Persistent Epochs）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#开始评估日志</span></span><br><span class="line">    <span class="comment">#初始化评估结果列表</span></span><br><span class="line">    <span class="comment">#这四个列表用于存储每个客户端在评估前后的损失和准确率。</span></span><br><span class="line">    logger.log(<span class="string">&quot;=&quot;</span> * <span class="number">20</span>, <span class="string">&quot;EVALUATION&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">20</span>, style=<span class="string">&quot;bold blue&quot;</span>)</span><br><span class="line">    loss_before = []</span><br><span class="line">    loss_after = []</span><br><span class="line">    acc_before = []</span><br><span class="line">    acc_after = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#客户端评估循环</span></span><br><span class="line">    <span class="comment">#代码遍历clients_4_eval列表中的每个客户端ID，并对每个客户端执行pers_N_eval方法。这个方法在评估前对模型进行本地训练（使用pers_epochs指定的轮次），然后评估模型的性能，并返回一个包含损失和准确率的字典。这些值随后被添加到相应的列表中。</span></span><br><span class="line">    <span class="keyword">for</span> client_id <span class="keyword">in</span> track(</span><br><span class="line">        clients_4_eval, <span class="string">&quot;Evaluating...&quot;</span>, console=logger, disable=args.log</span><br><span class="line">    ):</span><br><span class="line">        stats = clients[client_id].pers_N_eval(</span><br><span class="line">            global_model=global_model, pers_epochs=pers_epochs,</span><br><span class="line">        )</span><br><span class="line">        loss_before.append(stats[<span class="string">&quot;loss_before&quot;</span>])</span><br><span class="line">        loss_after.append(stats[<span class="string">&quot;loss_after&quot;</span>])</span><br><span class="line">        acc_before.append(stats[<span class="string">&quot;acc_before&quot;</span>])</span><br><span class="line">        acc_after.append(stats[<span class="string">&quot;acc_after&quot;</span>])</span><br><span class="line">	</span><br><span class="line">    <span class="comment">#输出评估结果</span></span><br><span class="line">    <span class="comment">#代码使用logger对象输出评估结果。它计算了所有客户端的平均损失和准确率，并将它们以格式化的方式输出。</span></span><br><span class="line">    logger.log(<span class="string">&quot;=&quot;</span> * <span class="number">20</span>, <span class="string">&quot;RESULTS&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">20</span>, style=<span class="string">&quot;bold green&quot;</span>)</span><br><span class="line">    logger.log(<span class="string">f&quot;loss_before_pers: <span class="subst">&#123;(<span class="built_in">sum</span>(loss_before) / <span class="built_in">len</span>(loss_before)):<span class="number">.4</span>f&#125;</span>&quot;</span>)</span><br><span class="line">    logger.log(<span class="string">f&quot;acc_before_pers: <span class="subst">&#123;(<span class="built_in">sum</span>(acc_before) * <span class="number">100.0</span> / <span class="built_in">len</span>(acc_before)):<span class="number">.2</span>f&#125;</span>%&quot;</span>)</span><br><span class="line">    logger.log(<span class="string">f&quot;loss_after_pers: <span class="subst">&#123;(<span class="built_in">sum</span>(loss_after) / <span class="built_in">len</span>(loss_after)):<span class="number">.4</span>f&#125;</span>&quot;</span>)</span><br><span class="line">    logger.log(<span class="string">f&quot;acc_after_pers: <span class="subst">&#123;(<span class="built_in">sum</span>(acc_after) * <span class="number">100.0</span> / <span class="built_in">len</span>(acc_after)):<span class="number">.2</span>f&#125;</span>%&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#保存评估结果（如果启用日志）</span></span><br><span class="line">    <span class="keyword">if</span> args.log:</span><br><span class="line">        algo = <span class="string">&quot;HF&quot;</span> <span class="keyword">if</span> args.hf <span class="keyword">else</span> <span class="string">&quot;FO&quot;</span></span><br><span class="line">        logger.save_html(</span><br><span class="line">            <span class="string">f&quot;./log/<span class="subst">&#123;args.dataset&#125;</span>_<span class="subst">&#123;args.client_num_per_round&#125;</span>_<span class="subst">&#123;args.global_epochs&#125;</span>_<span class="subst">&#123;pers_epochs&#125;</span>_<span class="subst">&#123;algo&#125;</span>.html&quot;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<h3 id="Per-FeAVG源码分析——data目录下：">Per_FeAVG源码分析——data目录下：</h3>
<h4 id="init-py"><a href="http://init.py">init.py</a></h4>
<p>不做分析</p>
<h4 id="utils-py-2"><a href="http://utils.py">utils.py</a></h4>
<h5 id="字典：DATASET-DICT">字典：DATASET_DICT</h5>
<p>作用：它将字符串键（如 <code>&quot;mnist&quot;</code> 和 <code>&quot;cifar&quot;</code>）映射到对应的类（<code>MNISTDataset</code> 和 <code>CIFARDataset</code>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATASET_DICT = &#123;</span><br><span class="line">    <span class="string">&quot;mnist&quot;</span>: MNISTDataset,</span><br><span class="line">    <span class="string">&quot;cifar&quot;</span>: CIFARDataset,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="函数：CURRENT-DIR">函数：CURRENT_DIR</h5>
<p>作用：<code>CURRENT_DIR</code> 被设置为当前 Python 脚本文件的父目录的绝对路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CURRENT_DIR = Path(__file__).parent.abspath()</span><br></pre></td></tr></table></figure>
<h5 id="函数：get-dataloader">函数：get_dataloader</h5>
<p>作用：从一个预处理好的 pickle 文件中加载数据集，并根据给定的 <code>client_id</code> 分割为训练集和验证集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_dataloader</span>(<span class="params">dataset: <span class="built_in">str</span>, client_id: <span class="built_in">int</span>, batch_size=<span class="number">20</span>, valset_ratio=<span class="number">0.1</span></span>):</span><br><span class="line">    pickles_dir = CURRENT_DIR / dataset / <span class="string">&quot;pickles&quot;</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(pickles_dir) <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;Please preprocess and create pickles first.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(pickles_dir / <span class="built_in">str</span>(client_id) + <span class="string">&quot;.pkl&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        client_dataset: DATASET_DICT[dataset] = pickle.load(f)</span><br><span class="line"></span><br><span class="line">    val_num_samples = <span class="built_in">int</span>(valset_ratio * <span class="built_in">len</span>(client_dataset))</span><br><span class="line">    train_num_samples = <span class="built_in">len</span>(client_dataset) - val_num_samples</span><br><span class="line"></span><br><span class="line">    trainset, valset = random_split(</span><br><span class="line">        client_dataset, [train_num_samples, val_num_samples]</span><br><span class="line">    )</span><br><span class="line">    trainloader = DataLoader(trainset, batch_size, drop_last=<span class="literal">True</span>)</span><br><span class="line">    valloader = DataLoader(valset, batch_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> trainloader, valloader</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="函数：get-client-id-indices-dataset">函数：get_client_id_indices(dataset)</h5>
<p>作用：从一个特定的 pickle 文件中加载并返回关于数据集分割的信息。从一个 <code>seperation.pkl</code> 文件中读取训练集、测试集以及总数目的索引或标识符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_client_id_indices</span>(<span class="params">dataset</span>):</span><br><span class="line">    dataset_pickles_path = CURRENT_DIR / dataset / <span class="string">&quot;pickles&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(dataset_pickles_path / <span class="string">&quot;seperation.pkl&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        seperation = pickle.load(f)</span><br><span class="line">    <span class="keyword">return</span> (seperation[<span class="string">&quot;train&quot;</span>], seperation[<span class="string">&quot;test&quot;</span>], seperation[<span class="string">&quot;total&quot;</span>])</span><br></pre></td></tr></table></figure>
<h4 id="preprocess-py"><a href="http://preprocess.py">preprocess.py</a></h4>
<h5 id="函数：CURRENT-DIR-2">函数：CURRENT_DIR</h5>
<p>作用：<code>CURRENT_DIR</code> 被设置为当前 Python 脚本文件的父目录的绝对路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CURRENT_DIR = Path(__file__).parent.abspath()</span><br></pre></td></tr></table></figure>
<h5 id="字典：DATASET">字典：DATASET</h5>
<p>作用：数据集名称映射到了两个元组，可以基于数据集名称来动态地加载和实例化相应的数据集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATASET = &#123;</span><br><span class="line">    <span class="string">&quot;mnist&quot;</span>: (MNIST, MNISTDataset),</span><br><span class="line">    <span class="string">&quot;cifar&quot;</span>: (CIFAR10, CIFARDataset),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="字典：MEAN">字典：MEAN</h5>
<p>作用：用来存储不同数据集的像素均值。这些均值通常用于数据归一化，只包含一个灰度通道，因此其均值是一个单元素元组 <code>(0.1307,)</code>。这意味着当你对 MNIST 数据集进行归一化时，你会从每个像素值中减去 0.1307。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MEAN = &#123;</span><br><span class="line">    <span class="string">&quot;mnist&quot;</span>: (<span class="number">0.1307</span>,),</span><br><span class="line">    <span class="string">&quot;cifar&quot;</span>: (<span class="number">0.4914</span>, <span class="number">0.4822</span>, <span class="number">0.4465</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="字典：STD">字典：STD</h5>
<p>作用：存储不同数据集的像素标准差。使用归一化时，标准差通常与均值一起使用，以确保数据的每个特征（在这个案例中是像素值）都有相似的尺度。它只包含一个灰度通道，因此其标准差是一个单元素元组 <code>(0.3015,)</code>。这意味着在归一化 MNIST 数据时，每个像素值都会根据其灰度通道的标准差进行缩放。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">STD = &#123;</span><br><span class="line">    <span class="string">&quot;mnist&quot;</span>: (<span class="number">0.3015</span>,),</span><br><span class="line">    <span class="string">&quot;cifar&quot;</span>: (<span class="number">0.2023</span>, <span class="number">0.1994</span>, <span class="number">0.2010</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="函数：preprocess">函数：preprocess()</h5>
<p>作用：用于预处理数据集，在联邦学习或分布式学习的场景中，数据需要在多个客户端（或节点）之间分配。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preprocess</span>(<span class="params">args: Namespace</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="comment">#参数和目录设置：</span></span><br><span class="line">    <span class="comment">#设置数据集目录（dataset_dir）和pickle文件目录（pickles_dir）。</span></span><br><span class="line">    dataset_dir = CURRENT_DIR / args.dataset</span><br><span class="line">    pickles_dir = CURRENT_DIR / args.dataset / <span class="string">&quot;pickles&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#设置随机数生成器的种子，以确保结果的可重复性。</span></span><br><span class="line">    np.random.seed(args.seed)</span><br><span class="line">    random.seed(args.seed)</span><br><span class="line">    torch.manual_seed(args.seed)</span><br><span class="line">    num_train_clients = <span class="built_in">int</span>(args.client_num_in_total * args.fraction)</span><br><span class="line">    num_test_clients = args.client_num_in_total - num_train_clients</span><br><span class="line"></span><br><span class="line">    <span class="comment">#数据转换</span></span><br><span class="line">    <span class="comment">#定义了一个转换transform，它只包含标准化（假设MEAN和STD是预定义的字典，包含了每个数据集的均值和标准差），初始化了训练集和测试集的统计信息字典</span></span><br><span class="line">    transform = transforms.Compose(</span><br><span class="line">        [transforms.Normalize(MEAN[args.dataset], STD[args.dataset]),]</span><br><span class="line">    )</span><br><span class="line">    target_transform = <span class="literal">None</span></span><br><span class="line">    trainset_stats = &#123;&#125;</span><br><span class="line">    testset_stats = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#目录和文件处理：</span></span><br><span class="line">    <span class="comment">#检查数据集目录是否存在，如果不存在则创建它。</span></span><br><span class="line">    <span class="comment">#如果pickle目录已经存在，则删除它（可能是为了确保没有旧的pickle文件干扰）。</span></span><br><span class="line">    <span class="comment">#创建新的pickle目录。</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(CURRENT_DIR / args.dataset):</span><br><span class="line">        os.mkdir(CURRENT_DIR / args.dataset)</span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(pickles_dir):</span><br><span class="line">        os.system(<span class="string">f&quot;rm -rf <span class="subst">&#123;pickles_dir&#125;</span>&quot;</span>)</span><br><span class="line">    os.mkdir(<span class="string">f&quot;<span class="subst">&#123;pickles_dir&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#加载数据集</span></span><br><span class="line">    <span class="comment">#从预定义的DATASET字典中获取原始和目标数据集。</span></span><br><span class="line">    <span class="comment">#使用ori_dataset类创建训练集和测试集。注意，训练集在加载时还指定了download=True（用于自动下载数据集），而测试集没有。两者都使用了transforms.ToTensor()进行初步的数据转换。</span></span><br><span class="line">    ori_dataset, target_dataset = DATASET[args.dataset]</span><br><span class="line">    trainset = ori_dataset(</span><br><span class="line">        dataset_dir, train=<span class="literal">True</span>, download=<span class="literal">True</span>, transform=transforms.ToTensor()</span><br><span class="line">    )</span><br><span class="line">    testset = ori_dataset(dataset_dir, train=<span class="literal">False</span>, transform=transforms.ToTensor())</span><br><span class="line"></span><br><span class="line">    <span class="comment">#分配类别到客户端</span></span><br><span class="line">    <span class="comment">#根据args.classes确定每个客户端应有的类别数量（默认为10类）</span></span><br><span class="line">    <span class="comment">#使用randomly_alloc_classes函数将类别随机分配给训练集和测试集的客户端</span></span><br><span class="line">    <span class="comment">#randomly_alloc_classes函数还返回每个子集的统计信息（</span></span><br><span class="line">    num_classes = <span class="number">10</span> <span class="keyword">if</span> args.classes &lt;= <span class="number">0</span> <span class="keyword">else</span> args.classes</span><br><span class="line">    all_trainsets, trainset_stats = randomly_alloc_classes(</span><br><span class="line">        ori_dataset=trainset,</span><br><span class="line">        target_dataset=target_dataset,</span><br><span class="line">        num_clients=num_train_clients,</span><br><span class="line">        num_classes=num_classes,</span><br><span class="line">        transform=transform,</span><br><span class="line">        target_transform=target_transform,</span><br><span class="line">    )</span><br><span class="line">    all_testsets, testset_stats = randomly_alloc_classes(</span><br><span class="line">        ori_dataset=testset,</span><br><span class="line">        target_dataset=target_dataset,</span><br><span class="line">        num_clients=num_test_clients,</span><br><span class="line">        num_classes=num_classes,</span><br><span class="line">        transform=transform,</span><br><span class="line">        target_transform=target_transform,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">#将所有训练集和测试集组合到一个列表all_datasets中</span></span><br><span class="line">    all_datasets = all_trainsets + all_testsets</span><br><span class="line"></span><br><span class="line">    <span class="comment">#保存客户端数据集为pickle文件</span></span><br><span class="line">    <span class="comment">#通过enumerate(all_datasets)遍历all_datasets列表中的每个数据集和对应的client_id（即客户端的ID）。</span></span><br><span class="line">    <span class="comment">#使用pathlib的/操作符（如果pickles_dir是pathlib.Path对象）来构建pickle文件的路径。</span></span><br><span class="line">    <span class="comment">#使用pickle.dump()函数将每个数据集保存到对应的pickle文件中。</span></span><br><span class="line">    <span class="keyword">for</span> client_id, dataset <span class="keyword">in</span> <span class="built_in">enumerate</span>(all_datasets):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(pickles_dir / <span class="built_in">str</span>(client_id) + <span class="string">&quot;.pkl&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            pickle.dump(dataset, f)</span><br><span class="line">     </span><br><span class="line">    <span class="comment">#保存客户端索引</span></span><br><span class="line">    <span class="comment">#创建一个字典，其中包含三个键：“train”、“test”和“total”，“total”的值就是总的客户端数量。</span></span><br><span class="line">    <span class="comment">#“train”和“test”的值是客户端ID的列表，分别代表训练集和测试集的客户端。这里假设num_train_clients表示训练集客户端的数量，而args.client_num_in_total表示总的客户端数量。</span></span><br><span class="line">    <span class="comment">#使用pickle.dump()函数将这个字典保存到名为“seperation.pkl”的文件中。这个文件用于在后续的训练和测试过程中区分哪些客户端是训练集，哪些是测试集</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(pickles_dir / <span class="string">&quot;seperation.pkl&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        pickle.dump(</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;train&quot;</span>: [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_train_clients)],</span><br><span class="line">                <span class="string">&quot;test&quot;</span>: [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_train_clients, args.client_num_in_total)],</span><br><span class="line">                <span class="string">&quot;total&quot;</span>: args.client_num_in_total,</span><br><span class="line">            &#125;,</span><br><span class="line">            f,</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#保存数据集统计信息</span></span><br><span class="line">    <span class="comment">#trainset_stats和testset_stats是在之前的预处理步骤中收集的训练集和测试集的统计信息。</span></span><br><span class="line">    <span class="comment">#使用json.dump()函数将这些统计信息保存为JSON格式的文件“all_stats.json”。这个文件用于在后续的模型训练和评估过程中提供数据集的相关信息</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(dataset_dir / <span class="string">&quot;all_stats.json&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        json.dump(&#123;<span class="string">&quot;train&quot;</span>: trainset_stats, <span class="string">&quot;test&quot;</span>: testset_stats&#125;, f)</span><br></pre></td></tr></table></figure>
<h5 id="函数：randomly-alloc-classes">函数：randomly_alloc_classes</h5>
<p>作用：将原始数据集（<code>ori_dataset</code>）中的样本随机分配给多个客户端（或用户），同时确保每个客户端获得指定数量的不同类别的样本。函数还返回了分配给每个客户端的数据集列表和相应的统计信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">randomly_alloc_classes</span>(<span class="params"></span></span><br><span class="line"><span class="params">    ori_dataset: Dataset,</span></span><br><span class="line"><span class="params">    target_dataset: Dataset,</span></span><br><span class="line"><span class="params">    num_clients: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">    num_classes: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">    transform=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    target_transform=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="type">Tuple</span>[<span class="type">List</span>[Dataset], <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]]]:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#分配样本</span></span><br><span class="line">    <span class="comment">#使用noniid_slicing函数来将ori_dataset中的样本分配给num_clients个客户端。这个函数应该返回一个字典，其中键是客户端ID，值是分配给该客户端的样本索引列表。</span></span><br><span class="line">    dict_users = noniid_slicing(ori_dataset, num_clients, num_clients * num_classes)</span><br><span class="line">    stats = &#123;&#125;</span><br><span class="line">    <span class="comment">#收集统计信息</span></span><br><span class="line">    <span class="comment">#对于每个客户端，从ori_dataset中提取标签（ori_dataset.targets），然后根据分配给该客户端的样本索引列表计算标签的类别分布。这些统计信息被存储在stats字典中。</span></span><br><span class="line">    <span class="keyword">for</span> i, indices <span class="keyword">in</span> dict_users.items():</span><br><span class="line">        targets_numpy = np.array(ori_dataset.targets)</span><br><span class="line">        stats[<span class="string">f&quot;client <span class="subst">&#123;i&#125;</span>&quot;</span>] = &#123;<span class="string">&quot;x&quot;</span>: <span class="number">0</span>, <span class="string">&quot;y&quot;</span>: &#123;&#125;&#125;</span><br><span class="line">        stats[<span class="string">f&quot;client <span class="subst">&#123;i&#125;</span>&quot;</span>][<span class="string">&quot;x&quot;</span>] = <span class="built_in">len</span>(indices)</span><br><span class="line">        stats[<span class="string">f&quot;client <span class="subst">&#123;i&#125;</span>&quot;</span>][<span class="string">&quot;y&quot;</span>] = Counter(targets_numpy[indices].tolist())</span><br><span class="line">    datasets = []</span><br><span class="line">    <span class="comment">#创建数据集</span></span><br><span class="line">    <span class="comment">#使用target_dataset类从ori_dataset中创建子集，每个子集对应于一个客户端。这是通过从ori_dataset中提取分配给该客户端的样本，并传递给target_dataset的构造函数来实现的。</span></span><br><span class="line">    <span class="keyword">for</span> indices <span class="keyword">in</span> dict_users.values():</span><br><span class="line">        datasets.append(</span><br><span class="line">            target_dataset(</span><br><span class="line">                [ori_dataset[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices],</span><br><span class="line">                transform=transform,</span><br><span class="line">                target_transform=target_transform,</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> datasets, stats</span><br></pre></td></tr></table></figure>
<h5 id="函数：-name-“main”">函数：__name__==“main”</h5>
<p>作用：基本的命令行参数解析设置，它使用<code>argparse</code>库来从命令行获取参数。这些参数包括数据集类型、客户端总数、训练客户端的比例、每个客户端数据所属的类别数量以及随机种子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = ArgumentParser()</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--dataset&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, choices=[<span class="string">&quot;mnist&quot;</span>, <span class="string">&quot;cifar&quot;</span>], default=<span class="string">&quot;mnist&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--client_num_in_total&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">200</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--fraction&quot;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.9</span>, <span class="built_in">help</span>=<span class="string">&quot;Propotion of train clients&quot;</span></span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--classes&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        default=<span class="number">2</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Num of classes that one client&#x27;s data belong to.&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--seed&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">0</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    preprocess(args)</span><br></pre></td></tr></table></figure>
<h4 id="dataset-py"><a href="http://dataset.py">dataset.py</a></h4>
<h5 id="类：MNISTDataset-Dataset">类：MNISTDataset(Dataset)</h5>
<h6 id="函数：init-2">函数：init</h6>
<p>作用：用于初始化一个对象的状态</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="comment">#参数</span></span></span><br><span class="line"><span class="params">    self,</span></span><br><span class="line"><span class="params">    subset=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    data=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    targets=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    transform=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    target_transform=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="comment">#处理</span></span><br><span class="line">    self.transform = transform</span><br><span class="line">    self.target_transform = target_transform</span><br><span class="line">    <span class="comment">#如果data和targets都非空，它将data增加一个新的维度（使用unsqueeze(1)），并将data和targets设置为对象的属性。</span></span><br><span class="line">    <span class="keyword">if</span> (data <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">and</span> (targets <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>):</span><br><span class="line">        self.data = data.unsqueeze(<span class="number">1</span>)</span><br><span class="line">        self.targets = targets</span><br><span class="line">    <span class="comment"># 如果subset非空，它将遍历subset，检查元组中的每个元素是否为张量。如果不是，它将使用torch.tensor将其转换为张量。然后，它使用torch.stack将数据和标签分别堆叠成张量，并设置为对象的属性。   </span></span><br><span class="line">    <span class="keyword">elif</span> subset <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self.data = torch.stack(</span><br><span class="line">            <span class="built_in">list</span>(</span><br><span class="line">                <span class="built_in">map</span>(</span><br><span class="line">                    <span class="keyword">lambda</span> tup: tup[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">isinstance</span>(tup[<span class="number">0</span>], torch.Tensor)</span><br><span class="line">                    <span class="keyword">else</span> torch.tensor(tup[<span class="number">0</span>]),</span><br><span class="line">                    subset,</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">        self.targets = torch.stack(</span><br><span class="line">            <span class="built_in">list</span>(</span><br><span class="line">                <span class="built_in">map</span>(</span><br><span class="line">                    <span class="keyword">lambda</span> tup: tup[<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">isinstance</span>(tup[<span class="number">1</span>], torch.Tensor)</span><br><span class="line">                    <span class="keyword">else</span> torch.tensor(tup[<span class="number">1</span>]),</span><br><span class="line">                    subset,</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    <span class="comment">#如果data和targets以及subset都为空，则抛出一个ValueError，说明需要提供数据格式。</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(</span><br><span class="line">            <span class="string">&quot;Data Format: subset: Tuple(data: Tensor / Image / np.ndarray, targets: Tensor) OR data: List[Tensor]  targets: List[Tensor]&quot;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<h6 id="函数：getitem">函数：getitem</h6>
<p>作用：允许类的实例像列表、元组或其他可迭代对象那样进行索引访问。在你提供的上下文中，这个方法通常用于数据加载器（如PyTorch的<code>DataLoader</code>），以便在训练或评估模型时能够按索引访问数据集中的单个样本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">    data, targets = self.data[index], self.targets[index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        data = self.transform(self.data[index])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.target_transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        targets = self.target_transform(self.targets[index])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data, targets</span><br></pre></td></tr></table></figure>
<h6 id="函数：len">函数：len</h6>
<p>作用：确定self.data的长度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(self.targets)</span><br></pre></td></tr></table></figure>
<h5 id="类：CIFARDataset-Dataset">类：CIFARDataset(Dataset)</h5>
<h6 id="函数：init-3">函数：init</h6>
<p>作用：用于初始化一个对象的状态</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">    self,</span></span><br><span class="line"><span class="params">    subset=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    data=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    targets=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    transform=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    target_transform=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    self.transform = transform</span><br><span class="line">    self.target_transform = target_transform</span><br><span class="line">    <span class="keyword">if</span> (data <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">and</span> (targets <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>):</span><br><span class="line">        self.data = data.unsqueeze(<span class="number">1</span>)</span><br><span class="line">        self.targets = targets</span><br><span class="line">    <span class="keyword">elif</span> subset <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self.data = torch.stack(</span><br><span class="line">            <span class="built_in">list</span>(</span><br><span class="line">                <span class="built_in">map</span>(</span><br><span class="line">                    <span class="keyword">lambda</span> tup: tup[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">isinstance</span>(tup[<span class="number">0</span>], torch.Tensor)</span><br><span class="line">                    <span class="keyword">else</span> torch.tensor(tup[<span class="number">0</span>]),</span><br><span class="line">                    subset,</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">        self.targets = torch.stack(</span><br><span class="line">            <span class="built_in">list</span>(</span><br><span class="line">                <span class="built_in">map</span>(</span><br><span class="line">                    <span class="keyword">lambda</span> tup: tup[<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">isinstance</span>(tup[<span class="number">1</span>], torch.Tensor)</span><br><span class="line">                    <span class="keyword">else</span> torch.tensor(tup[<span class="number">1</span>]),</span><br><span class="line">                    subset,</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(</span><br><span class="line">            <span class="string">&quot;Data Format: subset: Tuple(data: Tensor / Image / np.ndarray, targets: Tensor) OR data: List[Tensor]  targets: List[Tensor]&quot;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<h6 id="函数：getitem-2">函数：getitem</h6>
<p>作用：允许类的实例像列表、元组或其他可迭代对象那样进行索引访问。在你提供的上下文中，这个方法通常用于数据加载器（如PyTorch的<code>DataLoader</code>），以便在训练或评估模型时能够按索引访问数据集中的单个样本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">    img, targets = self.data[index], self.targets[index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        img = self.transform(self.data[index])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.target_transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        targets = self.target_transform(self.targets[index])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> img, targets</span><br></pre></td></tr></table></figure>
<h6 id="函数：len-2">函数：len</h6>
<p>作用：返回长度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(self.targets)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Per_FedAVG</tag>
      </tags>
  </entry>
  <entry>
    <title>STL标准模板库</title>
    <url>/2024/06/26/STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/</url>
    <content><![CDATA[<h3 id="概述：">概述：</h3>
<p>STL（Standard Template Library，标准模板库）是C++标准库的一部分，它提供了大量的模板类和函数，用于执行常见的算法和数据结构操作。STL的主要目的是提供一个统一、高效、可重用的数据结构和算法库，以减少程序员在编写这些基础代码时的重复工作。</p>
<h3 id="优点：">优点：</h3>
<ul>
<li>STL 是 C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</li>
<li>程序员可以不用思考 STL 具体的实现过程，只要能够熟练使用 STL 就 OK 了。</li>
<li>STL 具有高可重用性，高性能，高移植性，跨平台的优点。</li>
</ul>
<h3 id="组成：">组成：</h3>
<ul>
<li>容器、迭代器、算法、函数对象、适配器和分配器</li>
</ul>
<table>
<thead>
<tr>
<th>类别</th>
<th>示例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>容器（Containers）</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>序列容器</td>
<td><code>vector</code></td>
<td>动态数组，支持快速随机访问</td>
</tr>
<tr>
<td></td>
<td><code>deque</code></td>
<td>双端队列，支持在两端快速插入和删除</td>
</tr>
<tr>
<td></td>
<td><code>list</code></td>
<td>双向链表，支持在任何位置快速插入和删除</td>
</tr>
<tr>
<td>关联容器</td>
<td><code>set</code></td>
<td>有序集合，不允许重复元素</td>
</tr>
<tr>
<td></td>
<td><code>multiset</code></td>
<td>有序集合，允许重复元素</td>
</tr>
<tr>
<td></td>
<td><code>map</code></td>
<td>键值对集合，键唯一，值可重复</td>
</tr>
<tr>
<td></td>
<td><code>multimap</code></td>
<td>键值对集合，键可重复</td>
</tr>
<tr>
<td>容器适配器</td>
<td><code>stack</code></td>
<td>后进先出（LIFO）容器</td>
</tr>
<tr>
<td></td>
<td><code>queue</code></td>
<td>先进先出（FIFO）容器</td>
</tr>
<tr>
<td></td>
<td><code>priority_queue</code></td>
<td>优先级队列，元素根据优先级排序</td>
</tr>
<tr>
<td><strong>迭代器（Iterators）</strong></td>
<td></td>
<td>访问容器中元素的通用接口</td>
</tr>
<tr>
<td></td>
<td><code>begin()</code></td>
<td>返回指向容器第一个元素的迭代器</td>
</tr>
<tr>
<td></td>
<td><code>end()</code></td>
<td>返回指向容器尾后位置的迭代器（不指向任何元素）</td>
</tr>
<tr>
<td><strong>算法（Algorithms）</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>sort()</code></td>
<td>对容器中的元素进行排序</td>
</tr>
<tr>
<td></td>
<td><code>find()</code></td>
<td>在容器中查找元素</td>
</tr>
<tr>
<td></td>
<td><code>copy()</code></td>
<td>复制容器中的元素</td>
</tr>
<tr>
<td></td>
<td>…</td>
<td>其他各种算法，如 <code>remove()</code>, <code>reverse()</code>, <code>binary_search()</code> 等</td>
</tr>
<tr>
<td><strong>函数对象（Function Objects）</strong></td>
<td></td>
<td>类似于函数，但可以作为对象传递和存储</td>
</tr>
<tr>
<td></td>
<td><code>less&lt;T&gt;</code></td>
<td>比较两个对象是否小于（默认用于<code>set</code>, <code>map</code>等）</td>
</tr>
<tr>
<td></td>
<td><code>greater&lt;T&gt;</code></td>
<td>比较两个对象是否大于</td>
</tr>
<tr>
<td></td>
<td>自定义函数对象</td>
<td>自定义比较或操作函数</td>
</tr>
<tr>
<td><strong>适配器（Adapters）</strong></td>
<td></td>
<td>修改已有接口以适应不同需求</td>
</tr>
<tr>
<td></td>
<td><code>reverse_iterator</code></td>
<td>反向迭代器，用于反向遍历容器</td>
</tr>
<tr>
<td></td>
<td><code>istream_iterator</code></td>
<td>读取输入流中的元素</td>
</tr>
<tr>
<td></td>
<td><code>ostream_iterator</code></td>
<td>将元素写入输出流</td>
</tr>
<tr>
<td><strong>分配器（Allocators）</strong></td>
<td></td>
<td>管理容器中的内存分配</td>
</tr>
<tr>
<td></td>
<td><code>allocator&lt;T&gt;</code></td>
<td>默认分配器，使用<code>new</code>和<code>delete</code></td>
</tr>
<tr>
<td></td>
<td>自定义分配器</td>
<td>根据特定需求管理内存</td>
</tr>
</tbody>
</table>
<h3 id="常用容器">常用容器</h3>
<h4 id="string容器">string容器</h4>
<h5 id="构造函数：">构造函数：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>();<span class="comment">//创建一个空的字符串 例如: string str;      </span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp; str);<span class="comment">//使用一个string对象初始化另一个string对象</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span>* s);<span class="comment">//使用字符串s初始化</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">int</span> n, <span class="type">char</span> c);<span class="comment">//使用n个字符c初始化 </span></span><br></pre></td></tr></table></figure>
<h5 id="基本赋值：">基本赋值：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span>* s);<span class="comment">//char*类型字符串 赋值给当前的字符串</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>=(<span class="type">const</span> string &amp;s);<span class="comment">//把字符串s赋给当前的字符串</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>=(<span class="type">char</span> c);<span class="comment">//字符赋值给当前的字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;<span class="comment">//把字符串s赋给当前的字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> n)</span></span>;<span class="comment">//把字符串s的前n个字符赋给当前的字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;<span class="comment">//把字符串s赋给当前字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> c)</span></span>;<span class="comment">//用n个字符c赋给当前字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> start, <span class="type">int</span> n)</span></span>;<span class="comment">//将s从start开始n个字符赋值给字符</span></span><br></pre></td></tr></table></figure>
<h5 id="存取字符：">存取字符：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> n);<span class="comment">//通过[]方式取字符</span></span><br><span class="line"><span class="function"><span class="type">char</span>&amp; <span class="title">at</span><span class="params">(<span class="type">int</span> n)</span></span>;<span class="comment">//通过at方法获取字符</span></span><br></pre></td></tr></table></figure>
<h5 id="拼接操作：">拼接操作：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> string&amp; str);<span class="comment">//重载+=操作符</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span>* str);<span class="comment">//重载+=操作符</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span> c);<span class="comment">//重载+=操作符</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;<span class="comment">//把字符串s连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> n)</span></span>;<span class="comment">//把字符串s的前n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;<span class="comment">//同operator+=()</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> pos, <span class="type">int</span> n)</span></span>;<span class="comment">//把字符串s中从pos开始的n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> c)</span></span>;<span class="comment">//在当前字符串结尾添加n个字符c</span></span><br></pre></td></tr></table></figure>
<h5 id="查找替换：">查找替换：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">//查找str第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;  <span class="comment">//查找s第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos, <span class="type">int</span> n)</span> <span class="type">const</span></span>;  <span class="comment">//从pos位置查找s的前n个字符第一次位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;  <span class="comment">//查找字符c第一次出现位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//查找str最后一次位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//查找s最后一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos, <span class="type">int</span> n)</span> <span class="type">const</span></span>;<span class="comment">//从pos查找s的前n个字符最后一次位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">//查找字符c最后一次出现位置</span></span><br><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">const</span> string&amp; str)</span></span>; <span class="comment">//替换从pos开始n个字符为字符串str</span></span><br><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">const</span> <span class="type">char</span>* s)</span></span>; <span class="comment">//替换从pos开始的n个字符为字符串s</span></span><br></pre></td></tr></table></figure>
<h5 id="比较操作：">比较操作：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。</span></span><br><span class="line"><span class="comment">比较区分大小写，比较时参考字典顺序，排越前面的越小。</span></span><br><span class="line"><span class="comment">大写的A比小写的a小。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> string &amp;s)</span> <span class="type">const</span></span>;<span class="comment">//与字符串s比较</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> <span class="type">const</span></span>;<span class="comment">//与字符串s比较</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="取出子串：">取出子串：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">substr</span><span class="params">(<span class="type">int</span> pos = <span class="number">0</span>, <span class="type">int</span> n = npos)</span> <span class="type">const</span></span>;<span class="comment">//返回由pos开始的n个字符组成的字符串</span></span><br></pre></td></tr></table></figure>
<h5 id="插入删除：">插入删除：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">const</span> <span class="type">char</span>* s)</span></span>; <span class="comment">//插入字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">const</span> string&amp; str)</span></span>; <span class="comment">//插入字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">char</span> c)</span></span>;<span class="comment">//在指定位置插入n个字符c</span></span><br><span class="line"><span class="function">string&amp; <span class="title">erase</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n = npos)</span></span>;<span class="comment">//删除从Pos开始的n个字符 </span></span><br></pre></td></tr></table></figure>
<h5 id="c-style转换：">c-style转换：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//string 转 char*</span></span><br><span class="line">string str = <span class="string">&quot;it&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cstr = str.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="comment">//char* 转 string </span></span><br><span class="line"><span class="type">char</span>* s = <span class="string">&quot;it&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(s)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="vector容器">vector容器</h4>
<h5 id="构造函数">构造函数</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;T&gt; v; <span class="comment">//采用模板实现类实现，默认构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">//将v[begin(), end())区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(n, elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector &amp;vec);<span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure>
<h5 id="赋值操作">赋值操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assign</span>(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">assign</span>(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line">vector&amp; <span class="keyword">operator</span>=(<span class="type">const</span> vector  &amp;vec);<span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="built_in">swap</span>(vec);<span class="comment">// 将vec与本身的元素互换。</span></span><br></pre></td></tr></table></figure>
<h5 id="大小操作">大小操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">size</span>();<span class="comment">//返回容器中元素的个数</span></span><br><span class="line"><span class="built_in">empty</span>();<span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="built_in">resize</span>(<span class="type">int</span> num);<span class="comment">//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"><span class="built_in">resize</span>(<span class="type">int</span> num, elem);<span class="comment">//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。</span></span><br><span class="line"><span class="built_in">capacity</span>();<span class="comment">//容器的容量</span></span><br><span class="line"><span class="built_in">reserve</span>(<span class="type">int</span> len);<span class="comment">//容器预留len个元素长度，预留位置不初始化，元素不可访问。</span></span><br></pre></td></tr></table></figure>
<h5 id="数据存取">数据存取</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">at</span>(<span class="type">int</span> idx); <span class="comment">//返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</span></span><br><span class="line"><span class="keyword">operator</span>[];<span class="comment">//返回索引idx所指的数据，越界时，运行直接报错</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回容器中第一个数据元素</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回容器中最后一个数据元素</span></span><br></pre></td></tr></table></figure>
<h5 id="插入删除">插入删除</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">insert</span>(const_iterator pos, <span class="type">int</span> count,ele);<span class="comment">//迭代器指向位置pos插入count个元素ele.</span></span><br><span class="line"><span class="built_in">push_back</span>(ele); <span class="comment">//尾部插入元素ele</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除最后一个元素</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator start, const_iterator end);<span class="comment">//删除迭代器从start到end之间的元素</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator pos);<span class="comment">//删除迭代器指向的元素</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//删除容器中所有元素</span></span><br></pre></td></tr></table></figure>
<h4 id="deque容器">deque容器</h4>
<h5 id="构造函数-2">构造函数</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;T&gt; deqT;<span class="comment">//默认构造形式</span></span><br><span class="line"><span class="built_in">deque</span>(beg, end);<span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(n, elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="type">const</span> deque &amp;deq);<span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure>
<h5 id="赋值操作-2">赋值操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assign</span>(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">assign</span>(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line">deque&amp; <span class="keyword">operator</span>=(<span class="type">const</span> deque &amp;deq); <span class="comment">//重载等号操作符 </span></span><br><span class="line"><span class="built_in">swap</span>(deq);<span class="comment">// 将deq与本身的元素互换</span></span><br></pre></td></tr></table></figure>
<h5 id="大小操作-2">大小操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque.<span class="built_in">size</span>();<span class="comment">//返回容器中元素的个数</span></span><br><span class="line">deque.<span class="built_in">empty</span>();<span class="comment">//判断容器是否为空</span></span><br><span class="line">deque.<span class="built_in">resize</span>(num);<span class="comment">//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line">deque.<span class="built_in">resize</span>(num, elem); <span class="comment">//重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br></pre></td></tr></table></figure>
<h5 id="插入删除-2">插入删除</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">insert</span>(pos,elem);<span class="comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,n,elem);<span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,beg,end);<span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//移除容器的所有数据</span></span><br><span class="line"><span class="built_in">erase</span>(beg,end);<span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br></pre></td></tr></table></figure>
<h5 id="数据存取-2">数据存取</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">at</span>(idx);<span class="comment">//返回索引idx所指的数据，如果idx越界，抛出out_of_range。</span></span><br><span class="line"><span class="keyword">operator</span>[];<span class="comment">//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个数据。</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个数据</span></span><br></pre></td></tr></table></figure>
<h5 id="双端插入删除">双端插入删除</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(elem);<span class="comment">//在容器尾部添加一个数据</span></span><br><span class="line"><span class="built_in">push_front</span>(elem);<span class="comment">//在容器头部插入一个数据</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除容器最后一个数据</span></span><br><span class="line"><span class="built_in">pop_front</span>();<span class="comment">//删除容器第一个数据</span></span><br></pre></td></tr></table></figure>
<h4 id="stack容器">stack容器</h4>
<h5 id="构造函数-3">构造函数</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&lt;T&gt; stkT;<span class="comment">//stack采用模板类实现， stack对象的默认构造形式： </span></span><br><span class="line"><span class="built_in">stack</span>(<span class="type">const</span> stack &amp;stk);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<h5 id="赋值操作-3">赋值操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> stack &amp;stk);<span class="comment">//重载等号操作符</span></span><br></pre></td></tr></table></figure>
<h5 id="大小操作-3">大小操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push</span>(elem);<span class="comment">//向栈顶添加元素</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//从栈顶移除第一个元素</span></span><br><span class="line"><span class="built_in">top</span>();<span class="comment">//返回栈顶元素</span></span><br></pre></td></tr></table></figure>
<h5 id="数据存取-3">数据存取</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push</span>(elem);<span class="comment">//向栈顶添加元素</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//从栈顶移除第一个元素</span></span><br><span class="line"><span class="built_in">top</span>();<span class="comment">//返回栈顶元素</span></span><br></pre></td></tr></table></figure>
<h4 id="queue容器">queue容器</h4>
<h5 id="构造函数-4">构造函数</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;T&gt; queT;<span class="comment">//queue采用模板类实现，queue对象的默认构造形式：</span></span><br><span class="line"><span class="built_in">queue</span>(<span class="type">const</span> queue &amp;que);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<h5 id="赋值操作-4">赋值操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> queue &amp;que);<span class="comment">//重载等号操作符</span></span><br></pre></td></tr></table></figure>
<h5 id="大小操作-4">大小操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> queue &amp;que);<span class="comment">//重载等号操作符</span></span><br></pre></td></tr></table></figure>
<h5 id="存取插入删除">存取插入删除</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push</span>(elem);<span class="comment">//往队尾添加元素</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//从队头移除第一个元素</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个元素</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个元素</span></span><br></pre></td></tr></table></figure>
<h4 id="list容器">list容器</h4>
<h5 id="构造函数-5">构造函数</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;T&gt; lstT;<span class="comment">//list采用采用模板类实现,对象的默认构造形式：</span></span><br><span class="line"><span class="built_in">list</span>(beg,end);<span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">list</span>(n,elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">list</span>(<span class="type">const</span> list &amp;lst);<span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure>
<h5 id="赋值操作-5">赋值操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assign</span>(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">assign</span>(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line">list&amp; <span class="keyword">operator</span>=(<span class="type">const</span> list &amp;lst);<span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="built_in">swap</span>(lst);<span class="comment">//将lst与本身的元素互换。</span></span><br></pre></td></tr></table></figure>
<h5 id="大小操作-5">大小操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">size</span>();<span class="comment">//返回容器中元素的个数</span></span><br><span class="line"><span class="built_in">empty</span>();<span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="built_in">resize</span>(num);<span class="comment">//重新指定容器的长度为num，</span></span><br><span class="line">若容器变长，则以默认值填充新位置。</span><br><span class="line">如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line"><span class="built_in">resize</span>(num, elem);<span class="comment">//重新指定容器的长度为num，</span></span><br><span class="line">若容器变长，则以elem值填充新位置。</span><br><span class="line">如果容器变短，则末尾超出容器长度的元素被删除。</span><br></pre></td></tr></table></figure>
<h5 id="插入删除-3">插入删除</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(elem);<span class="comment">//在容器尾部加入一个元素</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除容器中最后一个元素</span></span><br><span class="line"><span class="built_in">push_front</span>(elem);<span class="comment">//在容器开头插入一个元素</span></span><br><span class="line"><span class="built_in">pop_front</span>();<span class="comment">//从容器开头移除第一个元素</span></span><br><span class="line"><span class="built_in">insert</span>(pos,elem);<span class="comment">//在pos位置插elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,n,elem);<span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,beg,end);<span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//移除容器的所有数据</span></span><br><span class="line"><span class="built_in">erase</span>(beg,end);<span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="built_in">remove</span>(elem);<span class="comment">//删除容器中所有与elem值匹配的元素。</span></span><br></pre></td></tr></table></figure>
<h5 id="数据存取-4">数据存取</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个元素。</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个元素。</span></span><br></pre></td></tr></table></figure>
<h5 id="反转排序">反转排序</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reverse</span>();<span class="comment">//反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。</span></span><br><span class="line"><span class="built_in">sort</span>(); <span class="comment">//list排序</span></span><br></pre></td></tr></table></figure>
<h4 id="set-multiset容器">set/multiset容器</h4>
<h5 id="构造函数-6">构造函数</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;T&gt; st;<span class="comment">//set默认构造函数：</span></span><br><span class="line">mulitset&lt;T&gt; mst; <span class="comment">//multiset默认构造函数: </span></span><br><span class="line"><span class="built_in">set</span>(<span class="type">const</span> set &amp;st);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<h5 id="赋值操作-6">赋值操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&amp; <span class="keyword">operator</span>=(<span class="type">const</span> set &amp;st);<span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="built_in">swap</span>(st);<span class="comment">//交换两个集合容器</span></span><br></pre></td></tr></table></figure>
<h5 id="大小操作-6">大小操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&amp; <span class="keyword">operator</span>=(<span class="type">const</span> set &amp;st);<span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="built_in">swap</span>(st);<span class="comment">//交换两个集合容器</span></span><br></pre></td></tr></table></figure>
<h5 id="插入删除-4">插入删除</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">insert</span>(elem);<span class="comment">//在容器中插入元素。</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//清除所有元素</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">erase</span>(beg, end);<span class="comment">//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">erase</span>(elem);<span class="comment">//删除容器中值为elem的元素。</span></span><br></pre></td></tr></table></figure>
<h5 id="查找操作">查找操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span>(key);<span class="comment">//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</span></span><br><span class="line"><span class="built_in">count</span>(key);<span class="comment">//查找键key的元素个数</span></span><br><span class="line"><span class="built_in">lower_bound</span>(keyElem);<span class="comment">//返回第一个key&gt;=keyElem元素的迭代器。</span></span><br><span class="line"><span class="built_in">upper_bound</span>(keyElem);<span class="comment">//返回第一个key&gt;keyElem元素的迭代器。</span></span><br><span class="line"><span class="built_in">equal_range</span>(keyElem);<span class="comment">//返回容器中key与keyElem相等的上下限的两个迭代器。</span></span><br></pre></td></tr></table></figure>
<h5 id="对组（pair）">对组（pair）</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种方法创建一个对组</span></span><br><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">pair1</span><span class="params">(string(<span class="string">&quot;name&quot;</span>), <span class="number">20</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; pair1.first &lt;&lt; endl; <span class="comment">//访问pair第一个值</span></span><br><span class="line">cout &lt;&lt; pair1.second &lt;&lt; endl;<span class="comment">//访问pair第二个值</span></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; pair2 = <span class="built_in">make_pair</span>(<span class="string">&quot;name&quot;</span>, <span class="number">30</span>);</span><br><span class="line">cout &lt;&lt; pair2.first &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pair2.second &lt;&lt; endl;</span><br><span class="line"><span class="comment">//pair=赋值</span></span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; pair3 = pair2;</span><br><span class="line">cout &lt;&lt; pair3.first &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pair3.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h4 id="map-multimap">map/multimap</h4>
<h5 id="构造函数-7">构造函数</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;T1, T2&gt; mapTT;<span class="comment">//map默认构造函数: </span></span><br><span class="line"><span class="built_in">map</span>(<span class="type">const</span> map &amp;mp);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<h5 id="赋值操作-7">赋值操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&amp; <span class="keyword">operator</span>=(<span class="type">const</span> map &amp;mp);<span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="built_in">swap</span>(mp);<span class="comment">//交换两个集合容器</span></span><br></pre></td></tr></table></figure>
<h5 id="大小操作-7">大小操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">size</span>();<span class="comment">//返回容器中元素的数目</span></span><br><span class="line"><span class="built_in">empty</span>();<span class="comment">//判断容器是否为空</span></span><br></pre></td></tr></table></figure>
<h5 id="插入删除-5">插入删除</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map.<span class="built_in">insert</span>(...); <span class="comment">//往容器插入元素，返回pair&lt;iterator,bool&gt;</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; mapStu;</span><br><span class="line"><span class="comment">// 第一种 通过pair的方式插入对象</span></span><br><span class="line">mapStu.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;小张&quot;</span>));</span><br><span class="line"><span class="comment">// 第二种 通过pair的方式插入对象</span></span><br><span class="line">mapStu.<span class="built_in">inset</span>(<span class="built_in">make_pair</span>(<span class="number">-1</span>, <span class="string">&quot;校长&quot;</span>));</span><br><span class="line"><span class="comment">// 第三种 通过value_type的方式插入对象</span></span><br><span class="line">mapStu.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span>(<span class="number">1</span>, <span class="string">&quot;小李&quot;</span>));</span><br><span class="line"><span class="comment">// 第四种 通过数组的方式插入值</span></span><br><span class="line">mapStu[<span class="number">3</span>] = <span class="string">&quot;小刘&quot;</span>;</span><br><span class="line">mapStu[<span class="number">5</span>] = <span class="string">&quot;小王&quot;</span>;</span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//删除所有元素</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">erase</span>(beg,end);<span class="comment">//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">erase</span>(keyElem);<span class="comment">//删除容器中key为keyElem的对组。</span></span><br></pre></td></tr></table></figure>
<h5 id="查找操作-2">查找操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span>(key);<span class="comment">//查找键key是否存在,若存在，返回该键的元素的迭代器；/若不存在，返回map.end();</span></span><br><span class="line"><span class="built_in">count</span>(keyElem);<span class="comment">//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</span></span><br><span class="line"><span class="built_in">lower_bound</span>(keyElem);<span class="comment">//返回第一个key&gt;=keyElem元素的迭代器。</span></span><br><span class="line"><span class="built_in">upper_bound</span>(keyElem);<span class="comment">//返回第一个key&gt;keyElem元素的迭代器。</span></span><br><span class="line"><span class="built_in">equal_range</span>(keyElem);<span class="comment">//返回容器中key与keyElem相等的上下限的两个迭代器。</span></span><br></pre></td></tr></table></figure>
<h4 id=""></h4>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb调试工具详解</title>
    <url>/2024/07/01/gdb%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="gdb调试详解">gdb调试详解</h3>
<p>是 GNU 调试器（GNU Debugger）的缩写，它是一个功能强大的 Unix-like 系统下的源代码调试器。使用 <code>gdb</code>，程序员可以查看程序在运行时的状态，设置断点，单步执行代码，检查变量的值，以及执行其他调试任务。(在命令行终端中进行)</p>
<h4 id="gdb启动流程">gdb启动流程</h4>
<ol>
<li>
<p>编译相关：编译链接的时候<code>-g</code>表示可以调试，如果要使用gdb调试记得加上</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -g test.cpp -o test</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>启动gdb，示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gdb test </span><br><span class="line">gbd -q test <span class="comment">//表示不打印gbd版本信息，界面比较干净</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>gdb下查看源码：<code>list</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) list </span><br><span class="line"><span class="number">9</span>	<span class="meta">#<span class="keyword">define</span> MAX_SIZE</span></span><br><span class="line"><span class="number">10</span>	</span><br><span class="line"><span class="number">11</span>	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">12	</span>&#123;</span><br><span class="line"><span class="number">13</span>	    <span class="type">int</span> i,fd,size1 ,size2 ,len;</span><br><span class="line"><span class="number">14</span>	    <span class="type">char</span> *buf = <span class="string">&quot;helo!I&#x27;m liujiangyong &quot;</span>;</span><br><span class="line"><span class="number">15</span>	    <span class="type">char</span> buf_r[<span class="number">15</span>];</span><br><span class="line"><span class="number">16</span>	    len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"><span class="number">17</span>	    fd = <span class="built_in">open</span>(<span class="string">&quot;/home/hello.txt&quot;</span>,O_CREAT | O_TRUNC | O_RDWR,<span class="number">0666</span>);</span><br><span class="line"><span class="number">18</span>	    <span class="keyword">if</span> (fd&lt;<span class="number">0</span>)</span><br><span class="line">(gdb) </span><br><span class="line"><span class="number">19</span>	        &#123;</span><br><span class="line"><span class="number">20</span>	            <span class="built_in">perror</span>(<span class="string">&quot;open :&quot;</span>);</span><br><span class="line"><span class="number">21</span>	            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"><span class="number">22</span>	        &#125;</span><br><span class="line"><span class="number">23</span>	    <span class="keyword">else</span></span><br><span class="line"><span class="number">24</span>	        &#123;</span><br><span class="line"><span class="number">25</span>	        <span class="built_in">printf</span>(<span class="string">&quot;open file:hello.txt %d\n&quot;</span>,fd);</span><br><span class="line"><span class="number">26</span>	        &#125;</span><br><span class="line"><span class="number">27</span>	    size1 = <span class="built_in">write</span>(fd,buf,len);</span><br><span class="line"><span class="number">28</span>	    <span class="keyword">if</span> (fd&lt;<span class="number">0</span>)</span><br><span class="line">(gdb) </span><br><span class="line"><span class="number">29</span>	    &#123;</span><br><span class="line"><span class="number">30</span>	        <span class="built_in">printf</span>(<span class="string">&quot;writre erro;&quot;</span>);</span><br><span class="line"><span class="number">31</span>	</span><br><span class="line"><span class="number">32</span>	    &#125;</span><br><span class="line"><span class="number">33</span>	    <span class="keyword">else</span></span><br><span class="line"><span class="number">34</span>	    &#123;</span><br><span class="line"><span class="number">35</span>	        <span class="built_in">printf</span>(<span class="string">&quot;写入的长度：%d\n写入文本内容：%s\n&quot;</span>,size1,buf);</span><br><span class="line"><span class="number">36</span>	</span><br><span class="line"><span class="number">37</span>	    &#125;</span><br><span class="line"><span class="number">38</span>	    <span class="built_in">lseek</span>(fd,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">(gdb) </span><br><span class="line"><span class="number">39</span>	    size2 = <span class="built_in">read</span>(fd,buf_r,<span class="number">12</span>);</span><br><span class="line"><span class="number">40</span>	    <span class="keyword">if</span> (size2 &lt;<span class="number">0</span>)</span><br><span class="line"><span class="number">41</span>	    &#123;</span><br><span class="line"><span class="number">42</span>	        <span class="built_in">printf</span>(<span class="string">&quot;read  erro\n&quot;</span>);</span><br><span class="line"><span class="number">43</span>	    &#125;</span><br><span class="line"><span class="number">44</span>	    <span class="keyword">else</span></span><br><span class="line"><span class="number">45</span>	    &#123;</span><br><span class="line"><span class="number">46</span>	        <span class="built_in">printf</span>(<span class="string">&quot;读取长度：%d\n 文本内容是：%s\n&quot;</span>,size2,buf_r);</span><br><span class="line"><span class="number">47</span>	    &#125;</span><br><span class="line"><span class="number">48</span>	    <span class="built_in">close</span>(fd);    </span><br><span class="line">(gdb) </span><br><span class="line"><span class="number">49</span>	</span><br><span class="line"><span class="number">50</span>	</span><br><span class="line"><span class="number">51</span>	&#125;</span><br><span class="line">(gdb) </span><br><span class="line">Line number <span class="number">52</span> out of range; write.c has <span class="number">51</span> lines.</span><br><span class="line">(gdb) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>gbd下运行程序：<code>run</code></p>
<p>该命令会运行程序直到结束或者遇到断点等待下一个命令</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y <span class="keyword">or</span> n) y</span><br><span class="line">Starting program: /home/eit/c_test/test </span><br><span class="line">open file:hello.txt <span class="number">3</span></span><br><span class="line">写入的长度：<span class="number">22</span></span><br><span class="line">写入文本内容：helo!I<span class="number">&#x27;</span>m liujiangyong </span><br><span class="line">读取长度：<span class="number">12</span></span><br><span class="line"> 文本内容是：helo!I<span class="number">&#x27;</span>m liu</span><br><span class="line">[Inferior <span class="number">1</span> (process <span class="number">19987</span>) exited normally]</span><br><span class="line">(gdb) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>gdb下设置断点：<code>break</code>+行号</p>
<p>该命令会在某一行设置一个断点,<code>info breakpoints</code>会显示所有断点信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) b <span class="number">5</span></span><br><span class="line">Breakpoint <span class="number">3</span> at <span class="number">0x400836</span>: file write.c, line <span class="number">5.</span></span><br><span class="line">(gdb) b <span class="number">26</span> </span><br><span class="line">Breakpoint <span class="number">4</span> at <span class="number">0x4008a6</span>: file write.c, line <span class="number">26.</span></span><br><span class="line">(gdb) b <span class="number">30</span></span><br><span class="line">Breakpoint <span class="number">5</span> at <span class="number">0x4008c6</span>: file write.c, line <span class="number">30.</span></span><br><span class="line">(gdb) info breakpoints </span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line"><span class="number">3</span>       breakpoint     keep y   <span class="number">0x0000000000400836</span> in main at write.c:<span class="number">5</span></span><br><span class="line"><span class="number">4</span>       breakpoint     keep y   <span class="number">0x00000000004008a6</span> in main at write.c:<span class="number">26</span></span><br><span class="line"><span class="number">5</span>       breakpoint     keep y   <span class="number">0x00000000004008c6</span> in main at write.c:<span class="number">30</span></span><br><span class="line">(gdb) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>num</th>
<th>type</th>
<th>disp</th>
<th>enb</th>
<th>address</th>
<th>what</th>
</tr>
</thead>
<tbody>
<tr>
<td>断点编号</td>
<td>类型</td>
<td>断点执行一次后是否有效，keep（有）</td>
<td>当前断点是否有效，y（有）</td>
<td>内存地址</td>
<td>在函数中的位置</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>gdb下单步执行：<code>continue</code>、<code>step</code>、<code>next</code>、<code>finish</code></p>
<ul>
<li>
<p><code>continue</code>：在断点处继续执行程序</p>
</li>
<li>
<p><code>next</code>：执行下一行代码（跳过函数内部）</p>
</li>
<li>
<p><code>step</code>：执行下一行代码（进入函数内部）</p>
</li>
<li>
<p><code>finish</code>：执行完当前函数并返回到父函数</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/eit/c_test/test </span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">3</span>, <span class="built_in">main</span> () at write.c:<span class="number">12</span></span><br><span class="line"><span class="number">12</span>	&#123;</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">14</span>	    <span class="type">char</span> *buf = <span class="string">&quot;helo!I&#x27;m liujiangyong &quot;</span>;</span><br><span class="line">(gdb) </span><br><span class="line"><span class="number">16</span>	    len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">(gdb) </span><br><span class="line"><span class="number">17</span>	    fd = <span class="built_in">open</span>(<span class="string">&quot;/home/hello.txt&quot;</span>,O_CREAT | O_TRUNC | O_RDWR,<span class="number">0666</span>);</span><br><span class="line">(gdb) <span class="function">s</span></span><br><span class="line"><span class="function"><span class="title">open64</span> <span class="params">()</span> at ../sysdeps/unix/syscall-<span class="keyword">template</span>.S:<span class="number">81</span></span></span><br><span class="line"><span class="function"><span class="number">81</span>	../sysdeps/unix/syscall-template.S: No such file or directory.</span></span><br><span class="line"><span class="function">(gdb) </span></span><br><span class="line"><span class="function">main () at write.c:<span class="number">18</span></span></span><br><span class="line"><span class="function"><span class="number">18</span>	    if (fd&lt;<span class="number">0</span>)</span></span><br><span class="line"><span class="function">(gdb) </span></span><br><span class="line"><span class="function"><span class="number">25</span>	        printf(<span class="string">&quot;open file:hello.txt %d\n&quot;</span>,fd);</span></span><br><span class="line">(gdb) </span><br><span class="line">__printf (format=<span class="number">0x400a26</span> <span class="string">&quot;open file:hello.txt %d\n&quot;</span>) at printf.c:<span class="number">28</span></span><br><span class="line"><span class="number">28</span>	printf.c: No such file <span class="keyword">or</span> directory.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">open file:hello.txt <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">4</span>, <span class="built_in">main</span> () at write.c:<span class="number">27</span></span><br><span class="line"><span class="number">27</span>	    size1 = <span class="built_in">write</span>(fd,buf,len);</span><br><span class="line">(gdb) </span><br><span class="line">Continuing.</span><br><span class="line">写入的长度：<span class="number">22</span></span><br><span class="line">写入文本内容：helo!I<span class="number">&#x27;</span>m liujiangyong </span><br><span class="line">读取长度：<span class="number">12</span></span><br><span class="line"> 文本内容是：helo!I<span class="number">&#x27;</span>m liu</span><br><span class="line">[Inferior <span class="number">1</span> (process <span class="number">20737</span>) exited normally]</span><br><span class="line">(gdb) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>gdb下查看变量：<code>print</code>、<code>whatis</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">main</span> () at write.c:<span class="number">28</span></span><br><span class="line"><span class="number">28</span>	    <span class="keyword">if</span> (fd&lt;<span class="number">0</span>)</span><br><span class="line">(gdb) </span><br><span class="line"><span class="number">35</span>	        <span class="built_in">printf</span>(<span class="string">&quot;写入的长度：%d\n写入文本内容：%s\n&quot;</span>,size1,buf);</span><br><span class="line">(gdb) print fd</span><br><span class="line">$<span class="number">10</span> = <span class="number">3</span></span><br><span class="line">(gdb) whatis fd</span><br><span class="line">type = <span class="built_in">int</span></span><br><span class="line">(gdb) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>gdb下退出gdb：<code>quit</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/eit/c_test/test </span><br><span class="line">open file:hello.txt <span class="number">3</span></span><br><span class="line">写入的长度：<span class="number">22</span></span><br><span class="line">写入文本内容：helo!I<span class="number">&#x27;</span>m liujiangyong </span><br><span class="line">读取长度：<span class="number">12</span></span><br><span class="line"> 文本内容是：helo!I<span class="number">&#x27;</span>m liu</span><br><span class="line">[Inferior <span class="number">1</span> (process <span class="number">20815</span>) exited normally]</span><br><span class="line">(gdb) q</span><br><span class="line">root@ubuntu:/home/eit/c_test# </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="常用命令">常用命令</h4>
<p>当使用表格来表示 <code>gdb</code> 的常用命令时，可以如下所示：</p>
<table>
<thead>
<tr>
<th>命令分类</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动和退出</td>
<td><code>gdb your_program</code></td>
<td>启动 GDB 并加载指定的程序</td>
</tr>
<tr>
<td></td>
<td><code>quit</code> 或 <code>q</code></td>
<td>退出 GDB</td>
</tr>
<tr>
<td>调试控制</td>
<td><code>run [arguments]</code> 或 <code>r [arguments]</code></td>
<td>运行程序并传递参数</td>
</tr>
<tr>
<td></td>
<td><code>continue</code> 或 <code>c</code></td>
<td>继续执行，直到遇到下一个断点或程序结束</td>
</tr>
<tr>
<td></td>
<td><code>next</code> 或 <code>n</code></td>
<td>执行下一行代码（不进入函数）</td>
</tr>
<tr>
<td></td>
<td><code>step</code> 或 <code>s</code></td>
<td>执行下一行代码（进入函数）</td>
</tr>
<tr>
<td></td>
<td><code>finish</code></td>
<td>执行完当前函数并返回到父函数</td>
</tr>
<tr>
<td>断点管理</td>
<td><code>break [location]</code> 或 <code>b [location]</code></td>
<td>在指定位置设置断点</td>
</tr>
<tr>
<td></td>
<td><code>info breakpoints</code> 或 <code>info b</code></td>
<td>显示所有断点信息</td>
</tr>
<tr>
<td></td>
<td><code>disable [breakpoint_number]</code></td>
<td>禁用指定编号的断点</td>
</tr>
<tr>
<td></td>
<td><code>enable [breakpoint_number]</code></td>
<td>启用指定编号的断点</td>
</tr>
<tr>
<td></td>
<td><code>delete [breakpoint_number]</code> 或 <code>d [breakpoint_number]</code></td>
<td>删除指定编号的断点</td>
</tr>
<tr>
<td>变量和内存查看</td>
<td><code>print [variable_name]</code> 或 <code>p [variable_name]</code></td>
<td>显示变量的值</td>
</tr>
<tr>
<td></td>
<td><code>ptype [variable_name]</code></td>
<td>显示变量的类型</td>
</tr>
<tr>
<td></td>
<td><code>set var [variable_name]=[newValue]</code></td>
<td>修改变量的值</td>
</tr>
<tr>
<td></td>
<td><code>x/NFU [address]</code></td>
<td>显示内存内容，N是数量，F是格式，U是单位，address是地址</td>
</tr>
<tr>
<td>其他常用命令</td>
<td><code>list [location]</code> 或 <code>l [location]</code></td>
<td>显示源代码</td>
</tr>
<tr>
<td></td>
<td><code>backtrace</code> 或 <code>bt</code></td>
<td>显示堆栈跟踪</td>
</tr>
<tr>
<td></td>
<td><code>watch [expression]</code></td>
<td>设置观察点，当表达式值改变时停止</td>
</tr>
<tr>
<td></td>
<td><code>catch [event]</code></td>
<td>捕获特定事件（如异常）</td>
</tr>
<tr>
<td></td>
<td><code>show path</code></td>
<td>显示GDB搜索源代码的路径</td>
</tr>
<tr>
<td></td>
<td><code>setargs [arguments]</code></td>
<td>设置传递给程序的命令行参数</td>
</tr>
<tr>
<td></td>
<td><code>show args</code></td>
<td>显示设置好的运行时参数</td>
</tr>
<tr>
<td></td>
<td><code>attach [process_id]</code></td>
<td>连接到正在运行的进程</td>
</tr>
<tr>
<td></td>
<td><code>detach</code></td>
<td>断开与已连接进程的连接</td>
</tr>
<tr>
<td></td>
<td><code>shell [command]</code></td>
<td>执行shell命令</td>
</tr>
<tr>
<td>自定义命令和脚本</td>
<td><code>define [cmd_name] [command_list]</code></td>
<td>定义自定义命令</td>
</tr>
<tr>
<td></td>
<td>脚本文件</td>
<td>使用脚本文件来自动化调试任务</td>
</tr>
<tr>
<td>多线程和多进程调试</td>
<td><code>info threads</code></td>
<td>显示所有线程信息</td>
</tr>
<tr>
<td></td>
<td><code>thread [tid]</code></td>
<td>切换到指定编号的线程</td>
</tr>
<tr>
<td></td>
<td>`set follow-fork-mode [child</td>
<td>parent]`</td>
</tr>
</tbody>
</table>
<p>请注意，这个表格只是提供了 <code>gdb</code> 的一些常用命令的概览，每个命令还有更多的选项和用法可以探索。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>gdb调试</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+butterfly+Github</title>
    <url>/2024/06/23/hexo-butterfly-Github/</url>
    <content><![CDATA[<h3 id="配置butterfly时总结出来的的经验">配置butterfly时总结出来的的经验</h3>
<ol>
<li>一步一步配，每配一次，<code>hexo s</code>一次，出问题了就查</li>
<li>出现报错的情况下，可以先试着<code>hexo clean&amp;hexo g&amp;hexo s</code>多来几次</li>
</ol>
<h3 id="我的文件结构注意事项">我的文件结构注意事项</h3>
<ol>
<li>在hexo根目录下的_config.yml和_config.butterfly.yml</li>
<li>没有特别提到的话，数据相关文件应该都是在/source/里面</li>
<li>文章的创建用<code>hexo new &quot;name&quot;</code>,页面的创建用的<code>hexo new page </code></li>
</ol>
<h3 id="用代码说话，两个配置文件最容易出问题">用代码说话，两个配置文件最容易出问题</h3>
<h4 id="config-butterfly-yml">_config.butterfly.yml</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果你用vs编程发现最后主页中文是乱码，</span></span><br><span class="line"><span class="comment">#是因为vs默认生成的文件不按照utf-8，请按照这个解决 https://blog.csdn.net/qq_41868108/article/details/105750175</span></span><br><span class="line"><span class="comment">#浏览器图标修改</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/image/luogic.jpg</span></span><br><span class="line"><span class="comment">#导航栏设置 最上面的一栏，logo是最左边的小圈圈</span></span><br><span class="line"><span class="attr">nav:</span></span><br><span class="line">  <span class="attr">logo:</span> <span class="string">/image/微信图片_202406231044301.jpg</span></span><br><span class="line">  <span class="attr">display_title:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">fixed:</span> <span class="literal">false</span> <span class="comment"># fixed navigation bar    </span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#这里是右上角的设置 格式是，/文件夹路劲/|| fas图标</span></span><br><span class="line"><span class="comment">#（一定要建立文件夹，不如找不到会报错） </span></span><br><span class="line"><span class="comment">#这里的fas图标 它用的是一个公司发行的标准图标图</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">时间轴:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="string">其他||fa</span> <span class="attr">fa-heartbeat:</span></span><br><span class="line">    <span class="string">音乐:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">    <span class="string">照片:</span> <span class="string">/Gallery/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-images</span></span><br><span class="line">    <span class="string">电影:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#网站副标题，中间标题下面一点点</span></span><br><span class="line"><span class="comment"># 主页subtitle</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Typewriter Effect (打字效果)</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">startDelay:</span> <span class="number">300</span> <span class="comment"># time before typing starts in milliseconds</span></span><br><span class="line">  <span class="attr">typeSpeed:</span> <span class="number">200</span> <span class="comment"># type speed in milliseconds</span></span><br><span class="line">  <span class="attr">backSpeed:</span> <span class="number">800</span> <span class="comment"># backspacing speed in milliseconds</span></span><br><span class="line">  <span class="comment"># loop (循环打字)</span></span><br><span class="line">  <span class="attr">loop:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># source 调用三方服务</span></span><br><span class="line">  <span class="comment"># source: false 开关调用</span></span><br><span class="line">  <span class="comment"># subtitle 会先显示 source , 再显示 sub 的內容</span></span><br><span class="line">  <span class="attr">source:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 如果关闭打字效果，subtitle 只会显示 sub 的第一行文字</span></span><br><span class="line">  <span class="attr">sub:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">飒飒西风满院栽，蕊寒香冷蝶难来</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">他年我若为青帝，报与桃花一处开</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#页面 右侧个人信息相关的设置</span></span><br><span class="line"><span class="comment">#头像 如果报错或者显示的是吃豆小人，检查你的名称，一定要正确</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">img:</span> <span class="string">/image/luogic.jpg</span></span><br><span class="line">  <span class="comment">#effect: true # 头像会一直转，转的贼快，太鬼畜了（emmm，超级抽象，别设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#顶部图片设置，就是主页的那张背景图，建议设置400px，默认的全屏容易让人找不到博客在哪里</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">index_img:</span> <span class="string">/image/流萤.jpg</span></span><br><span class="line"><span class="attr">default_top_img:</span> <span class="string">/image/流萤.jpg</span></span><br><span class="line"><span class="attr">index_top_img_height:</span>  <span class="comment">#顶部图高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#背景动态</span></span><br><span class="line"><span class="attr">canvas_fluttering_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span> <span class="comment"># false 手机端不显示 true 手机端显示</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#页面加载动画</span></span><br><span class="line"><span class="comment">#加载动画</span></span><br><span class="line"><span class="attr">preloader:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">source:</span> <span class="number">1</span> <span class="comment">#可选值1=fullpage或2=progress bar，可查看https://codebyzach.github.io/pace/</span></span><br><span class="line">  <span class="attr">pace_css_url:</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#池塘养鱼（最底部）+渐变色</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line"> <span class="attr">head:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;/styles/fish.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/styles/main.css&quot;&gt;</span>   </span><br><span class="line"> <span class="attr">bottom:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#搜索功能</span></span><br><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">3</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">CDN:</span></span><br><span class="line"><span class="comment">#数学公式支持</span></span><br><span class="line"><span class="attr">katex:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># true 表示每一页都加载katex.js</span></span><br><span class="line">  <span class="comment"># false 需要时加载，须在使用的Markdown Front-matter 加上 katex: true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">hide_scrollbar:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="config-yml">_config.yml</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">龙锦</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;买不起茅台 &#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">龙金伟</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://username.github.io</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># Apply to the whole site</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">syntax_highlighter:</span> <span class="string">highlight.js</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">prismjs:</span></span><br><span class="line">  <span class="attr">preprocess:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Metadata elements</span></span><br><span class="line"><span class="comment">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span></span><br><span class="line"><span class="attr">meta_generator:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="string">HH:mm:ss</span></span><br><span class="line"><span class="comment">## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;</span></span><br><span class="line"><span class="attr">updated_option:</span> <span class="string">&#x27;mtime&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Include / Exclude file(s)</span></span><br><span class="line"><span class="comment">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span></span><br><span class="line"><span class="attr">include:</span></span><br><span class="line"><span class="attr">exclude:</span></span><br><span class="line"><span class="attr">ignore:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="comment"># deploy:</span></span><br><span class="line"><span class="comment">#   type: &#x27;&#x27;</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/longjinw/longjinw.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br><span class="line">  <span class="comment"># message: Site updated: &#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125;)</span></span><br><span class="line"><span class="comment">#搜索</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line"><span class="comment">#数学支chi</span></span><br><span class="line"><span class="attr">markdown:</span></span><br><span class="line">    <span class="attr">plugins:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;@renbaoshuo/markdown-it-katex&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 命令使用</title>
    <url>/2024/06/23/hexo_%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>这个是官网（可以查看主题以及更新）：<a href="https://hexo.io/">Hexo</a><br>
这篇文章是hexo第一篇文章. 点击 <a href="https://hexo.io/docs/">documentation</a> 可以获得更多信息.<br>
可以在 <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> 找到绝大部分hexo相关问题，或者直接去 <a href="https://github.com/hexojs/hexo/issues">GitHub</a>评论留言.</p>
<h2 id="快速开始">快速开始</h2>
<h3 id="创建一个新的文章，文章默认在source-ports-目录下面">创建一个新的文章，文章默认在source/ _ports /目录下面</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>相关: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="在本地上启动">在本地上启动</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>相关: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="生成静态文件">生成静态文件</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>相关: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="部署到网站">部署到网站</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>相关: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo文章主题头内各个数据的意义</title>
    <url>/2024/06/24/hexo%E6%96%87%E7%AB%A0%E4%B8%BB%E9%A2%98%E5%A4%B4%E9%87%8C%E5%A1%AB%E5%86%99%E7%9A%84%E6%84%8F%E6%80%9D/</url>
    <content><![CDATA[<h3 id="页面编写（page）">页面编写（page）</h3>
<table>
<thead>
<tr>
<th style="text-align:left">写法</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">title</td>
<td style="text-align:left">【必需】页面标题</td>
</tr>
<tr>
<td style="text-align:left">date</td>
<td style="text-align:left">【必需】页面创建日期</td>
</tr>
<tr>
<td style="text-align:left">type</td>
<td style="text-align:left">【必需】标签、分类和友情链接三个页面需要配置</td>
</tr>
</tbody>
</table>
<h3 id="文章编辑（port1）">文章编辑（port1）</h3>
<table>
<thead>
<tr>
<th style="text-align:left">写法</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">title</td>
<td style="text-align:left">【必需】文章标题</td>
</tr>
<tr>
<td style="text-align:left">date</td>
<td style="text-align:left">【必需】文章创建日期</td>
</tr>
<tr>
<td style="text-align:left">tagas</td>
<td style="text-align:left">【可选】文章标签</td>
</tr>
<tr>
<td style="text-align:left">categories</td>
<td style="text-align:left">【可选】文章分类</td>
</tr>
<tr>
<td style="text-align:left">keywords</td>
<td style="text-align:left">【可选】文章关键字</td>
</tr>
<tr>
<td style="text-align:left">description</td>
<td style="text-align:left">【可选】文章描述</td>
</tr>
<tr>
<td style="text-align:left">cover</td>
<td style="text-align:left">【可选】文章图标</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客编写</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown建议上手之-图表绘制</title>
    <url>/2024/07/01/markdown%E5%BB%BA%E8%AE%AE%E4%B8%8A%E6%89%8B%E4%B9%8B-%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6/</url>
    <content><![CDATA[<h3 id="流程图绘制相关">流程图绘制相关</h3>
<h4 id="mermaid简述">mermaid简述</h4>
<p>特性：Mermaid制图是一种基于文本的图表绘制方法，它使用类似于Markdown的语法来描述图表，并可以将其转换为SVG或其他图形格式进行展示。特点是简单易学功能强大，能够满足大部分简易制图要求，（要是太难了为什么不直接贴图呢）</p>
<p>其他：</p>
<ul>
<li>Mermaid支持通过CSS样式来自定义图表的外观和布局。（不建议，太复杂不如贴图）</li>
<li>Mermaid图表可以导出为PNG、SVG等常见的图像格式。（不会，遇到了在学）</li>
<li>Mermaid支持插件和编辑器的集成，使得用户可以更加高效地使用和管理Mermaid图表。</li>
<li><strong>在Markdown编辑器中，可以直接使用Mermaid语法来创建和渲染图表。</strong>（Typora可以）。</li>
<li><strong>支持流程图、序列图、甘特图。</strong></li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>在markdown编辑中，要写在代码框里，所以要先在最开始打出<code>```mermaid</code> 唤醒这个对应代码（Typora里）。</li>
</ul>
<h4 id="简单的流程图：">简单的流程图：</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">graph TB  </span><br><span class="line">A[开始] --&gt; B[处理]  </span><br><span class="line">B --&gt; C&#123;判断&#125;  </span><br><span class="line">C -- 是 --&gt; D[结束]  </span><br><span class="line">C -- 否 --&gt; E[处理]  </span><br><span class="line">E --&gt; B</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB  </span><br><span class="line">A[开始] --&gt; B[处理]  </span><br><span class="line">B --&gt; C&#123;判断&#125;  </span><br><span class="line">C -- 是 --&gt; D[结束]  </span><br><span class="line">C -- 否 --&gt; E[处理]  </span><br><span class="line">E --&gt; B</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="简单的序列图：">简单的序列图：</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sequenceDiagram  </span><br><span class="line">A-&gt;&gt;B: 消息<span class="number">1</span>  </span><br><span class="line">B-&gt;&gt;C: 消息<span class="number">2</span>  </span><br><span class="line">C--&gt;&gt;A: 响应  </span><br><span class="line">loop 循环操作  </span><br><span class="line">  A-&gt;&gt;B: 消息<span class="number">3</span>  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram  </span><br><span class="line">A-&gt;&gt;B: 消息1  </span><br><span class="line">B-&gt;&gt;C: 消息2  </span><br><span class="line">C--&gt;&gt;A: 响应  </span><br><span class="line">loop 循环操作  </span><br><span class="line">  A-&gt;&gt;B: 消息3  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="简单的甘特图">简单的甘特图</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gantt  </span><br><span class="line">dateFormat  YYYY-MM-DD  </span><br><span class="line">title       项目进度  </span><br><span class="line">section SectionA  </span><br><span class="line">TaskA       :active,    a1, <span class="number">2023</span><span class="number">-01</span><span class="number">-01</span>, <span class="number">30</span>d  </span><br><span class="line">TaskB       :           b1, after a1, <span class="number">20</span>d</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gantt  </span><br><span class="line">dateFormat  YYYY-MM-DD  </span><br><span class="line">title       项目进度  </span><br><span class="line">section SectionA  </span><br><span class="line">TaskA       :active,    a1, 2023-01-01, 30d  </span><br><span class="line">TaskB       :           b1, after a1, 20d</span><br></pre></td></tr></table></figure>
<h4 id="具体语法">具体语法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">主要分成三层：</span><br><span class="line">标志层：选择graph、sequenceDiagram 、gantt选择你要制的图</span><br><span class="line">语法层：中间填入对应语法</span><br><span class="line">结束层：end表示结束</span><br></pre></td></tr></table></figure>
<h4 id="流程图（Flowchart）">流程图（Flowchart）</h4>
<ul>
<li>使用<code>graph</code>关键词定义图表类型，如<code>graph TB</code>（从上到下）或<code>graph RL</code>（从右到左）。</li>
<li>使用<code>A --&gt; B</code>表示从节点A到节点B的箭头。</li>
<li>支持条件判断，如<code>C -- 是 --&gt; D[结果1]</code>。</li>
</ul>
<h5 id="序列图（Sequence-Diagram）">序列图（Sequence Diagram）</h5>
<ul>
<li>使用<code>sequenceDiagram</code>关键词定义。</li>
<li>通过<code>-&gt;&gt;</code>表示参与者之间的消息传递。</li>
<li>可以使用<code>loop</code>、<code>alt</code>等关键词描述循环和选择结构。</li>
</ul>
<h5 id="甘特图（Gantt-Chart）">甘特图（Gantt Chart）</h5>
<ul>
<li>使用<code>gantt</code>关键词定义。</li>
<li>定义任务和时间轴，如<code>section SectionName</code>和<code>TaskName :crit, active, x-day1, x3-day4</code>。</li>
</ul>
<h5 id="节点形状">节点形状</h5>
<ul>
<li>节点可以通过不同的括号和关键词来定义形状，如：
<ul>
<li><code>[方形]</code></li>
<li><code>(圆边矩形)</code></li>
<li><code>((圆形))</code></li>
<li><code>&#123;菱形&#125;</code></li>
<li>// 注释</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown简易上手</title>
    <url>/2024/06/23/markdown%E7%AE%80%E6%98%93%E4%B8%8A%E6%89%8B/</url>
    <content><![CDATA[<h1>markdown简易上手</h1>
<h3 id="编写渠道">编写渠道</h3>
<ul>
<li>软件：收费：<a href="https://typora.ymzhxing.cn/index.html?bd_vid=12314572084174744930%22%E4%B8%AD%E6%96%87%E7%BD%91%E7%AB%99%22">Typora</a>  不收费：<a href="https://apps.microsoft.com/detail/xp9khm4bk9fz7q?launch=true&amp;mode=full&amp;hl=zh-cn&amp;gl=cn&amp;ocid=bingwebsearch%22%E5%AE%98%E7%BD%91%22">VS Code</a>。</li>
<li>网站：程序员聚集网站都有这个功能如<a href="https://www.csdn.net/">CSDN</a>、<a href="https://github.com/">Github</a>。</li>
</ul>
<h3 id="VS-studio配置编辑器的链接">VS studio配置编辑器的链接</h3>
<ul>
<li>这告诉你怎么增加一个Markdown的扩展：<a href="https://blog.csdn.net/qq_35504602/article/details/108054416%22%E9%85%8D%E7%BD%AE%E8%BF%9E%E6%8E%A5%22">VS studio</a></li>
</ul>
<h3 id="起源与定义">起源与定义</h3>
<ul>
<li>起源：由约翰·格鲁伯（John Gruber）创建，旨在简化纯文本格式的文档编写。</li>
<li>定义：一种纯文本格式的标记语言，可选择性地转换为有效的XHTML（或HTML）。</li>
<li>特性：语法简单，纯文本，可使用文本编辑器打开，并化成其他格式（HTML文档等）。</li>
</ul>
<h3 id="常用语法">常用语法</h3>
<ul>
<li>标题: #+“空格”+标题内容，得到标题，多个#号得到多级标题，最多6级；</li>
<li>引用：&gt;+“空格”+内容，得到引用内容</li>
<li>有序列表：序号+“空格”+内容<br>
 1 序列一<br>
 2 序列二<br>
 3 序列三</li>
<li>无序列表：-+“空格”+内容
<ul>
<li>a</li>
<li>b</li>
<li>c</li>
</ul>
</li>
<li>任务列表：-+‘‘空格’’+[ ],[]里面也要有空格
<ul>
<li>[ ] 任务一</li>
<li>[ ] 任务二</li>
<li>[ ] 任务三</li>
</ul>
</li>
<li>代码块：```c 三个反引号（键盘上和波浪线在一起）+语言  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">在这里插入代码 </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>数学公式：$$,中间加公式（不会也不打算学，就不做实列了</li>
<li>表格：|A|B|C|	表格头<br>
   |:—|—: | :—: |对齐方式：左。右。居中。<br>
   |qq|eee|wwww |打完按enter</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:right">B</th>
<th style="text-align:center">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">qqq</td>
<td style="text-align:right">eee</td>
<td style="text-align:center">www</td>
</tr>
</tbody>
</table>
<ul>
<li>脚注：ABC [ ^abc]————在文末或者下一行+[ ^abc]:注释内容就行<br>
ABC[^abc]<br>
[^abc]:skfkdsaif</li>
<li>横线：— 三个-生成一条横线，打完按enter</li>
</ul>
<hr>
<ul>
<li>链接：[ 百度]( caidu m&quot;注释&quot;) 会得到一个链接,中间的网址正确的话<br>
 <a href="baidu.com%22%E6%B3%A8%E9%87%8A%22"> 百度</a></li>
<li>图片：![百度]（）括号里面是图片链接</li>
<li>视频：直接找到网站上的视频，复制嵌入链接粘贴即可</li>
</ul>
<h3 id="行内格式">行内格式</h3>
<ul>
<li>斜体：**</li>
<li>加粗：****</li>
<li>编写行内代码：''反引号</li>
</ul>
<p><code>ssss</code></p>
<ul>
<li>下划线：&lt; u&gt;&lt; /u&gt;</li>
<li>行内数学公式：$$</li>
<li>高亮文字：== a==</li>
<li>首行缩进：&amp;emsp；</li>
</ul>
]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>shell脚本编写基础</title>
    <url>/2024/06/27/shell%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="shell脚本编辑">shell脚本编辑</h3>
<p>具体了解推荐：<a href="https://blog.csdn.net/weixin_53072519/article/details/125009092?ops_request_misc=%7B%22request%5Fid%22%3A%22171949229516777224488979%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171949229516777224488979&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125009092-null-null.142%5Ev100%5Econtrol&amp;utm_term=shell%E7%BC%96%E7%A8%8B&amp;spm=1018.2226.3001.4187">Linux实操篇——shell入门</a></p>
<h4 id="shell：">shell：</h4>
<ul>
<li>概念：Shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。</li>
<li>性质：一个命令行解释器，解释由用户输入的命令并把它们送到内核去执行。</li>
<li>作用：用户与内核进行交互的接口，负责接收用户输入的命令并送入内核执行</li>
</ul>
<h4 id="shell脚本：">shell脚本：</h4>
<ul>
<li>概念：用于编写自动化任务、批处理脚本和系统管理脚本的脚本语言</li>
<li>性质：利用Shell的功能所写的程序，写入到一个纯文本文件中。</li>
<li>作用：自动化执行一系列命令，减少手动操作的工作量，提高工作效率。</li>
</ul>
<h4 id="shell命令：">shell命令：</h4>
<p>Shell常见命令涵盖了文件目录操作、系统状态查看、网络配置与诊断、文件压缩与解压缩等多个方面。</p>
<h5 id="文件目录类">文件目录类</h5>
<h6 id="ls-列出目录内容"><code>ls</code> 列出目录内容</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l :显示详细的文件信息</span><br><span class="line">ls -a :显示隐藏文件</span><br><span class="line">ls -lS :以人类可读格式显示文件大小</span><br><span class="line">ls -lh :按文件大小排序</span><br></pre></td></tr></table></figure>
<h6 id="cd-切换目录"><code>cd</code> 切换目录</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd :切换到当前用户的home目录</span><br><span class="line">cd /path/bbb :切换到指定目录。</span><br><span class="line">cd .. :返回上一级目录。</span><br><span class="line">popd  :返回到前一个工作目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="pwd-显示当前目录路径。"><code>pwd</code> 显示当前目录路径。</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pwd :会显示当前工作目录</span><br></pre></td></tr></table></figure>
<h6 id="mkdir-创建目录。"><code>mkdir</code> 创建目录。</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir AAA :创建目录AAA</span><br><span class="line">mkdir AAA BBB CCC :创建多个目录，只有某些shell里面有</span><br><span class="line">mkdir -p A/B/C :创建三层目录A/B/C</span><br></pre></td></tr></table></figure>
<h6 id="cp-复制文件或目录"><code>cp</code> 复制文件或目录</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp A B :A被复制到B（B存在则覆盖，不存在则创建）</span><br><span class="line">cp A B KKK/:A B复制到KKK目录下面</span><br><span class="line">cp -r A B/ :复制A到B（B必须存在）</span><br></pre></td></tr></table></figure>
<h6 id="rm-删除文件或目录"><code>rm</code> 删除文件或目录</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm A :删除名为A的文件</span><br><span class="line">rm A B C :删除多个文件</span><br><span class="line">rm -r KKK :删除目录及其内容（一般是-rf,不用确认）</span><br></pre></td></tr></table></figure>
<h6 id="cat查看文件内容"><code>cat</code>查看文件内容</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat A :查看文件内容（-n对每一行输出加上行号，-s不显示多余空白行）</span><br><span class="line">cat A B&gt;C :合并A、B到C里去</span><br><span class="line">cat A&gt;&gt;B  :向B里面追加A的内容</span><br></pre></td></tr></table></figure>
<h6 id="more-less-分页查看文件内容"><code>more</code>,<code> less</code> 分页查看文件内容</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">more -5 A :显示A的前五行（内容超过终端大小的时候，按空格键翻页）</span><br><span class="line">less -N A :显示A，并添加行号(在less中使用/A 来搜索A)</span><br></pre></td></tr></table></figure>
<h6 id="head-tail查看文件的开头或结尾部分内容"><code>head</code>,<code>tail</code>查看文件的开头或结尾部分内容</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">head A :显示A前<span class="number">10</span>行(-n <span class="number">20</span>显示前<span class="number">20</span>行 -c <span class="number">20</span>显示前<span class="number">20</span>个字节)</span><br><span class="line">tail A :显示A后<span class="number">10</span>行(-n <span class="number">20</span>显示后<span class="number">20</span>行 -f 实时跟踪文件更新内容)</span><br></pre></td></tr></table></figure>
<h6 id="find-搜索文件"><code>find</code> 搜索文件</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find [路径][选项][表达式][操作]</span><br><span class="line">find /A/b -name&quot;*.log&quot; -ls :查找？、/A/b 目录先所有.log文件，并ls出来</span><br></pre></td></tr></table></figure>
<h6 id="ln-创建链接"><code>ln</code> 创建链接</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln [选项] 源文件 目标文件或者目录</span><br><span class="line">ln A B :B是A的一个硬链接（-s就是软连接）</span><br></pre></td></tr></table></figure>
<h6 id="du显示目录所占用的磁盘空间"><code>du</code>显示目录所占用的磁盘空间</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">du [选项][文件或者目录]</span><br><span class="line">du -h :显示当前目录及其子目录的磁盘使用情况（人类可读）</span><br><span class="line">du -sh /A/B :显示/A/B目录的磁盘使用情况</span><br></pre></td></tr></table></figure>
<h5 id="文件压缩和归档">文件压缩和归档</h5>
<h6 id="tar打包与压缩文件"><code>tar</code>打包与压缩文件</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar [选项] 归档文件 目标</span><br><span class="line">tar -czvf A.tar.gz AAA/ :创建一个gzip压缩的tar归档文件</span><br><span class="line">tar -xzvf A.tar.gz      :从gzip压缩的tar归档文件中提取内容</span><br></pre></td></tr></table></figure>
<h6 id="gzip-gunzip-压缩和解压-gz文件"><code>gzip</code>,<code>gunzip</code> 压缩和解压.gz文件</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gzip A :把A压缩成A.gz(-k 保留源文件，否则不保留)</span><br><span class="line">gzip -r A/ :压缩A目录中所有文件</span><br><span class="line">gunzip A.gz :把A.gz解压缩到A（-k保留源文件，否则不保留）</span><br><span class="line">gunzip -c A.gz&gt;A :这会将 A.gz 解压缩后的数据写入 A，而不会删除或覆盖任何文件。</span><br></pre></td></tr></table></figure>
<h5 id="系统状态类">系统状态类</h5>
<h6 id="top-监控系统资源利用情况"><code>top</code> 监控系统资源利用情况</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top 	:内容多，系统时间、运行时间、登录用户数、系统负载：进程列表：内存和交换空间信息：</span><br><span class="line">man top :获取更详细的信息和用法说明。</span><br></pre></td></tr></table></figure>
<h6 id="df显示磁盘空间使用情况"><code>df</code>显示磁盘空间使用情况</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df     :文件系统：1K-块：已用：可用：已用%：挂载点：</span><br><span class="line">man df :了解更多用法说明</span><br></pre></td></tr></table></figure>
<h6 id="uptime显示系统运行时间和负载"><code>uptime</code>显示系统运行时间和负载</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uptime  :当前时间 up 系统运行时间, 用户数, load average: 最近1分钟, 最近5分钟, 最近15分钟</span><br></pre></td></tr></table></figure>
<h6 id="who-w显示当前登录在系统上的用户信息"><code>who</code>,<code>w</code>显示当前登录在系统上的用户信息</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">who   :显示用户名、登录终端、登录时间以及从哪个主机登录（如果适用）</span><br><span class="line">w 	  :提供了更详细的信息</span><br></pre></td></tr></table></figure>
<h5 id="网络类">网络类</h5>
<h6 id="ping检查网络连通性"><code>ping</code>检查网络连通性</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping &lt;hostname-or-ip-address&gt;  :一个地址</span><br></pre></td></tr></table></figure>
<h6 id="ifconfig配置网络接口参数"><code>ifconfig</code>配置网络接口参数</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig:将显示系统上所有活动网络接口的信息，包括IP地址、子网掩码、广播地址、MAC地址等。</span><br></pre></td></tr></table></figure>
<h6 id="netstat显示网络连接、路由表、网卡统计数信息"><code>netstat</code>显示网络连接、路由表、网卡统计数信息</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat :是一个命令行工具，用于显示网络连接、路由表、接口统计等网络相关信息。</span><br></pre></td></tr></table></figure>
<h6 id="traceroute追踪网络数据包传输路径"><code>traceroute</code>追踪网络数据包传输路径</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">是一个网络诊断工具，用于跟踪和显示数据包从源主机到目标主机所经过的每一跳（路由器）的路径。</span><br></pre></td></tr></table></figure>
<h5 id="其他">其他</h5>
<h6 id="man，info查看命令的帮助文档"><code>man</code>，<code>info</code>查看命令的帮助文档</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man [命令]  :查看详细内容</span><br><span class="line">info [主题] :访问GUN项目的Info文档</span><br></pre></td></tr></table></figure>
<h6 id="alias创建命令别名"><code>alias</code>创建命令别名</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias :查看所有别名</span><br><span class="line">alias ll=&#x27;ls -l&#x27;:设置‘ll’为‘ls -l’的别名</span><br></pre></td></tr></table></figure>
<h6 id="chmod，chown，chgrp-修改文件权限，所属用户和组"><code>chmod</code>，<code>chown</code>，<code>chgrp</code> 修改文件权限，所属用户和组</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 750 文件名</span><br><span class="line">数字7代表所有者权限（4+2+1=7，即读/写/执行）。</span><br><span class="line">数字5代表组权限（4+1=5，即读/执行）。</span><br><span class="line">末尾的0代表其他用户无权限。</span><br><span class="line"></span><br><span class="line">sudo chown 新用户名 文件名</span><br><span class="line"></span><br><span class="line">sudo chgrp 新组名 文件名</span><br></pre></td></tr></table></figure>
<h6 id="history查看命令历史记录"><code>history</code>查看命令历史记录</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">history :显示所有历史命令</span><br></pre></td></tr></table></figure>
<h4 id="shell脚本编辑-2">shell脚本编辑</h4>
<p>Shell脚本本质上是纯文本文件(.sh)，其中包含一系列要由shell（如bash、sh、zsh等）执行的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span>  </span><br><span class="line">echo &quot;Hello, World!&quot;  </span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure>
<h5 id="shell变量">shell变量</h5>
<p>在Shell脚本中，变量是用于存储数据的占位符。Shell变量可以存储数字、字符串、文件名等任何类型的数据。Shell变量是区分大小写的，并且在使用时不需要声明其类型。</p>
<h6 id="定义变量">定义变量</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义一个字符串变量</span>  </span><br><span class="line">my_string=&quot;Hello, World!&quot;  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义一个数字变量</span>  </span><br><span class="line">my_number=42  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义一个特殊字符或空格的变量（需要使用引号）</span>  </span><br><span class="line">my_special_var=&quot;This is a string with spaces&quot;</span><br></pre></td></tr></table></figure>
<h6 id="使用变量">使用变量</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">引用变量</span>  </span><br><span class="line">echo $my_string  # 输出: Hello, World!  </span><br><span class="line">echo $my_number  # 输出: 42  </span><br><span class="line">echo $my_special_var  # 输出: This is a string with spaces  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以使用花括号来明确变量的边界（当变量名后紧跟其他字符时）</span>  </span><br><span class="line">echo $&#123;my_string&#125;World  # 输出: Hello, World!World  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变量名大小写敏感</span>  </span><br><span class="line">echo $MY_STRING  # 输出为空，因为MY_STRING未定义</span><br></pre></td></tr></table></figure>
<h6 id="变量赋值">变量赋值</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用反引号进行命令替换</span>  </span><br><span class="line">files_count=`ls | wc -l`  </span><br><span class="line">echo $files_count  # 输出当前目录下的文件数量  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用$(...)进行命令替换</span>  </span><br><span class="line">files_count=$(ls | wc -l)  </span><br><span class="line">echo $files_count  # 同样输出当前目录下的文件数量</span><br></pre></td></tr></table></figure>
<h5 id="shell运算符">shell运算符</h5>
<h6 id="算数运算符">算数运算符</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span>  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接赋值</span>  </span><br><span class="line">num1=10  </span><br><span class="line">num2=20  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加法</span>  </span><br><span class="line">sum=$((num1 + num2))  </span><br><span class="line">echo &quot;The sum is: $sum&quot;  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">乘法</span>  </span><br><span class="line">product=$((num1 * num2))  </span><br><span class="line">echo &quot;The product is: $product&quot;  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">幂运算（使用<span class="built_in">expr</span>命令）</span>  </span><br><span class="line">result=$(expr $num1 ** $num2)  </span><br><span class="line">echo &quot;The result of $num1 to the power of $num2 is: $result&quot;  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋值运算符</span>  </span><br><span class="line">num1+=5  </span><br><span class="line">echo &quot;After adding 5 to num1, it is: $num1&quot;</span><br></pre></td></tr></table></figure>
<h6 id="关系运算符">关系运算符</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span>  </span><br><span class="line">  </span><br><span class="line">num1=10  </span><br><span class="line">num2=20  </span><br><span class="line">  </span><br><span class="line">if [ $num1 -eq $num2 ]; then  </span><br><span class="line">    echo &quot;num1 is equal to num2&quot;  </span><br><span class="line">elif [ $num1 -gt $num2 ]; then  </span><br><span class="line">    echo &quot;num1 is greater than num2&quot;  </span><br><span class="line">else  </span><br><span class="line">    echo &quot;num1 is less than num2&quot;  </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h6 id="布尔运算符">布尔运算符</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span>  </span><br><span class="line">  </span><br><span class="line">num1=10  </span><br><span class="line">num2=20  </span><br><span class="line">  </span><br><span class="line">if [ $num1 -eq 10 ] &amp;&amp; [ $num2 -eq 20 ]; then  </span><br><span class="line">    echo &quot;Both num1 and num2 are correct&quot;  </span><br><span class="line">else  </span><br><span class="line">    echo &quot;At least one of the numbers is incorrect&quot;  </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h6 id="字符串运算符">字符串运算符</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span>  </span><br><span class="line">  </span><br><span class="line">str1=&quot;Hello&quot;  </span><br><span class="line">str2=&quot;World&quot;  </span><br><span class="line">  </span><br><span class="line">if [ $str1 = $str2 ]; then  </span><br><span class="line">    echo &quot;$str1 is equal to $str2&quot;  </span><br><span class="line">else  </span><br><span class="line">    echo &quot;$str1 is not equal to $str2&quot;  </span><br><span class="line">fi  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查字符串长度是否为零</span>  </span><br><span class="line">str3=&quot;&quot;  </span><br><span class="line">if [ -z &quot;$str3&quot; ]; then  </span><br><span class="line">    echo &quot;str3 is empty&quot;  </span><br><span class="line">else  </span><br><span class="line">    echo &quot;str3 is not empty&quot;  </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h6 id="文件测试运算符">文件测试运算符</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span>  </span><br><span class="line">  </span><br><span class="line">file=&quot;/path/to/some/file.txt&quot;  </span><br><span class="line">  </span><br><span class="line">if [ -e &quot;$file&quot; ]; then  </span><br><span class="line">    echo &quot;The file $file exists&quot;  </span><br><span class="line">elif [ -d &quot;$file&quot; ]; then  </span><br><span class="line">    echo &quot;The $file is a directory&quot;  </span><br><span class="line">else  </span><br><span class="line">    echo &quot;The file $file does not exist&quot;  </span><br><span class="line">fi  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查文件是否可读、可写、可执行</span>  </span><br><span class="line">if [ -r &quot;$file&quot; ]; then  </span><br><span class="line">    echo &quot;The file $file is readable&quot;  </span><br><span class="line">fi  </span><br><span class="line">  </span><br><span class="line">if [ -w &quot;$file&quot; ]; then  </span><br><span class="line">    echo &quot;The file $file is writable&quot;  </span><br><span class="line">fi  </span><br><span class="line">  </span><br><span class="line">if [ -x &quot;$file&quot; ]; then  </span><br><span class="line">    echo &quot;The file $file is executable&quot;  </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h6 id="命令替换运算符">命令替换运算符</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span>  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用命令替换获取当前日期</span>  </span><br><span class="line">today=$(date)  </span><br><span class="line">echo &quot;Today&#x27;s date is: $today&quot;  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用命令替换获取文件内容（假设文件为file.txt）</span>  </span><br><span class="line">content=$(cat file.txt)  </span><br><span class="line">echo &quot;The content of file.txt is:&quot;  </span><br><span class="line">echo &quot;$content&quot;</span><br></pre></td></tr></table></figure>
<h6 id="字符串引用">字符串引用</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span>  </span><br><span class="line">  </span><br><span class="line">name=&quot;John Doe&quot;  </span><br><span class="line">greeting=&quot;Hello, $&#123;name&#125;!&quot;  </span><br><span class="line">echo &quot;$greeting&quot;  # 输出: Hello, John Doe!  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用双引号保留特殊字符</span>  </span><br><span class="line">path=&quot;/home/$USER/Documents&quot;  </span><br><span class="line">echo &quot;$path&quot;  # 输出: /home/username/Documents（其中username是当前登录用户的用户名）</span><br></pre></td></tr></table></figure>
<h5 id="shell条件判断">shell条件判断</h5>
<p>在Shell脚本中，条件判断是非常重要的，它允许脚本根据某些条件执行不同的代码块。Shell提供了多种条件判断的方式，下面是一些常见的例子：</p>
<h6 id="测试命令">测试命令</h6>
<pre><code>* `[ ]` 或 `test` 命令用于执行条件测试。
* 常见的测试有文件测试（如 `-f` 检查文件是否存在且是一个普通文件）、字符串测试（如 `=`, `!=` 比较字符串）和数字测试（如 `-eq`, `-ne`, `-gt`, `-lt`, `-ge`, `-le` 比较数字）。
</code></pre>
<h6 id="if-语句">if 语句</h6>
<p>使用 <code>if</code>, <code>elif</code> 和 <code>else</code> 进行条件判断。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># code to execute if condition is true</span></span><br><span class="line"><span class="keyword">elif</span> [ another_condition ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># code to execute if another_condition is true</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># code to execute if none of the conditions are true</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h6 id="字符串比较">字符串比较</h6>
<pre><code>* `=`, `==`：检查两个字符串是否相等。
* `!=`：检查两个字符串是否不相等。
* `-z`：检查字符串长度是否为零。
* `-n`：检查字符串长度是否非零。
</code></pre>
<h6 id="数字比较">数字比较</h6>
<pre><code>* `-eq`：等于
* `-ne`：不等于
* `-gt`：大于
* `-lt`：小于
* `-ge`：大于或等于
* `-le`：小于或等于
</code></pre>
<h6 id="文件测试">文件测试</h6>
<pre><code>* `-e`：文件存在
* `-f`：是一个普通文件
* `-d`：是一个目录
* `-r`：文件可读
* `-w`：文件可写
* `-x`：文件可执行
* `-s`：文件大小非零
* `-L`：是一个符号链接
* 等等...
</code></pre>
<h6 id="逻辑操作符">逻辑操作符</h6>
<pre><code>* `!`：逻辑非
* `-a` 或 `&amp;&amp;`：逻辑与
* `-o` 或 `||`：逻辑或
</code></pre>
<h6 id="示例">示例</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查文件是否存在</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;/path/to/file.txt&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;File exists.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;File does not exist.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查两个数字是否相等</span></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -eq <span class="variable">$b</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;a is equal to b&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;a is not equal to b&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用逻辑操作符</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;/path/to/file1.txt&quot;</span> ] &amp;&amp; [ -f <span class="string">&quot;/path/to/file2.txt&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Both files exist.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;One or both files do not exist.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>注意：在 <code>[</code> 和 <code>]</code> 之间以及 <code>[</code> 之后和 <code>]</code> 之前都需要有空格。例如，<code>[ -f &quot;/path/to/file.txt&quot; ]</code> 是正确的，但 <code>[ -f&quot;/path/to/file.txt&quot;]</code> 是错误的。</p>
<h5 id="shell流程控制">shell流程控制</h5>
<p>在Shell脚本中，流程控制是非常重要的，它允许脚本根据条件或循环执行不同的代码块。除了前面提到的条件判断（如<code>if</code>、<code>elif</code>、<code>else</code>）外，Shell还提供了循环结构（如<code>for</code>、<code>while</code>、<code>until</code>）以及控制结构（如<code>break</code>、<code>continue</code>）。</p>
<h6 id="条件判断-if-elif-else">条件判断(<code>if</code>, <code>elif</code>, <code>else</code>)</h6>
<p>之前已经提到，<code>if</code>语句用于根据条件执行不同的代码块。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># code to execute if condition is true</span></span><br><span class="line"><span class="keyword">elif</span> [ another_condition ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># code to execute if another_condition is true</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># code to execute if none of the conditions are true</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h6 id="循环结构">循环结构</h6>
<ul>
<li>
<p><strong>for循环</strong>：用于遍历列表（如数组或字符串）中的元素。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> variable <span class="keyword">in</span> list</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># code to execute for each element in list</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>或者使用C风格的for循环：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (( i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># code to execute for each iteration</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>while循环</strong>：当条件为真时，重复执行代码块。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> [ condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># code to execute while condition is true</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>until循环</strong>：当条件为假时，重复执行代码块。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">until</span> [ condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># code to execute until condition is true</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="控制结构">控制结构</h6>
<ul>
<li>
<p><strong>break</strong>：用于立即终止循环（最内层循环）。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> [ <span class="literal">true</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># some code</span></span><br><span class="line">    <span class="keyword">if</span> [ some_condition ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>continue</strong>：用于跳过当前循环迭代，直接进入下一次迭代。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$file</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">continue</span>  <span class="comment"># skip directories</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="comment"># process files</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="函数：允许你定义可重用的代码块，并在脚本中多次调用。">函数：允许你定义可重用的代码块，并在脚本中多次调用。</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">my_function</span></span>() &#123;</span><br><span class="line">    <span class="comment"># code to execute when function is called</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># calling the function</span></span><br><span class="line">my_function</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p><strong>case语句</strong>：类似于其他编程语言中的switch语句，用于根据变量的值执行不同的代码块。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="variable">$variable</span> <span class="keyword">in</span></span><br><span class="line">    pattern1)</span><br><span class="line">        <span class="comment"># code to execute if $variable matches pattern1</span></span><br><span class="line">        ;;</span><br><span class="line">    pattern2)</span><br><span class="line">        <span class="comment"># code to execute if $variable matches pattern2</span></span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        <span class="comment"># code to execute if $variable doesn&#x27;t match any patterns</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>select语句</strong>：用于创建菜单，允许用户从一组选项中选择一个。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> option <span class="keyword">in</span> <span class="string">&quot;Option 1&quot;</span> <span class="string">&quot;Option 2&quot;</span> <span class="string">&quot;Quit&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$option</span> <span class="keyword">in</span></span><br><span class="line">        <span class="string">&quot;Option 1&quot;</span>)</span><br><span class="line">            <span class="comment"># code for Option 1</span></span><br><span class="line">            ;;</span><br><span class="line">        <span class="string">&quot;Option 2&quot;</span>)</span><br><span class="line">            <span class="comment"># code for Option 2</span></span><br><span class="line">            ;;</span><br><span class="line">        <span class="string">&quot;Quit&quot;</span>)</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Invalid option&quot;</span></span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这些流程控制结构使Shell脚本能够处理复杂的逻辑和场景。</p>
<h5 id="shell读取控制台输入">shell读取控制台输入</h5>
<p>在Shell脚本中，你可以使用<code>read</code>命令来读取控制台输入。<code>read</code>命令允许你从标准输入（通常是键盘）读取一行数据，并将其存储在变量中。</p>
<p>以下是如何使用<code>read</code>命令的基本示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示用户输入名字</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;请输入你的名字: &quot;</span></span><br><span class="line"><span class="built_in">read</span> name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出用户输入的名字</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;你好, <span class="variable">$name</span>!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以同时读取多个变量的值</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;请输入你的名字和年龄，用空格分隔: &quot;</span></span><br><span class="line"><span class="built_in">read</span> firstname lastname age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出用户输入的名字和年龄</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;你好, <span class="variable">$firstname</span> <span class="variable">$lastname</span>! 你的年龄是 <span class="variable">$age</span>。&quot;</span></span><br></pre></td></tr></table></figure>
<p>在上面的脚本中，<code>echo -n</code>命令用于打印提示信息，但是<code>-n</code>选项会阻止换行符的打印，这样提示信息就会和用户的输入在同一行显示。</p>
<p><code>read</code>命令后面跟着的变量名（如<code>name</code>、<code>firstname</code>、<code>lastname</code>和<code>age</code>）用于存储用户的输入。当用户输入数据后，这些数据会被存储在相应的变量中，然后你可以在你的脚本中使用这些变量。</p>
<p>如果你想要读取密码或其他敏感信息，并且不希望这些信息在输入时显示在屏幕上，你可以使用<code>read</code>命令的<code>-s</code>选项，这样用户的输入就会被隐藏：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;请输入密码: &quot;</span></span><br><span class="line"><span class="built_in">read</span> -s password</span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="comment"># 注意：这里我们加了一个echo命令来创建一个新的行，因为-s选项会阻止换行符的打印</span></span><br></pre></td></tr></table></figure>
<p>另外，如果你想要限制用户输入的字符数，你可以使用<code>-n</code>选项（注意这里的<code>-n</code>和前面用于禁止换行的<code>-n</code>不同）和一个数字来指定最大字符数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;请输入最多5个字符的字符串: &quot;</span></span><br><span class="line"><span class="built_in">read</span> -n 5 input_string</span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="comment"># input_string现在将包含用户输入的前5个字符（或更少的字符，如果用户输入少于5个字符）</span></span><br></pre></td></tr></table></figure>
<p>1</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络概述总结</title>
    <url>/2024/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="计算网络体系概述">计算网络体系概述</h3>
<h4 id="相关问题">相关问题</h4>
<ul>
<li>计算机网络为什么要分层？</li>
<li>计算机网络是怎么分层的？</li>
<li>三种计算机网络模型的关系是什么？每一层分别包含哪些协议？</li>
<li>计算机网络中，数据如何在各层中传播？数据在网络各层中的存在形式是怎么样的？</li>
</ul>
<h4 id="OSI七层模型">OSI七层模型</h4>
<p>OSI（Open Systems Interconnection）是开放系统互连参考模型的缩写，它是一个定义得非常好的协议规范集，它为各种系统定义了一个层次结构和一套用于协调与控制各层活动的规则，模型有七层结构。OSI模型的七层结构及其简要描述：</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>名称</th>
<th>简要描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>物理层 (Physical Layer)</td>
<td>定义了物理设备标准，如网络接口、传输介质等，负责传输原始比特流。</td>
</tr>
<tr>
<td>2</td>
<td>数据链路层 (Data Link Layer)</td>
<td>在物理层提供的服务基础上，建立相邻节点之间的数据链路，进行差错控制和流量控制。</td>
</tr>
<tr>
<td>3</td>
<td>网络层 (Network Layer)</td>
<td>负责为分组交换网上的不同主机提供通信服务，实现路由选择和分组转发。</td>
</tr>
<tr>
<td>4</td>
<td>传输层 (Transport Layer)</td>
<td>提供端到端的通信服务，负责数据的分段、重组和差错控制，确保数据的可靠传输。</td>
</tr>
<tr>
<td>5</td>
<td>会话层 (Session Layer)</td>
<td>负责建立、管理和终止会话过程，同步不同设备上的各种表示层实体。</td>
</tr>
<tr>
<td>6</td>
<td>表示层 (Presentation Layer)</td>
<td>对应用层数据进行表示和转换，如数据压缩、加密和解密、数据格式转换等。</td>
</tr>
<tr>
<td>7</td>
<td>应用层 (Application Layer)</td>
<td>为网络应用提供访问OSI环境的手段，定义应用进程间通信和交互的规则。</td>
</tr>
</tbody>
</table>
<p>这个表格简洁地概述了OSI模型的每一层及其主要功能。需要注意的是，虽然OSI模型在理论上是一个完善的参考模型，但在实际应用中，TCP/IP协议族由于其简洁性和高效性而被广泛采用。</p>
<h4 id="TCP-IP五层协议">TCP/IP五层协议</h4>
<p>五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层。其中应用层对应 OSI 的上三层，下四层和 OSI 相同。五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。TCP/IP五层协议栈：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>主要功能</th>
<th>主要协议/技术</th>
</tr>
</thead>
<tbody>
<tr>
<td>物理层</td>
<td>负责物理传输介质上比特流的传输</td>
<td>无（依赖于物理介质）</td>
</tr>
<tr>
<td>数据链路层</td>
<td>负责将数据封装成帧，进行差错控制和流量控制</td>
<td>以太网、PPP</td>
</tr>
<tr>
<td>网络层</td>
<td>负责数据包的路由和转发，实现不同网络之间的通信</td>
<td>IP、ICMP、IGMP、ARP、RARP</td>
</tr>
<tr>
<td>传输层</td>
<td>负责端到端的数据传输，提供可靠或不可靠的数据传输服务</td>
<td>TCP、UDP</td>
</tr>
<tr>
<td>应用层</td>
<td>提供网络应用服务，处理特定应用的数据格式</td>
<td>HTTP、FTP、SMTP、DNS、SSH</td>
</tr>
</tbody>
</table>
<p>这个表格简要地概括了TCP/IP五层协议栈中每一层的主要功能以及该层使用的主要协议或技术。这些协议共同协作，确保数据能够正确、高效地从源地址传输到目标地址。</p>
<h4 id="数据在各层之间的传输">数据在各层之间的传输</h4>
<p>在TCP/IP五层协议栈中，数据并不是直接在各层之间传输的，而是经历了一个封装和解封装的过程。这个过程确保了数据从源地址到目标地址的可靠传输。以下是数据在各层之间传输的详细步骤：</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>物理层</th>
<th>数据链路层</th>
<th>网络层</th>
<th>传输层</th>
<th>应用层</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据类型</td>
<td>比特流</td>
<td>帧、数据帧</td>
<td>数据报、数据包</td>
<td>报文段、数据段</td>
<td>报文</td>
</tr>
<tr>
<td>添加部分</td>
<td>前导码</td>
<td>MAC头部</td>
<td>IP头部</td>
<td>TCP头部</td>
<td>数据</td>
</tr>
</tbody>
</table>
<h5 id="应用层：">应用层：</h5>
<ul>
<li>应用层是TCP/IP模型的最上层，直接为用户的应用程序（如浏览器、电子邮件客户端等）提供服务。</li>
<li>在应用层，应用程序（如HTTP服务器或FTP客户端）生成数据，这些数据可能是文本、图片、音频或视频等。</li>
<li>应用层将数据封装成应用层协议所能理解的数据格式，如HTTP请求或FTP命令。</li>
</ul>
<h5 id="传输层：">传输层：</h5>
<ul>
<li>传输层负责提供端到端的数据传输服务，包括可靠性和流量控制。</li>
<li>在传输层，数据被封装成传输层协议的数据单元，对于TCP来说是TCP段（segment），对于UDP来说是UDP数据报（datagram）。</li>
<li>封装过程中，传输层会添加源端口号和目的端口号等信息，以便在接收端能够正确地将数据交付给相应的应用程序。</li>
</ul>
<h5 id="网络层：">网络层：</h5>
<ul>
<li>网络层负责网络间的通信，主要处理路由和转发。</li>
<li>在网络层，数据被封装成IP数据报（datagram）。封装过程中，会添加源IP地址和目的IP地址等信息。</li>
<li>网络层根据路由选择算法，将数据报从源主机发送到目的主机。</li>
</ul>
<h5 id="数据链路层：">数据链路层：</h5>
<ul>
<li>数据链路层负责处理本地网络的通信，包括帧的构造和解析。</li>
<li>在数据链路层，IP数据报被封装成帧（frame）。封装过程中，会添加帧头（包含源MAC地址和目的MAC地址）和帧尾（包含校验信息）。</li>
<li>数据链路层通过物理层提供的服务，将数据帧从一个节点传输到下一个节点。</li>
</ul>
<h5 id="物理层：">物理层：</h5>
<ul>
<li>物理层是TCP/IP模型的最底层，负责将比特流转换成物理信号，并在物理介质上进行传输。</li>
<li>物理层将数据帧转换成适合在物理介质上传输的比特流，如电信号或光信号。</li>
<li>比特流通过物理介质（如电缆、光纤等）传输到目的主机。</li>
</ul>
<h3 id="应用层">应用层</h3>
<h4 id="相关问题-2">相关问题</h4>
<ul>
<li>uri 和 url 的区别 ？</li>
<li>dns 是啥工作原理，主要解析过程是啥？</li>
<li>用户输入网址到显示对应页面的全过程是啥？</li>
<li>http 头部包含哪些信息？</li>
<li>http 方法了解哪些？</li>
<li>http 状态码了解哪些？</li>
<li>get 和 post 的区别？</li>
<li>https 和 https 的区别？</li>
<li>https 的加密方式？</li>
<li>http 是不保存状态的协议,如何保存用户状态？</li>
<li>http 不同版本的区别？</li>
</ul>
<h4 id="万维网和域名系统">万维网和域名系统</h4>
<p>万维网（简称WWW或Web）和域名系统（简称DNS）是互联网中两个重要的组成部分，它们各自在互联网的运作中扮演着关键角色。</p>
<h5 id="P2P和C-S">P2P和C/S</h5>
<p>P2P（Peer-to-Peer）与C/S（Client/Server）是计算机网络中两种常见的通信模式，P2P是一种去中心化的网络架构，适用于资源共享和实时通信；而C/S是一种中心化的架构，适用于需要集中管理和控制的应用场景。</p>
<h6 id="P2P（Peer-to-Peer）">P2P（Peer-to-Peer）</h6>
<p>定义：P2P是一种网络架构，其中每个设备（称为“对等点”或“节点”）都可以直接与其他设备通信，而不需要通过中央服务器。</p>
<p>特点：</p>
<ul>
<li>去中心化：没有中央控制点，每个节点都可以相互通信。</li>
<li>资源共享：节点可以共享文件、带宽等资源。</li>
<li>灵活：节点可以动态地加入或离开网络。</li>
</ul>
<p>应用场景：文件共享（如BitTorrent）、即时通讯（如Skype或某些在线游戏）。</p>
<h6 id="C-S（Client-Server）">C/S（Client/Server）</h6>
<p>定义：C/S架构中，有一个或多个服务器负责存储数据和处理请求，而客户端设备（如电脑、手机等）则发送请求给服务器并接收响应。</p>
<p>特点：</p>
<ul>
<li>集中管理：数据和服务由服务器集中提供。</li>
<li>安全性：服务器可以提供安全控制和数据完整性检查。</li>
<li>响应速度快：客户端与服务器直接通信，响应通常较快。</li>
</ul>
<p>应用场景：Web应用（如网站）、数据库系统、电子邮件服务等。</p>
<h5 id="Web结构组件">Web结构组件</h5>
<p>web结构组件指的是构成Web系统的基础元素，这些组件共同协作，使得Web应用能够正常运行并提供服务，以下是一些Web结构组件：</p>
<table>
<thead>
<tr>
<th>组件名称</th>
<th>定义</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>代理（Proxy）</td>
<td>中间服务器，用于转发客户端和服务器之间的请求和响应</td>
<td>提高性能、安全性或进行内容过滤</td>
</tr>
<tr>
<td>缓存（Cache）</td>
<td>存储常用页面副本的地方，以减少网络带宽使用和加快页面加载速度</td>
<td>提高Web应用的响应速度</td>
</tr>
<tr>
<td>网关（Gateway）</td>
<td>连接其他应用或服务的服务器，例如连接Web服务器到FTP服务器的中间件</td>
<td>协议转换和服务集成</td>
</tr>
<tr>
<td>Agent代理</td>
<td>发起HTTP请求的Web客户端，如浏览器、网络爬虫等</td>
<td>代表用户或系统发送HTTP请求</td>
</tr>
<tr>
<td>Web组件（Web Components）</td>
<td>封装好的可复用的自定义元素，用于构建Web应用</td>
<td>提高Web开发的效率和可维护性</td>
</tr>
<tr>
<td>网络协议（Network Protocols）</td>
<td>计算机之间通信的规则，如HTTP和HTTPS</td>
<td>确保客户端和服务器之间能够正确通信</td>
</tr>
<tr>
<td>域名系统（DNS）</td>
<td>将域名转换为IP地址的系统</td>
<td>使人们可以通过易记的域名来访问网站</td>
</tr>
</tbody>
</table>
<h5 id="DNS">DNS</h5>
<p>域名服务器（Domain Name Server，简称DNS）是互联网中至关重要的基础设施之一，它负责将人类可读的域名（<a href="http://xn--example-i22m.com">如example.com</a>）映射到与之对应的IP地址（如192.0.2.1）。</p>
]]></content>
      <categories>
        <category>计算机四大件</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
