<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++常见设计模式</title>
    <url>/2024/07/04/C-%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="设计模式">设计模式</h3>
<p>设计模式（Design Patterns）是软件开发人员在软件设计过程中面临的一般问题的解决方案。它们不是直接用来完成工作的代码或“完成品”，而是描述如何组织代码和对象，以及它们之间的交互和职责分配的一种抽象方式。设计模式使得代码更加灵活、可重用、易于理解和维护。</p>
<h5 id="设计模式的六大原则">设计模式的六大原则</h5>
<ol>
<li><strong>单一职责原则（SRP）</strong>：一个类负责一项职责。</li>
<li><strong>开闭原则（OCP）</strong>：软件应对扩展开放，对修改关闭。</li>
<li><strong>里氏替换原则（LSP）</strong>：子类可以替换父类且功能不受影响。</li>
<li><strong>依赖倒置原则（DIP）</strong>：高层模块不应依赖低层模块，而应依赖抽象。</li>
<li><strong>接口隔离原则（ISP）</strong>：使用多个小接口比单一大接口好。</li>
<li><strong>迪米特法则（LoD）</strong>：一个类应尽量少地了解其他类。</li>
</ol>
<h4 id="单例模式">单例模式</h4>
<p>单例模式（Singleton Pattern）是一种常用的软件设计模式，用于确保一个类仅有一个实例，并提供一个全局访问点来获取这个唯一实例。这种模式在需要控制资源访问，如数据库连接、文件句柄或者需要确保配置信息的全局唯一性等场景下非常有用。</p>
<p>在C++中，单例模式（Singleton Pattern）是一种确保一个类仅有一个实例，并提供一个全局访问点来获取该实例的设计模式。以下是C++中实现单例模式的几种方式：</p>
<h5 id="饿汉式（Eager-Initialization）">饿汉式（Eager Initialization）</h5>
<p>饿汉式单例模式在类加载时就完成了实例的初始化，因此它是线程安全的，但可能会导致资源浪费，因为实例在程序启动时就已经创建，即使它可能从未被使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;_slt; <span class="comment">// 返回静态成员变量的地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他成员函数...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125; <span class="comment">// 构造函数私有化</span></span><br><span class="line">    <span class="type">static</span> Singleton _slt; <span class="comment">// 静态成员变量，类加载时初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝构造和赋值构造</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外初始化静态成员变量</span></span><br><span class="line">Singleton Singleton::_slt;</span><br></pre></td></tr></table></figure>
<h5 id="懒汉式（Lazy-Initialization，线程不安全）">懒汉式（Lazy Initialization，线程不安全）</h5>
<p>懒汉式单例模式在需要时才创建实例，但如果不加锁，它在多线程环境下可能会创建多个实例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他成员函数...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125; <span class="comment">// 构造函数私有化</span></span><br><span class="line">    <span class="type">static</span> Singleton* instance; <span class="comment">// 静态指针成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝构造和赋值构造</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>注意：上述代码在多线程环境下是不安全的。</p>
<h5 id="懒汉式（Lazy-Initialization，线程安全）">懒汉式（Lazy Initialization，线程安全）</h5>
<p>为了在多线程环境下保证懒汉式单例模式的线程安全，可以在<code>GetInstance()</code>方法中添加锁。但这种方式可能会影响性能，因为每次调用<code>GetInstance()</code>都需要加锁。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他成员函数...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125; <span class="comment">// 构造函数私有化</span></span><br><span class="line">    <span class="type">static</span> Singleton* instance; <span class="comment">// 静态指针成员变量</span></span><br><span class="line">    <span class="type">static</span> std::mutex mtx; <span class="comment">// 静态互斥锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝构造和赋值构造</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Singleton::mtx;</span><br></pre></td></tr></table></figure>
<h5 id="局部静态变量（C-11及更高版本）">局部静态变量（C++11及更高版本）</h5>
<p>C++11引入了局部静态变量的线程安全初始化，这使得实现单例模式变得更加简单和高效。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance; <span class="comment">// 局部静态变量，线程安全地初始化</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他成员函数...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125; <span class="comment">// 构造函数私有化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝构造和赋值构造</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种方法利用了C++11中的“Magic Static”特性，即在多线程环境下，局部静态变量的初始化是线程安全的。因此，这种方法既简单又高效，是推荐使用的实现方式。</p>
<h4 id="工厂模式">工厂模式</h4>
<p>工厂模式（Factory Pattern）是一种创建型设计模式，它提供了一种创建对象的最佳方式，而无需在代码中显式指定所要创建的具体类。工厂模式主要用于创建具有共同接口的对象，但又不希望客户端依赖于这些对象的具体类。工厂模式可以细分为简单工厂模式、工厂方法模式和抽象工厂模式。</p>
<h5 id="简单工厂模式（Simple-Factory-Pattern）">简单工厂模式（Simple Factory Pattern）</h5>
<p>简单工厂模式又称为静态工厂方法模式，它由一个工厂类根据传入的参数决定创建哪一种类的实例。这种模式通常包括三个角色：工厂类角色、抽象产品角色和具体产品角色。</p>
<p><strong>实现示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 抽象产品角色  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 抽象方法  </span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Product</span>() &#123;&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 具体产品角色A  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA</span> : <span class="keyword">public</span> Product &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using ConcreteProductA&quot;</span> &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 具体产品角色B  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB</span> : <span class="keyword">public</span> Product &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using ConcreteProductB&quot;</span> &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 工厂类角色  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductFactory</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">static</span> std::unique_ptr&lt;Product&gt; <span class="title">createProduct</span><span class="params">(<span class="type">const</span> std::string&amp; type)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">&quot;A&quot;</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;ConcreteProductA&gt;();  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;B&quot;</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;ConcreteProductB&gt;();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 或者抛出异常  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">auto</span> productA = ProductFactory::<span class="built_in">createProduct</span>(<span class="string">&quot;A&quot;</span>);  </span><br><span class="line">    <span class="keyword">if</span> (productA) &#123;  </span><br><span class="line">        productA-&gt;<span class="built_in">use</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">auto</span> productB = ProductFactory::<span class="built_in">createProduct</span>(<span class="string">&quot;B&quot;</span>);  </span><br><span class="line">    <span class="keyword">if</span> (productB) &#123;  </span><br><span class="line">        productB-&gt;<span class="built_in">use</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="工厂方法模式（Factory-Method-Pattern）">工厂方法模式（Factory Method Pattern）</h5>
<p>工厂方法模式定义一个用于创建对象的接口，但让子类决定要实例化的类是哪一个。工厂方法让类的实例化推迟到子类中进行。</p>
<p><strong>实现示例</strong>（基于上面的示例稍作修改）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂类  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductFactory</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;Product&gt; <span class="title">createProduct</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 工厂方法  </span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ProductFactory</span>() &#123;&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 具体工厂类A  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactoryA</span> : <span class="keyword">public</span> ProductFactory &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function">std::unique_ptr&lt;Product&gt; <span class="title">createProduct</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;ConcreteProductA&gt;();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 具体工厂类B  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactoryB</span> : <span class="keyword">public</span> ProductFactory &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function">std::unique_ptr&lt;Product&gt; <span class="title">createProduct</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;ConcreteProductB&gt;();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    std::unique_ptr&lt;ProductFactory&gt; factoryA = std::<span class="built_in">make_unique</span>&lt;ConcreteFactoryA&gt;();  </span><br><span class="line">    <span class="keyword">auto</span> productA = factoryA-&gt;<span class="built_in">createProduct</span>();  </span><br><span class="line">    productA-&gt;<span class="built_in">use</span>();  </span><br><span class="line">  </span><br><span class="line">    std::unique_ptr&lt;ProductFactory&gt; factoryB = std::<span class="built_in">make_unique</span>&lt;ConcreteFactoryB&gt;();  </span><br><span class="line">    <span class="keyword">auto</span> productB = factoryB-&gt;<span class="built_in">createProduct</span>();  </span><br><span class="line">    productB-&gt;<span class="built_in">use</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="抽象工厂模式（Abstract-Factory-Pattern）">抽象工厂模式（Abstract Factory Pattern）</h5>
<p>抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。它允许客户端使用抽象的接口来创建一组相关的产品，而不需要知道（或关心）实际产出的具体产品是什么。由于它涉及到多个产品族，因此结构相对复杂。</p>
<p>假设我们有两个产品族：一个是汽车制造（包括跑车和SUV），另一个是手机制造（包括智能手机和平板电脑）。每个产品族内部的产品都是相互关联的，并且每个产品族都有其独特的实现方式。</p>
<p>首先，我们定义抽象产品和抽象工厂：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Vehicle</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">call</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Phone</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vehicle* <span class="title">createVehicle</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Phone* <span class="title">createPhone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ProductFactory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来，我们为汽车制造和手机制造分别定义具体的产品和工厂：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 汽车制造的具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SportsCar</span> : <span class="keyword">public</span> Vehicle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producing a Sports Car\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SUV</span> : <span class="keyword">public</span> Vehicle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producing an SUV\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手机制造的具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPhone</span> : <span class="keyword">public</span> Phone &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">call</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calling with a Smart Phone\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tablet</span> : <span class="keyword">public</span> Phone &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">call</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calling (or video calling) with a Tablet\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 汽车制造的具体工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarFactory</span> : <span class="keyword">public</span> ProductFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Vehicle* <span class="title">createVehicle</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SUV</span>(); <span class="comment">// 或者返回 new SportsCar();，取决于你想生产哪种汽车</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Phone* <span class="title">createPhone</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 汽车工厂不生产手机，所以返回一个null或者抛出一个异常</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手机制造的具体工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneFactory</span> : <span class="keyword">public</span> ProductFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Vehicle* <span class="title">createVehicle</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 手机工厂不生产汽车，所以返回一个null或者抛出一个异常</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Phone* <span class="title">createPhone</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SmartPhone</span>(); <span class="comment">// 或者返回 new Tablet();，取决于你想生产哪种手机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>请注意，在这个例子中，<code>CarFactory</code> 和 <code>PhoneFactory</code> 实际上并不是完整的抽象工厂实现，因为它们只生产各自领域内的产品。在更复杂的场景中，你可能会希望有一个能够同时生产汽车和手机的工厂（尽管这在现实中可能不太常见）。但为了演示目的，我们保持这两个工厂是独立的。</p>
<p>现在，让我们看看如何使用这些工厂：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ProductFactory* carFactory = <span class="keyword">new</span> <span class="built_in">CarFactory</span>();</span><br><span class="line">    Vehicle* myCar = carFactory-&gt;<span class="built_in">createVehicle</span>();</span><br><span class="line">    myCar-&gt;<span class="built_in">display</span>(); <span class="comment">// Producing an SUV</span></span><br><span class="line"></span><br><span class="line">    ProductFactory* phoneFactory = <span class="keyword">new</span> <span class="built_in">PhoneFactory</span>();</span><br><span class="line">    Phone* myPhone = phoneFactory-&gt;<span class="built_in">createPhone</span>();</span><br><span class="line">    myPhone-&gt;<span class="built_in">call</span>(); <span class="comment">// Calling with a Smart Phone</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> myCar;</span><br><span class="line">    <span class="keyword">delete</span> myPhone;</span><br><span class="line">    <span class="keyword">delete</span> carFactory;</span><br><span class="line">    <span class="keyword">delete</span> phoneFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子展示了如何在C++中使用抽象工厂模式来创建一系列相关的对象。每个工厂负责生产其特定领域内的产品。客户端代码通过工厂接口与工厂交互，而不需要知道具体的产品实现细节。</p>
<h4 id="观察者模式">观察者模式</h4>
<p>观察者模式（Observer Pattern）是一种行为设计模式，用于建立一种对象之间的一对多依赖关系，使得每当一个对象状态发生改变时，其所有依赖者都会得到通知并自动更新。这种模式提供了一种对象设计，让主题（subject）和观察者（observer）之间松耦合，这样它们就可以交互而不需要知道彼此的具体实现细节。</p>
<h5 id="观察者模式的主要角色：">观察者模式的主要角色：</h5>
<ol>
<li>
<p><strong>Subject（主题）</strong>：</p>
<ul>
<li>抽象主题：定义一个接口，可以增加、删除和通知观察者。</li>
<li>具体主题：存储着状态，当状态改变时，向所有观察者发出通知。</li>
</ul>
</li>
<li>
<p><strong>Observer（观察者）</strong>：</p>
<ul>
<li>抽象观察者：定义了一个更新接口，使得自身在得到主题的通知时更新自己。</li>
<li>具体观察者：实现抽象观察者的更新接口，以便在得到通知时执行具体操作。</li>
</ul>
</li>
</ol>
<h5 id="实现示例（C-）：">实现示例（C++）：</h5>
<p>下面是一个简单的C++实现示例，其中有一个<code>Subject</code>类和一个<code>Observer</code>接口，以及它们的具体实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Observer 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteObserver</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; received: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subject 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Observer*&gt; observers;</span><br><span class="line">    std::string message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">attach</span><span class="params">(Observer* observer)</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">push_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">(Observer* observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(observers.<span class="built_in">begin</span>(), observers.<span class="built_in">end</span>(), observer);</span><br><span class="line">        <span class="keyword">if</span> (it != observers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            observers.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> observer : observers) &#123;</span><br><span class="line">            observer-&gt;<span class="built_in">update</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;message = message;</span><br><span class="line">        <span class="built_in">notify</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="function">ConcreteObserver <span class="title">obs1</span><span class="params">(<span class="string">&quot;Observer 1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ConcreteObserver <span class="title">obs2</span><span class="params">(<span class="string">&quot;Observer 2&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    subject.<span class="built_in">attach</span>(&amp;obs1);</span><br><span class="line">    subject.<span class="built_in">attach</span>(&amp;obs2);</span><br><span class="line"></span><br><span class="line">    subject.<span class="built_in">setMessage</span>(<span class="string">&quot;Hello, Observers!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    subject.<span class="built_in">detach</span>(&amp;obs1);</span><br><span class="line"></span><br><span class="line">    subject.<span class="built_in">setMessage</span>(<span class="string">&quot;Hello again, remaining Observers!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="关键点：">关键点：</h5>
<ul>
<li><strong>松耦合</strong>：主题和观察者之间通过抽象层进行交互，这使得它们可以独立地改变和复用。</li>
<li><strong>广播通信</strong>：当主题状态变化时，所有注册的观察者都会收到通知。</li>
<li><strong>动态关联</strong>：观察者可以在运行时被添加或删除，从而允许系统更灵活地改变行为。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>C++关键字和关键库函数细论</title>
    <url>/2024/07/02/C-%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0%E7%BB%86%E8%AE%BA/</url>
    <content><![CDATA[<h4 id="sizeof-与-strlen">sizeof 与 strlen</h4>
<p><code>sizeof</code>和<code>strlen</code>在C语言中各有其独特的用途和限制。<code>sizeof</code>主要用于获取对象或类型所占的内存字节数，而<code>strlen</code>则用于计算字符串的长度（不包括终止的空字符）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello, World!&quot;</span>;  </span><br><span class="line"><span class="type">char</span> *ptr = str;  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="built_in">sizeof</span>(str)); <span class="comment">// 输出整个数组所占的字节数，包括终止符&#x27;\0&#x27;，可能是13（取决于编译器和平台）  </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="built_in">sizeof</span>(ptr)); <span class="comment">// 输出指针变量ptr所占的字节数，通常是4或8（取决于平台）  </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="built_in">strlen</span>(str)); <span class="comment">// 输出字符串的长度，不包括终止符&#x27;\0&#x27;，输出12  </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="built_in">strlen</span>(ptr)); <span class="comment">// 同样输出12，因为ptr指向str</span></span><br></pre></td></tr></table></figure>
<h4 id="static关键字">static关键字</h4>
<p>在C++中，<code>static</code>关键字在C++中主要用于限制变量的作用域和生命周期，隐藏函数实现细节，以及实现类的静态成员变量和静态成员函数，这些特性在程序设计中非常有用。</p>
<ol>
<li>
<p><strong>局部静态变量</strong>：</p>
<ul>
<li>当<code>static</code>用于局部变量时（包括在函数内部定义的变量），这个变量在程序的整个执行期间只被初始化一次，并在函数调用结束后不会销毁，而是保持其值，直到程序结束。这意味着，在后续的函数调用中，这个局部静态变量的值会保持不变，除非在函数内部被显式修改。</li>
</ul>
</li>
<li>
<p><strong>全局静态变量</strong>：</p>
<ul>
<li>当<code>static</code>用于全局变量时，该变量的作用域被限制在定义它的文件内，即它是文件作用域的（file-scoped）。这意呀着，其他文件无法直接访问这个变量，从而避免了命名冲突。全局静态变量具有静态存储期，即在程序开始执行时被分配内存，并在程序结束时释放内存。</li>
</ul>
</li>
<li>
<p><strong>静态函数</strong>：</p>
<ul>
<li>当<code>static</code>用于函数声明时，这个函数就变成了静态函数。静态函数的作用域被限制在定义它的文件内，其他文件无法链接到这个函数。这有助于隐藏函数实现细节，减少命名空间污染。</li>
</ul>
</li>
<li>
<p><strong>静态成员变量</strong>：</p>
<ul>
<li>在类定义中，<code>static</code>关键字用于声明类的静态成员变量。静态成员变量属于类本身，而不是类的某个特定对象。这意味着，无论创建了多少个类的对象，静态成员变量都只有一份拷贝，并由所有对象共享。静态成员变量必须在类定义外部进行初始化。</li>
</ul>
</li>
<li>
<p><strong>静态成员函数</strong>：</p>
<ul>
<li><code>static</code>关键字也可以用于声明类的静态成员函数。静态成员函数只能访问类的静态成员变量和静态成员函数，不能访问类的非静态成员变量和非静态成员函数（因为它们属于类的特定对象）。静态成员函数不依赖于类的特定对象实例，因此可以通过类名直接调用，而无需创建类的实例。</li>
</ul>
</li>
<li>
<p><strong>静态类</strong>（注意：C++标准本身并不直接支持静态类概念，但可以通过静态成员变量和静态成员函数模拟静态类行为）：</p>
<ul>
<li>虽然在C++中没有直接称为“静态类”的语法结构，但可以通过将所有成员变量和成员函数都声明为静态来模拟静态类的行为。这样的类本质上成为了一个只包含静态成员和静态函数的命名空间，不包含任何非静态成员。</li>
</ul>
</li>
</ol>
<h4 id="const关键字">const关键字</h4>
<p>在C++中，<code>const</code>关键字是一个非常重要的修饰符，它用于声明一个变量、函数参数、返回值或成员函数为常量，即这些实体在声明之后其值（对于变量和函数参数）或行为（对于成员函数）将不能被修改。<code>const</code>的使用可以提高代码的可读性、安全性和可维护性。</p>
<ol>
<li><strong>修饰变量</strong>：当<code>const</code>修饰变量时，该变量成为常量，其值在初始化之后不能被修改。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxVal = <span class="number">100</span>; <span class="comment">// maxVal是一个常量，其值不能被修改</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>修饰指针</strong>：<code>const</code>可以修饰指针，但需要注意<code>const</code>的位置，因为它决定了是指针指向的值是常量，还是指针本身是常量，或者是两者都是。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr; <span class="comment">// ptr是一个指向int类型常量的指针，即不能通过ptr修改它所指向的值</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr; <span class="comment">// ptr是一个常量指针，指向int类型，即ptr的值（即它所指向的地址）不能被修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr; <span class="comment">// ptr是一个常量指针，指向int类型的常量，即ptr的值和它所指向的值都不能被修改</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>修饰函数参数</strong>：将<code>const</code>用于函数参数时，表明函数内部不会修改通过这个参数传入的变量。这可以提高函数的通用性，因为允许传入常量变量作为参数。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span>; <span class="comment">// x是通过引用传入的，但在函数内部不能被修改</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>修饰函数返回值</strong>：<code>const</code>也可以修饰函数的返回值，但这在大多数情况下并不是特别有用，因为返回值通常会被赋值给另一个变量，而赋值操作会丢弃<code>const</code>修饰符。然而，在返回引用或指针时，<code>const</code>修饰符可以表明返回的引用或指针指向的值不应被修改。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">getConstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> value; <span class="comment">// 返回对静态变量的const引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><strong>修饰成员函数</strong>：在类定义中，<code>const</code>可以修饰成员函数，表明该函数不会修改类的任何成员变量（除了那些被声明为<code>mutable</code>的成员变量）。这使得该函数可以被常量对象调用。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里不能修改类的任何成员变量（除了mutable的）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> MyClass obj;</span><br><span class="line">obj.<span class="built_in">func</span>(); <span class="comment">// 合法，因为func()是const成员函数</span></span><br></pre></td></tr></table></figure>
<h4 id="define-与-const区别">define 与 const区别</h4>
<p><code>define</code>和<code>const</code>在C/C++等编程语言中都是用于定义常量的方式，但它们之间存在显著的区别。</p>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center"><code>define</code></th>
<th style="text-align:center"><code>const</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>编译器处理方式</strong></td>
<td style="text-align:center">预处理阶段文本替换</td>
<td style="text-align:center">编译时类型检查</td>
</tr>
<tr>
<td style="text-align:center"><strong>类型检查</strong></td>
<td style="text-align:center">无类型，仅文本替换</td>
<td style="text-align:center">有明确类型，进行类型检查</td>
</tr>
<tr>
<td style="text-align:center"><strong>内存占用</strong></td>
<td style="text-align:center">不占用运行时内存（但可能增加代码段大小）</td>
<td style="text-align:center">占用运行时内存（可能通过优化减少）</td>
</tr>
<tr>
<td style="text-align:center"><strong>调试</strong></td>
<td style="text-align:center">调试时难以直接查看值</td>
<td style="text-align:center">调试时可直接查看值</td>
</tr>
<tr>
<td style="text-align:center"><strong>作用域和生命周期</strong></td>
<td style="text-align:center">全局有效（除非<code>#undef</code>），无作用域限制</td>
<td style="text-align:center">受限于定义位置的作用域和生命周期</td>
</tr>
<tr>
<td style="text-align:center"><strong>使用场景</strong></td>
<td style="text-align:center">全局常量定义，条件编译</td>
<td style="text-align:center">局部常量、类成员常量，提供类型安全和调试支持</td>
</tr>
<tr>
<td style="text-align:center"><strong>类型安全</strong></td>
<td style="text-align:center">不提供</td>
<td style="text-align:center">提供</td>
</tr>
<tr>
<td style="text-align:center"><strong>存储位置</strong></td>
<td style="text-align:center">预处理后嵌入代码中</td>
<td style="text-align:center">可能存储在符号表或内存中</td>
</tr>
<tr>
<td style="text-align:center"><strong>灵活性</strong></td>
<td style="text-align:center">灵活，可用于复杂宏定义</td>
<td style="text-align:center">适用于简单常量定义，易于理解和维护</td>
</tr>
</tbody>
</table>
<h4 id="inline关键字">inline关键字</h4>
<p><code>inline</code>关键字在C++中是一个非常重要的特性，它用于向编译器建议将函数的调用替换为函数体本身的直接展开，从而消除函数调用的开销，提高程序的执行效率。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：内联函数的定义  </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> n * n;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 类的成员函数示例  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">m_value</span>(value) &#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> m_value;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> m_value;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 在类外定义时添加inline关键字  </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">MyClass::getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> m_value;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="define-与-inline">define 与 inline</h4>
<p>下表格总结了<code>define</code>与<code>inline</code>之间的主要区别：</p>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center"><code>define</code>宏定义</th>
<th style="text-align:center"><code>inline</code>内联函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>定义方式</strong></td>
<td style="text-align:center">预处理指令<code>#define</code></td>
<td style="text-align:center">C++关键字<code>inline</code></td>
</tr>
<tr>
<td style="text-align:center"><strong>作用阶段</strong></td>
<td style="text-align:center">预处理阶段</td>
<td style="text-align:center">编译阶段</td>
</tr>
<tr>
<td style="text-align:center"><strong>作用域</strong></td>
<td style="text-align:center">无作用域限制，整个源文件有效</td>
<td style="text-align:center">遵循C++作用域规则</td>
</tr>
<tr>
<td style="text-align:center"><strong>类型检查</strong></td>
<td style="text-align:center">无类型检查，仅文本替换</td>
<td style="text-align:center">有类型检查，与普通函数相同</td>
</tr>
<tr>
<td style="text-align:center"><strong>安全性</strong></td>
<td style="text-align:center">可能引入副作用，如优先级问题、重复求值</td>
<td style="text-align:center">编译器进行更严格的检查，更安全</td>
</tr>
<tr>
<td style="text-align:center"><strong>调试能力</strong></td>
<td style="text-align:center">调试困难，因为宏展开后不易识别原始宏</td>
<td style="text-align:center">调试更容易，与普通函数一样</td>
</tr>
<tr>
<td style="text-align:center"><strong>性能影响</strong></td>
<td style="text-align:center">可能因重复求值或宏展开过大导致性能问题</td>
<td style="text-align:center">编译器决定是否内联，可能提高性能</td>
</tr>
<tr>
<td style="text-align:center"><strong>使用场景</strong></td>
<td style="text-align:center">定义常量、简单的表达式或代码片段，条件编译</td>
<td style="text-align:center">频繁调用且函数体较小的函数，以减少函数调用开销</td>
</tr>
<tr>
<td style="text-align:center"><strong>编译器行为</strong></td>
<td style="text-align:center">总是进行文本替换</td>
<td style="text-align:center">可能忽略<code>inline</code>建议，不内联函数</td>
</tr>
</tbody>
</table>
<h4 id="new-与-malloc">new 与 malloc</h4>
<p><code>new</code> 和 <code>malloc</code> 都是用于动态内存分配的机制，new<code> 是 C++ 语言中的操作符，而 malloc</code>是 C 语言标准库中的一个函数。</p>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center"><code>new</code> (C++)</th>
<th style="text-align:center"><code>malloc</code> ©</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>所属语言/库</strong></td>
<td style="text-align:center">C++ 语言操作符</td>
<td style="text-align:center">C 标准库函数</td>
</tr>
<tr>
<td style="text-align:center"><strong>语法</strong></td>
<td style="text-align:center"><code>Type* ptr = new Type(initializer);</code></td>
<td style="text-align:center"><code>void* ptr = malloc(size);</code></td>
</tr>
<tr>
<td style="text-align:center"><strong>初始化</strong></td>
<td style="text-align:center">支持自动初始化（调用构造函数）</td>
<td style="text-align:center">不自动初始化，需手动（如使用<code>memset</code>）</td>
</tr>
<tr>
<td style="text-align:center"><strong>类型安全</strong></td>
<td style="text-align:center">是，编译器检查类型</td>
<td style="text-align:center">否，返回<code>void*</code>，需显式类型转换</td>
</tr>
<tr>
<td style="text-align:center"><strong>内存管理</strong></td>
<td style="text-align:center">使用<code>delete</code>释放，自动调用析构函数</td>
<td style="text-align:center">使用<code>free</code>释放，不调用析构函数</td>
</tr>
<tr>
<td style="text-align:center"><strong>数组分配</strong></td>
<td style="text-align:center">使用<code>new[]</code>分配，<code>delete[]</code>释放</td>
<td style="text-align:center">分配时指定总大小，释放时同样使用<code>free</code></td>
</tr>
<tr>
<td style="text-align:center"><strong>异常安全</strong></td>
<td style="text-align:center">在分配失败时抛出<code>std::bad_alloc</code>异常</td>
<td style="text-align:center">分配失败时返回<code>NULL</code>（或<code>nullptr</code>，取决于C标准版本和编译器）</td>
</tr>
<tr>
<td style="text-align:center"><strong>用途</strong></td>
<td style="text-align:center">分配并初始化对象</td>
<td style="text-align:center">分配原始内存块</td>
</tr>
<tr>
<td style="text-align:center"><strong>性能</strong></td>
<td style="text-align:center">可能稍慢（因为调用构造函数）</td>
<td style="text-align:center">通常更快（仅分配内存）</td>
</tr>
<tr>
<td style="text-align:center"><strong>调试支持</strong></td>
<td style="text-align:center">更好的调试信息（如类型信息）</td>
<td style="text-align:center">调试信息较少，依赖于类型转换和初始化</td>
</tr>
</tbody>
</table>
<h4 id="delete-与-free">delete 与 free</h4>
<p>在 C++ 中，除非你有特殊理由需要使用 C 风格的内存管理（例如，与 C 代码库互操作），否则通常建议使用 <code>new</code> 和 <code>delete</code>，因为它们提供了更好的类型安全性和资源管理。</p>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center"><code>delete</code> (C++)</th>
<th style="text-align:center"><code>free</code> ©</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>所属语言</strong></td>
<td style="text-align:center">C++</td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center"><strong>用途</strong></td>
<td style="text-align:center">释放通过 <code>new</code> 分配的内存，并调用对象的析构函数（如果有）</td>
<td style="text-align:center">释放通过 <code>malloc</code>、<code>calloc</code> 或 <code>realloc</code> 分配的内存块</td>
</tr>
<tr>
<td style="text-align:center"><strong>语法</strong></td>
<td style="text-align:center"><code>delete ptr;</code>（单个对象）<br><code>delete[] ptr;</code>（对象数组）</td>
<td style="text-align:center"><code>free(void* ptr);</code></td>
</tr>
<tr>
<td style="text-align:center"><strong>行为</strong></td>
<td style="text-align:center">释放内存，并调用对象的析构函数（如果对象有析构函数）</td>
<td style="text-align:center">仅释放内存块，不调用析构函数</td>
</tr>
<tr>
<td style="text-align:center"><strong>类型安全</strong></td>
<td style="text-align:center">是，与对象的类型相关联</td>
<td style="text-align:center">否，返回 <code>void*</code>，需显式类型转换</td>
</tr>
<tr>
<td style="text-align:center"><strong>对NULL的处理</strong></td>
<td style="text-align:center">如果 <code>ptr</code> 是 <code>nullptr</code>（或 <code>NULL</code>，取决于C++标准版本），则不执行任何操作</td>
<td style="text-align:center">如果 <code>ptr</code> 是 <code>NULL</code>，则不执行任何操作</td>
</tr>
<tr>
<td style="text-align:center"><strong>异常安全</strong></td>
<td style="text-align:center">分配失败时抛出 <code>std::bad_alloc</code> 异常；释放内存时通常不失败</td>
<td style="text-align:center">不抛出异常，分配失败时返回 <code>NULL</code>（或 <code>nullptr</code>）</td>
</tr>
<tr>
<td style="text-align:center"><strong>内存管理</strong></td>
<td style="text-align:center">负责释放内存，并调用析构函数进行资源管理</td>
<td style="text-align:center">负责释放内存，但不负责资源管理（如文件句柄等）</td>
</tr>
<tr>
<td style="text-align:center"><strong>野指针问题</strong></td>
<td style="text-align:center">释放后应将指针设置为 <code>nullptr</code>（C++11及更高版本）以避免野指针</td>
<td style="text-align:center">释放后应将指针设置为 <code>NULL</code> 或指向其他有效内存</td>
</tr>
<tr>
<td style="text-align:center"><strong>用途场景</strong></td>
<td style="text-align:center">C++ 语言中的动态内存和对象生命周期管理</td>
<td style="text-align:center">C 语言中的动态内存管理</td>
</tr>
</tbody>
</table>
<h4 id="volatile">volatile</h4>
<p>在C++中，<code>volatile</code>关键字主要用于处理多线程环境或硬件访问时，确保变量的可见性和防止编译器对代码进行过度优化。</p>
<ul>
<li>
<p>可见性：当一个变量被声明为<code>volatile</code>时，它告诉编译器该变量的值可能会在程序的控制之外被改变（例如，由另一个线程或硬件事件改变）。因此，编译器在每次访问该变量时都必须重新从内存中读取它的值，而不是使用可能已经缓存在寄存器或CPU缓存中的值。</p>
</li>
<li>
<p>防止优化：<code>volatile</code>还阻止编译器对包含该变量的代码进行某些优化，比如将多次读取该变量的操作合并为一个，或者将写入操作延迟到更晚的时间点。</p>
</li>
<li>
<p>在某些嵌入式系统或需要直接与硬件交互的程序中，<code>volatile</code>可能用于确保对特定内存地址的访问不会被编译器优化掉，因为这些地址可能映射到硬件寄存器上。</p>
</li>
</ul>
<h4 id="struct关键字">struct关键字</h4>
<p>虽然C和C++都支持<code>struct</code>，但它们在用法和特性上存在一些差异，尤其是在C++中，随着类的引入，<code>struct</code>的一些行为变得与类相似，但也有一些关键区别。</p>
<ul>
<li>C语言：<code>struct</code>用于定义记录（record），它是一个或多个不同类型变量的集合。使用<code>struct</code>时，你需要首先声明它，然后才能创建该类型的变量。C中的<code>struct</code>默认访问权限是<code>public</code>（虽然C中没有直接使用<code>public</code>、<code>private</code>这样的关键字），这意味着结构体内的所有成员都可以从外部直接访问。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span>  </span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];  </span><br><span class="line">    <span class="type">int</span> age;  </span><br><span class="line">    <span class="type">float</span> height;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 创建Person类型的变量  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">person1</span>;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>C++：C++在C的基础上扩展了<code>struct</code>的功能，使其更加类似于类。C++中的<code>struct</code>和类的主要区别在于：</p>
<p><strong>默认访问权限</strong>：在C++中，<code>struct</code>的默认访问权限是<code>public</code>，而类的默认访问权限是<code>private</code>。</p>
<p><strong>继承</strong>：当<code>struct</code>或类被用作基类时，<code>struct</code>默认是公有继承（public inheritance），而类默认是私有继承（private inheritance）。但这一点在大多数情况下并不显著，因为在实际编程中通常会明确指定继承类型。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;  </span><br><span class="line">    std::string name;  </span><br><span class="line">    <span class="type">int</span> age;  </span><br><span class="line">    <span class="type">float</span> height;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 构造函数  </span></span><br><span class="line">    <span class="built_in">Person</span>(std::string n, <span class="type">int</span> a, <span class="type">float</span> h) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a), <span class="built_in">height</span>(h) &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 成员函数  </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, Height: &quot;</span> &lt;&lt; height &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 创建Person类型的变量  </span></span><br><span class="line"><span class="function">Person <span class="title">person1</span><span class="params">(<span class="string">&quot;John Doe&quot;</span>, <span class="number">30</span>, <span class="number">1.75f</span>)</span></span>;  </span><br><span class="line">person1.<span class="built_in">display</span>();</span><br></pre></td></tr></table></figure>
<h4 id="struct-与-union-的区别">struct 与 union 的区别</h4>
<p><code>struct</code>（结构体）和<code>union</code>（共用体）是C和C++中两种用于定义复合数据类型的关键字，它们之间在多个方面存在显著的区别。</p>
<ol>
<li>成员存储方式</li>
</ol>
<ul>
<li><strong>struct</strong>：结构体在内存中为每个成员分配独立的内存空间，所有成员变量都同时存在。结构体的大小是其所有成员大小的总和（加上可能的填充字节以满足内存对齐要求）。</li>
<li><strong>union</strong>：共用体在内存中只分配足够的空间来存储其最大成员，所有成员共享同一段内存空间。在任何时刻，共用体只能存储其一个成员的值，对其他成员的赋值会覆盖当前成员的值。</li>
</ul>
<ol start="2">
<li>内存分配</li>
</ol>
<ul>
<li><strong>struct</strong>：每个成员都有自己的内存位置，且成员在内存中的顺序与它们在结构体中声明的顺序相同。结构体的大小是其成员大小之和加上可能的填充字节，以确保结构体的对齐。</li>
<li><strong>union</strong>：所有成员共享同一内存位置，共用体的大小是其最大成员的大小（按照该成员类型的倍数进行对齐）。这意味着，无论共用体声明了多少个成员，它在内存中占用的空间都是固定的，且等于其最大成员的大小。</li>
</ul>
<ol start="3">
<li>成员访问和赋值</li>
</ol>
<ul>
<li><strong>struct</strong>：对结构体中不同成员的赋值是独立的，互不影响。可以通过结构体变量直接访问其任何成员。</li>
<li><strong>union</strong>：对共用体中不同成员的赋值会覆盖当前成员的值。在任一时刻，只能访问并安全地使用共用体中被赋值的那个成员。尝试访问未被赋值的成员将导致未定义行为。</li>
</ul>
<h3 id="6-示例">6. 示例</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// struct 示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// union 示例</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体变量</span></span><br><span class="line">Person person;</span><br><span class="line"><span class="comment">// 共用体变量</span></span><br><span class="line">Data data;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>Person</code>结构体将为其成员<code>name</code>、<code>age</code>和<code>height</code>分别分配内存空间，而<code>Data</code>共用体则只分配足够的空间来存储一个<code>int</code>、一个<code>float</code>或一个<code>char</code>数组（取其中最大者），并且这些成员共享这段空间。</p>
<h4 id="extern-C">extern&quot;C&quot;</h4>
<p>在C和C++编程中，<code>extern &quot;C&quot;</code>这个语法结构主要用于在C++代码中链接C代码，确保C++编译器能够正确地处理C语言编写的代码或库。</p>
<p>这是因为C++支持函数重载，而C不支持。C++编译器为了支持函数重载，会对函数名进行修饰（Name Mangling），这样编译后的函数名会包含函数参数类型的信息。然而，C编译器不会进行这样的修饰，因此如果C++代码直接调用C语言编写的函数，链接器会因为找不到未修饰的函数名而报错。</p>
<p>为了解决这个问题，<code>extern &quot;C&quot;</code>告诉C++编译器，被其修饰的代码应该按照C语言的编译和链接规则来处理。</p>
<ol>
<li>
<p><strong>对单个函数使用</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">my_c_function</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>对整个文件使用</strong>：<br>
如果一个头文件完全是用C语言编写的，并且打算被C和C++代码共同使用，可以在该头文件的开始处加上<code>extern &quot;C&quot;</code>的块包围整个文件的内容。但是，通常的做法是在C++代码中包含该头文件时，使用<code>extern &quot;C&quot;</code>，而不是修改头文件本身。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myclib.h&quot;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="strcpy函数">strcpy函数</h4>
<p><code>strcpy</code>函数的主要缺陷在于它不会检查目标缓冲区的大小，这可能导致缓冲区溢出。如果源字符串的长度超过目标缓冲区的大小，<code>strcpy</code>会继续复制直到遇到源字符串的终止符，从而覆盖相邻内存区域的数据，可能引发数据损坏、程序崩溃或安全漏洞。</p>
<p>为避免<code>strcpy</code>的缺陷，推荐使用更安全的字符串复制函数，如<code>strncpy</code>（需手动确保终止符）或<code>strncpy_s</code>（指定目标缓冲区大小）。这些函数提供了额外的边界检查，有助于防止缓冲区溢出。同时，也可以考虑使用高级语言特性，如C++中的<code>std::string</code>类，它自动管理内存并提供了更安全的字符串操作。</p>
<h4 id="lambda-表达式的应用">lambda 表达式的应用</h4>
<p>Lambda 表达式可以捕获其所在作用域中的变量，并允许你在需要函数对象的地方使用它们，而无需显式地定义一个函数或函数对象类型。</p>
<ul>
<li>基本语法:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture](parameters) <span class="keyword">mutable</span> -&gt; return_type &#123; body &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>示例：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式对 vector 中的元素进行排序  </span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;  </span><br><span class="line">        <span class="keyword">return</span> a &lt; b; <span class="comment">// Lambda 表达式，表示升序排序  </span></span><br><span class="line">    &#125;);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式和 std::for_each 遍历 vector  </span></span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> n) &#123;  </span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;  </span><br><span class="line">    &#125;);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="explicit-的作用">explicit 的作用</h4>
<p>当构造函数被声明为<code>explicit</code>时，它只能被显式地调用，不能通过隐式类型转换自动调用。<code>explicit</code>关键字主要用于修饰只有一个参数的构造函数。对于多参数构造函数，如果所有参数都有默认值，并且只有第一个参数是必需的，也可以使用<code>explicit</code>（尽管这种情况较少见）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 构造函数的实现  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(MyClass obj)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 函数的实现  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 正确，显式调用构造函数  </span></span><br><span class="line">    <span class="comment">// MyClass obj2 = 20; // 错误，如果构造函数是explicit的，则此行会编译失败  </span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj3</span><span class="params">(MyClass(<span class="number">20</span>))</span></span>; <span class="comment">// 正确，虽然绕了一点，但显式调用了构造函数  </span></span><br><span class="line">    <span class="built_in">func</span>(obj1); <span class="comment">// 正确  </span></span><br><span class="line">    <span class="comment">// func(30); // 错误，如果构造函数是explicit的，则此行会编译失败  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="define-与-typedef-的区别">define 与 typedef 的区别</h4>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>#define</code></th>
<th><code>typedef</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>执行时间和处理方式</strong></td>
<td>在预处理阶段进行文本替换，不进行类型检查或语法分析</td>
<td>在编译阶段处理，具有类型检查功能</td>
</tr>
<tr>
<td><strong>作用域</strong></td>
<td>从定义点开始，直到文件结束，除非使用<code>#undef</code>取消定义；可能跨越文件界限</td>
<td>限定在定义的作用域内，如文件、命名空间或函数内</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>定义常量、变量、编译开关、类型别名等；可以进行带参数的宏定义</td>
<td>主要用于定义类型的别名，简化复杂的类型声明</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>条件编译、宏展开、定义常量等；也可用于类型别名，但不如<code>typedef</code>清晰</td>
<td>提高代码的可读性和可维护性，特别是处理复杂类型声明和跨平台编程时</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #define 示例  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT_PTR int*  </span></span><br><span class="line">INT_PTR p1, p2; <span class="comment">// p1 和 p2 都是 int* 类型  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// typedef 示例  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* IntPtr;  </span><br><span class="line">IntPtr q1, q2; <span class="comment">// q1 和 q2 都是 int* 类型</span></span><br></pre></td></tr></table></figure>
<h4 id="class-与-struct-的异同">class 与 struct 的异同</h4>
<ul>
<li>
<p>相似之处</p>
<p><strong>自定义数据类型</strong>：两者都允许用户定义自己的数据类型，封装数据成员和成员函数。</p>
<p><strong>成员组成</strong>：都可以包含成员变量（属性）和成员函数（方法）。</p>
<p><strong>继承</strong>：都支持继承机制，可以创建基于现有类型的新类型。</p>
<p><strong>访问控制</strong>：都可以使用访问修饰符（如<code>public</code>、<code>private</code>、<code>protected</code>）来控制成员的访问权限。</p>
</li>
<li>
<p>不同之处</p>
<p><strong>默认访问权限</strong>：<code>class</code>的默认成员访问权限是<code>private</code>。<code>struct</code>的默认成员访问权限是<code>public</code>。</p>
<p><strong>继承方式</strong>：<code>class</code>默认使用<code>private</code>继承。<code>struct</code>默认使用<code>public</code>继承。</p>
<p><strong>用途和语义</strong>：<code>class</code>更常用于面向对象编程，表示具有行为和属性的对象。<code>struct</code>虽然也可以用于面向对象编程，但更常用于表示简单的数据结构或记录，其成员通常是可以直接访问的公共数据。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++关键字和关键库函数</tag>
      </tags>
  </entry>
  <entry>
    <title>C++I/O进程技术</title>
    <url>/2024/07/04/C-I-O%E8%BF%9B%E7%A8%8B%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h4 id="C-条件变量">C++条件变量</h4>
<p>C++中的条件变量（Condition Variable）是一种同步原语，用于在多线程程序中阻塞一个或多个线程，直到收到另一个线程的通知。条件变量通常与互斥锁（Mutex）一起使用，以确保在访问共享数据时线程之间的同步。</p>
<h5 id="基本概念">基本概念</h5>
<ul>
<li><strong>互斥锁（Mutex）</strong>：用于保护共享数据，防止多个线程同时访问造成数据竞争。</li>
<li><strong>条件变量（Condition Variable）</strong>：用于等待某个条件成立。当条件不满足时，线程会阻塞在条件变量上，等待其他线程修改条件并通知（notify）条件变量。</li>
</ul>
<h5 id="使用条件变量的步骤">使用条件变量的步骤</h5>
<ol>
<li><strong>创建互斥锁和条件变量</strong>：在需要同步的共享数据附近创建互斥锁和条件变量。</li>
<li><strong>加锁</strong>：在访问共享数据或等待条件变量之前，先对互斥锁加锁。</li>
<li><strong>等待条件变量</strong>：如果条件不满足，则调用条件变量的等待函数（如<code>wait</code>、<code>wait_for</code>、<code>wait_until</code>），这会使当前线程阻塞并释放互斥锁，直到其他线程调用条件变量的通知函数（<code>notify_one</code>或<code>notify_all</code>）唤醒它。</li>
<li><strong>被唤醒后重新加锁</strong>：当线程被唤醒后，会自动重新对互斥锁加锁，然后再次检查条件是否满足。</li>
<li><strong>解锁</strong>：在访问完共享数据后，对互斥锁进行解锁。</li>
</ol>
<h5 id="示例">示例</h5>
<p>以下是一个简单的使用条件变量的示例，展示了生产者-消费者模型的基本思想：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Produced &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; by producer &quot;</span> &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知一个等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (!ready) cv.<span class="built_in">wait</span>(lck); <span class="comment">// 等待条件变量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当我们到达这里时，我们知道条件为真</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumed &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">empty</span>()) <span class="keyword">break</span>; <span class="comment">// 如果队列为空，则退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::thread producers[<span class="number">10</span>];</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer_thread</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动10个生产者</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        producers[i] = std::<span class="built_in">thread</span>(producer, i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有生产者完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : producers) th.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    consumer_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：这个示例为了简化，<code>ready</code>变量被用作一个简单的条件标志。在实际应用中，你可能需要更复杂的条件逻辑来确保线程间的正确同步。此外，示例中的<code>consumer</code>函数使用了<code>while</code>循环来检查条件，这是因为在<code>wait</code>函数返回后，条件可能已经被其他线程改变了，所以需要重新检查条件是否仍然满足。</p>
<h4 id="线程同步和异步">线程同步和异步</h4>
<p>线程同步（Synchronous Threads）和异步（Asynchronous Threads）是并发编程中的两个重要概念，它们在处理线程间的任务执行顺序和数据共享方面存在显著差异。</p>
<h5 id="线程同步">线程同步</h5>
<p><strong>定义</strong>：线程同步是指多个线程在执行过程中，需要按照一定的顺序或规则来访问共享资源或执行特定操作，以确保数据的一致性和程序的正确性。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>顺序执行</strong>：一个线程必须等待另一个线程完成其任务后才能继续执行。这保证了程序的执行顺序和数据的一致性。</li>
<li><strong>数据一致性</strong>：同步线程能够确保在多个线程同时访问共享数据时，数据的一致性和完整性。</li>
<li><strong>易于编程和维护</strong>：同步线程的执行流程相对简单，容易理解和实现，也有利于代码的维护和调试。</li>
<li><strong>适用场景</strong>：适用于需要按照特定顺序执行任务、保证数据一致性的场景，如银行转账系统中的转账操作。</li>
</ul>
<p><strong>实现方式</strong>：同步可以通过多种机制来实现，如互斥锁（Mutex）、信号量（Semaphore）、事件（Event）等。这些机制用于控制线程对共享资源的访问，确保同一时刻只有一个线程可以访问该资源。</p>
<h5 id="线程异步">线程异步</h5>
<p><strong>定义</strong>：线程异步是指一个线程在执行任务时，不需要等待该任务完成就可以继续执行其他任务。这种方式允许线程并行处理任务，从而提高程序的执行效率。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>并行执行</strong>：异步线程允许线程并行处理任务，从而加快程序的执行速度。</li>
<li><strong>减少等待时间</strong>：当一个线程需要等待某个资源或完成某个长时间运行的任务时，异步线程可以让其他线程继续执行，从而减少用户等待时间。</li>
<li><strong>充分利用多核资源</strong>：异步线程可以充分利用多核处理器的计算能力，提高程序的并行处理能力。</li>
<li><strong>复杂性增加</strong>：异步编程通常比同步编程更复杂，需要处理回调、Promise、事件等，容易导致代码难以理解和维护。</li>
<li><strong>调试困难</strong>：异步操作的非线性执行顺序使得调试和追踪问题变得更加困难。</li>
</ul>
<p><strong>适用场景</strong>：异步线程适用于需要并行处理大量任务、提高程序执行效率的场景，如网络编程、文件IO操作、复杂计算等。</p>
<h4 id="C11的同步和异步">C11的同步和异步</h4>
<p>在C++中，线程同步和异步是处理多线程程序时需要考虑的重要方面。C++标准库从C++11开始引入了多线程支持，包括线程（<code>std::thread</code>）、互斥锁（<code>std::mutex</code>）、条件变量（<code>std::condition_variable</code>）、锁保护器（如<code>std::lock_guard</code>和<code>std::unique_lock</code>）等，用于实现线程的同步和异步。</p>
<h5 id="线程同步-2">线程同步</h5>
<p>在C++中，线程同步通常涉及使用互斥锁、条件变量或其他同步机制来确保多个线程在访问共享资源时不会出现数据竞争或条件竞争。例如：</p>
<ul>
<li><strong>互斥锁（<code>std::mutex</code>）</strong>：用于保护共享数据，确保同一时间只有一个线程可以访问该数据。</li>
<li><strong>条件变量（<code>std::condition_variable</code>）</strong>：与互斥锁一起使用，允许线程在特定条件未满足时挂起，并在条件满足时被其他线程唤醒。</li>
<li><strong>锁保护器（<code>std::lock_guard</code>、<code>std::unique_lock</code>）</strong>：这些RAII（Resource Acquisition Is Initialization）风格的封装器可以自动管理互斥锁的加锁和解锁，减少死锁的风险。</li>
</ul>
<h5 id="线程异步-2">线程异步</h5>
<p>在C++中，实现线程异步通常意味着启动一个或多个线程来并行执行任务，而这些任务的执行不会阻塞主线程或调用线程。例如：</p>
<ul>
<li><strong><code>std::thread</code></strong>：用于表示一个独立的执行线程。你可以创建一个<code>std::thread</code>对象来启动一个新线程，并在其中执行指定的函数或可调用对象。</li>
<li><strong>异步操作（如<code>std::async</code>）</strong>：从C++11开始，<code>std::async</code>函数提供了一种启动异步任务的方法。它返回一个<code>std::future</code>对象，该对象可以用来获取异步操作的结果。<code>std::async</code>可以自动管理线程的创建和销毁，以及结果的存储和检索。</li>
<li><strong>并发算法和容器</strong>：C++标准库还提供了一些并发算法和容器（如<code>std::vector</code>的并行算法版本），它们可以在多个线程上并行执行操作，从而提高程序的执行效率。</li>
</ul>
<h4 id="C-I-o操作">C++I/o操作</h4>
<p>在C++中，I/O（输入/输出）操作是程序与外部世界交互的基本方式。C++标准库提供了丰富的I/O库来支持文件、控制台（命令行）以及其他输入输出设备的数据交换。以下是一些主要的C++ I/O操作及其相关类的概述：</p>
<h5 id="标准输入输出流">标准输入输出流</h5>
<ul>
<li><strong><code>std::cin</code></strong>：用于从标准输入（通常是键盘）读取数据。</li>
<li><strong><code>std::cout</code></strong>：用于向标准输出（通常是屏幕）输出数据。</li>
<li><strong><code>std::cerr</code></strong>：用于向标准错误输出流输出错误信息，通常不经过缓冲，直接输出。</li>
<li><strong><code>std::clog</code></strong>：类似于<code>std::cerr</code>，但它会经过缓冲处理。</li>
</ul>
<p>这些流都继承自<code>std::ostream</code>（对于输出）或<code>std::istream</code>（对于输入）类，并提供了丰富的成员函数和操作符重载来支持格式化输入输出。</p>
<h5 id="文件输入输出">文件输入输出</h5>
<p>C++通过<code>std::ifstream</code>（用于从文件读取数据）、<code>std::ofstream</code>（用于向文件写入数据）和<code>std::fstream</code>（同时支持读写）类来支持文件I/O。这些类都是模板类，但它们通常与<code>char</code>类型一起使用，分别对应<code>std::ifstream&lt;char&gt;</code>、<code>std::ofstream&lt;char&gt;</code>和<code>std::fstream&lt;char&gt;</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (outFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        outFile &lt;&lt; <span class="string">&quot;Hello, file!&quot;</span>;</span><br><span class="line">        outFile.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;</span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">if</span> (inFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">getline</span>(inFile, line)) &#123;</span><br><span class="line">            std::cout &lt;&lt; line &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inFile.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="字符串流">字符串流</h5>
<p>C++还提供了<code>std::istringstream</code>、<code>std::ostringstream</code>和<code>std::stringstream</code>类，用于在字符串上进行输入输出操作。这些类非常有用，特别是当你需要在内存中进行数据转换或分割时。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string data = <span class="string">&quot;123 456 789&quot;</span>;</span><br><span class="line">    <span class="function">std::istringstream <span class="title">iss</span><span class="params">(data)</span></span>;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span> (iss &gt;&gt; num) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;The answer is &quot;</span> &lt;&lt; <span class="number">42</span>;</span><br><span class="line">    std::string answer = oss.<span class="built_in">str</span>();</span><br><span class="line">    std::cout &lt;&lt; answer &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="格式化输入输出">格式化输入输出</h5>
<p>C++标准库中的I/O流支持通过<code>iomanip</code>库中的操作符和函数来格式化输出。例如，你可以设置浮点数的小数点后的位数、控制整数的基数（十进制、十六进制等）、填充字符等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; <span class="number">3.14159</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 输出: 3.14</span></span><br><span class="line">    std::cout &lt;&lt; std::hex &lt;&lt; <span class="number">255</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 输出: ff</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="缓冲区管理">缓冲区管理</h5>
<p>所有的I/O流都使用缓冲区来管理数据的输入输出。你可以通过成员函数如<code>flush()</code>、<code>sync()</code>和<code>pubsync()</code>来管理缓冲区，确保数据被及时写出或读入。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>I/O与进程同步</tag>
      </tags>
  </entry>
  <entry>
    <title>C++特性和新特性</title>
    <url>/2024/07/02/C-%E7%89%B9%E6%80%A7%E5%92%8C%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h3 id="C-特性和新特性">C++特性和新特性</h3>
<h4 id="C-11">C++11</h4>
<p>C++11是C++编程语言的一个重要标准版本，是C++98标准发布后13年来的第一次重大修正，它引入了许多新特性和改进，极大地增强了C++语言的表达能力和开发效率。</p>
<p>C++11是C++编程语言的一个重要标准版本，由国际标准化组织(ISO)和国际电工委员会(IEC)旗下的C++标准委员会(ISO/IEC JTC1/SC22/WG21)于2011年8月12日公布，并于2011年9月正式出版，其标准文件号为ISO/IEC 14882:2011。C++11是C++98标准发布后13年来的第一次重大修正，它引入了许多新特性和改进，极大地增强了C++语言的表达能力和开发效率。以下是对C++11的一些主要特性和改进的归纳：</p>
<h5 id="核心语言的新机能">核心语言的新机能</h5>
<h6 id="自动类型推导（auto）："><strong>自动类型推导（auto）</strong>：</h6>
<p>C++11引入了auto关键字，用于自动推导变量的类型，使得代码更加简洁，特别是在处理复杂类型或模板类型时。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 使用auto推导vector&lt;int&gt;类型  </span></span><br><span class="line">    <span class="keyword">auto</span> myVector = std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 遍历vector  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = myVector.<span class="built_in">begin</span>(); it != myVector.<span class="built_in">end</span>(); ++it) &#123;  </span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 推导函数返回类型  </span></span><br><span class="line">    <span class="keyword">auto</span> result = myVector.<span class="built_in">size</span>(); <span class="comment">// result的类型是std::vector&lt;int&gt;::size_type，通常是unsigned int  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="decltype："><strong>decltype</strong>：</h6>
<p>与auto类似，但decltype用于推导表达式的类型，适用于auto无法使用的场景。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;  </span><br><span class="line">    <span class="comment">// 使用decltype获取x的类型，并声明同类型的变量y  </span></span><br><span class="line">    <span class="keyword">decltype</span>(x) y = x;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 也可以用于复杂表达式  </span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;  </span><br><span class="line">    <span class="keyword">decltype</span>(a + b) c = a + b; <span class="comment">// c的类型是int  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 引用类型  </span></span><br><span class="line">    <span class="type">int</span>&amp; ref = x;  </span><br><span class="line">    <span class="keyword">decltype</span>(ref) anotherRef = y; <span class="comment">// anotherRef也是int&amp;类型  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 注意，decltype(表达式)的结果取决于表达式的形式  </span></span><br><span class="line">    <span class="keyword">decltype</span>((x)) wholeX = x; <span class="comment">// wholeX是int&amp;，因为表达式(x)是左值  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="右值引用和移动语义："><strong>右值引用和移动语义</strong>：</h6>
<p>引入了右值引用（T&amp;&amp;）和移动语义，允许临时对象（右值）的资源被“窃取”以进行高效的资源转移，避免了不必要的拷贝操作。</p>
<ul>
<li>右值引用：右值引用是C++11中引入的一个关键特性，它允许程序员显式地将一个表达式标记为右值，从而可以利用移动语义进行优化。在C++中，每个表达式都可以被分类为左值或右值。左值是指那些可以取地址的表达式，如变量、数组元素等，而右值则是指那些不能取地址的表达式，如字面量、临时变量、表达式求值结果等。右值引用就是用来引用这些右值的类型，其语法是在变量名前添加两个连续的“&amp;”符号，如“int&amp;&amp;”。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; rvalueRef = <span class="number">10</span>; <span class="comment">// 正确：10是右值，可以被右值引用绑定  </span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;  </span><br><span class="line"><span class="type">int</span>&amp;&amp; rvalueRef2 = std::<span class="built_in">move</span>(x); <span class="comment">// 正确：使用std::move将x转换为右值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>移动语义：移动语义是C++11中引入的一种新的语言特性，旨在提高程序的性能和资源管理效率。其核心概念在于允许对象间资源的转移，而非传统的拷贝操作。移动语义通过右值引用和移动构造函数（以及移动赋值运算符）实现了资源的所有权从一个对象到另一个对象的转移，从而避免了不必要的复制操作。</li>
<li>移动构造函数：接收一个右值引用参数，并将其资源“移动”到新的对象中，而不是复制这些资源。移动构造函数的定义形式为<code>ClassName(ClassName&amp;&amp; other);</code>。</li>
<li>移动赋值函数：用于将一个对象的资源转移给另一个已经存在的对象，其定义形式通常为<code>ClassName&amp; operator=(ClassName&amp;&amp; other);</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span>* data) : <span class="built_in">ptr</span>(data) &#123;&#125;  </span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">ptr</span>(other.ptr) &#123;  </span><br><span class="line">        other.ptr = <span class="literal">nullptr</span>; <span class="comment">// 确保原对象不再拥有资源  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;  </span><br><span class="line">            <span class="keyword">delete</span>[] ptr; <span class="comment">// 释放原资源  </span></span><br><span class="line">            ptr = other.ptr;  </span><br><span class="line">            other.ptr = <span class="literal">nullptr</span>; <span class="comment">// 确保原对象不再拥有资源  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; <span class="keyword">delete</span>[] ptr; &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span>* ptr;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function">MyClass <span class="title">createMyClass</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MyClass</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>]); <span class="comment">// 返回临时对象，将触发移动语义  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">MyClass obj = <span class="built_in">createMyClass</span>(); <span class="comment">// 这里将调用移动构造函数</span></span><br></pre></td></tr></table></figure>
<h6 id="统一的初始化："><strong>统一的初始化</strong>：</h6>
<p>C++11引入了统一的初始化语法（{}），使得所有类型的对象都可以使用相同的初始化方式。通过大括号<code>&#123;&#125;</code>和<code>std::initializer_list</code>提供了更加灵活、安全、直观的初始化方法。</p>
<ol>
<li>使用大括号<code>&#123;&#125;</code>直接初始化
<ul>
<li>对于基本数据类型：<code>int a&#123;10&#125;;</code></li>
<li>对于数组：<code>int arr[3]&#123;1, 2, 3&#125;;</code> 或者 <code>int arr[3] = &#123;1, 2, 3&#125;;</code>（注意，这里<code>=</code>并不是传统意义上的拷贝初始化，而是C++允许的一种简写形式，仍然属于统一初始化）</li>
<li>对于结构体和类对象：<code>struct Point&#123;int x, y;&#125; p&#123;1, 2&#125;;</code></li>
<li>对于容器：<code>std::vector&lt;int&gt; vec&#123;1, 2, 3&#125;;</code></li>
</ul>
</li>
<li>使用<code>std::initializer_list</code>
<ul>
<li>在C++11中，许多容器（如<code>std::vector</code>、<code>std::map</code>等）都增加了接受<code>std::initializer_list</code>作为参数的构造函数，使得容器初始化更加方便。</li>
<li><code>std::initializer_list</code>是一个轻量级的、可以容纳固定数量元素的容器，它在初始化时自动生成，并在初始化结束后销毁。</li>
</ul>
</li>
</ol>
<h6 id="Lambda表达式："><strong>Lambda表达式</strong>：</h6>
<p>提供了一种定义匿名函数对象的方式，使得编写回调函数等更加简洁方便。Lambda 表达式特别适用于需要函数对象但又不想正式命名一个函数的场景，比如作为算法（如 <code>std::sort</code>）的参数，或者在需要回调函数的地方。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture](parameters) <span class="keyword">mutable</span> -&gt; return_type &#123;  </span><br><span class="line">    <span class="comment">// 函数体  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>捕获列表</strong>（<code>[capture]</code>）：指定哪些外部变量在 lambda 表达式内部是可见的。如果省略捕获列表，则 lambda 表达式不能访问任何外部变量。捕获列表可以是值捕获（通过拷贝）或引用捕获（通过引用）。</li>
<li><strong>参数列表</strong>（<code>(parameters)</code>）：与普通函数的参数列表相同，定义了 lambda 表达式的参数。如果 lambda 表达式不接受任何参数，则可以省略参数列表。</li>
<li><strong>mutable</strong> 关键字（可选）：允许在 lambda 表达式体内修改被捕获的变量的值（如果它们是通过值捕获的）。默认情况下，这些变量在 lambda 表达式内是不可变的。</li>
<li><strong>返回类型</strong>（<code>-&gt; return_type</code>）：指定 lambda 表达式的返回类型。如果 lambda 表达式体只包含一个返回语句，并且编译器可以推导出返回类型，则可以省略返回类型。</li>
<li><strong>函数体</strong>：定义了 lambda 表达式的操作。</li>
<li>一个计算两数之和的简单例子：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 定义一个 lambda 表达式，计算两个整数的和  </span></span><br><span class="line">    <span class="keyword">auto</span> sum = [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使用 lambda 表达式  </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum is &quot;</span> &lt;&lt; <span class="built_in">sum</span>(a, b) &lt;&lt; std::endl;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使用 lambda 表达式作为 std::sort 的比较函数  </span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>&#125;;  </span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x &lt; y; &#125;);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : vec) &#123;  </span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    std::cout &lt;&lt; std::endl;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="标准库的扩展">标准库的扩展</h5>
<h6 id="智能指针："><strong>智能指针</strong>：</h6>
<p>C++11标准库增加了shared_ptr、unique_ptr和weak_ptr等智能指针，用于自动管理动态分配的内存，减少内存泄漏的风险。</p>
<ol>
<li>unique_ptr
<ul>
<li>独占式智能指针，确保只有一个指针可以指向资源。</li>
<li>通过<code>std::move()</code>函数可以转移资源的所有权。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">value_</span>(value) &#123;&#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value_ &lt;&lt; std::endl; &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> value_;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 创建一个 unique_ptr 指向 MyClass 的实例  </span></span><br><span class="line">    std::unique_ptr&lt;MyClass&gt; ptr = std::<span class="built_in">make_unique</span>&lt;MyClass&gt;(<span class="number">10</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使用 ptr  </span></span><br><span class="line">    ptr-&gt;<span class="built_in">print</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 当 ptr 离开作用域时，它指向的 MyClass 实例将被自动销毁  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>shared_ptr
<ul>
<li>共享式智能指针，允许多个指针共享同一个资源。</li>
<li>采用引用计数机制，当所有shared_ptr对象都不再需要该资源时，资源会自动被销毁。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Myclass同上</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 创建两个 shared_ptr 指向同一个 MyClass 实例  </span></span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(<span class="number">20</span>);  </span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; ptr2 = ptr1; <span class="comment">// ptr2 和 ptr1 共享所有权  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使用 ptr1 和 ptr2  </span></span><br><span class="line">    ptr1-&gt;<span class="built_in">print</span>();  </span><br><span class="line">    ptr2-&gt;<span class="built_in">print</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 当 ptr1 和 ptr2 都离开作用域时，MyClass 实例将被销毁  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>weak_ptr
<ul>
<li>弱引用智能指针，用于辅助shared_ptr工作，不增加资源的引用计数。</li>
<li>当所有的shared_ptr对象都不再需要该资源时，weak_ptr对象会自动失效。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Myclass同上</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 创建一个 shared_ptr 和一个 weak_ptr  </span></span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; ptr = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(<span class="number">30</span>);  </span><br><span class="line">    std::weak_ptr&lt;MyClass&gt; weakPtr = ptr;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使用 ptr  </span></span><br><span class="line">    ptr-&gt;<span class="built_in">print</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 尝试通过 weakPtr 访问资源，需要先锁定 weakPtr  </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> lockedPtr = weakPtr.<span class="built_in">lock</span>()) &#123;  </span><br><span class="line">        lockedPtr-&gt;<span class="built_in">print</span>();  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;weak_ptr is expired!&quot;</span> &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 当 ptr 离开作用域时，MyClass 实例将被销毁  </span></span><br><span class="line">    <span class="comment">// weakPtr 将自动变为过期状态  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="无序容器："><strong>无序容器</strong>：</h6>
<p>新增了unordered_map和unordered_set等基于哈希表的容器，提供了比原有map和set更高的查找效率。点击了解更多容器知识：<a href="https://blog.csdn.net/longer_net/article/details/140000701?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22140000701%22%2C%22source%22%3A%22longer_net%22%7D">STL标准模板库容器操作集合-CSDN博客</a></p>
<ol>
<li><strong><code>std::unordered_map</code></strong>：存储键值对，其中每个键都是唯一的。键和值可以是任何可复制且可赋值的类型。</li>
<li><strong><code>std::unordered_multimap</code></strong>：与<code>unordered_map</code>类似，但允许键重复。</li>
<li><strong><code>std::unordered_set</code></strong>：只存储键的集合，键是唯一的。</li>
<li><strong><code>std::unordered_multiset</code></strong>：与<code>unordered_set</code>类似，但允许键重复。</li>
</ol>
<h6 id="正则表达式："><strong>正则表达式</strong>：</h6>
<p>标准库增加了对正则表达式的支持，使得字符串处理更加灵活和强大。从C++11开始，C++标准库引入了<code>&lt;regex&gt;</code>头文件，提供了对正则表达式的支持。C++中的正则表达式类和相关函数主要包括：</p>
<ol>
<li><strong>std::regex</strong>：定义包含正则表达式的对象。</li>
<li><strong>std::smatch</strong>和<strong>std::cmatch</strong>：定义保存匹配结果的对象，分别用于string类型和char*类型的字符串。</li>
<li>常用正则匹配函数
<ul>
<li><strong>std::regex_match</strong>：判断整个目标字符串是否与正则表达式完全匹配。</li>
<li><strong>std::regex_search</strong>：在目标字符串中搜索与正则表达式匹配的第一个子字符串。</li>
<li><strong>std::regex_replace</strong>：用指定的字符串替换与正则表达式匹配的部分。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    std::string s = <span class="string">&quot;hello, world!&quot;</span>;  </span><br><span class="line">    <span class="function">std::regex <span class="title">e</span><span class="params">(<span class="string">&quot;\\bhello\\b&quot;</span>)</span></span>; <span class="comment">// 匹配单词&quot;hello&quot;  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(s, e)) &#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match found!&quot;</span> &lt;&lt; std::endl;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No match.&quot;</span> &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 替换匹配到的内容  </span></span><br><span class="line">    std::string replaced = std::<span class="built_in">regex_replace</span>(s, e, <span class="string">&quot;Hi&quot;</span>);  </span><br><span class="line">    std::cout &lt;&lt; replaced &lt;&lt; std::endl; <span class="comment">// 输出: &quot;Hi, world!&quot;  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="线程支持："><strong>线程支持</strong>：</h6>
<p>C++11首次在标准库中引入了线程支持，包括线程（std::thread）、互斥锁（std::mutex）、条件变量（std::condition_variable）等，使得C++能够更方便地进行多线程编程。以下是C++11中线程支持的主要特点：</p>
<ol>
<li>std::thread类
<ul>
<li><code>std::thread</code>是C++11中用于表示线程的类。通过创建<code>std::thread</code>的实例并传递给它一个可调用对象（如函数、lambda表达式、函数对象等），可以启动一个新的线程来执行该可调用对象。</li>
<li><code>std::thread</code>的构造函数有多种重载形式，允许传递不同数量和类型的参数给线程函数。</li>
</ul>
</li>
<li>线程控制
<ul>
<li><strong>join()</strong>：等待线程结束。调用线程（通常是主线程）会阻塞，直到被join的线程执行完毕。join操作是线程同步的一种方式。</li>
<li><strong>detach()</strong>：分离线程，使其独立于主线程运行。一旦线程被分离，就不能再对其执行join操作。分离后的线程在结束时会自动释放资源。</li>
<li><strong>joinable()</strong>：检查线程是否可以被join。如果线程已经被join或detach，或者线程对象从未与任何执行线程关联，则joinable()返回false。</li>
</ul>
</li>
<li>线程ID
<ul>
<li>每个<code>std::thread</code>对象都有一个唯一的标识符，可以通过调用<code>get_id()</code>成员函数来获取。这个ID可以用于区分不同的线程。</li>
</ul>
</li>
<li>线程互斥与同步
<ul>
<li>C++11还引入了<code>&lt;mutex&gt;</code>、<code>&lt;condition_variable&gt;</code>等头文件，提供了互斥锁、条件变量等同步机制，用于解决多线程中的数据竞争和同步问题。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line"> <span class="comment">//在这个示例中，我们创建了两个线程t1和t2，它们分别执行threadFunction函数，并传递不同的参数。然后，主线程通过调用join()函数等待这两个线程结束。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread: &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;, Count: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(threadFunction, <span class="number">1</span>)</span></span>;  </span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(threadFunction, <span class="number">2</span>)</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 等待两个线程结束  </span></span><br><span class="line">    t1.<span class="built_in">join</span>();  </span><br><span class="line">    t2.<span class="built_in">join</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="其他重要特性">其他重要特性</h5>
<h6 id="nullptr："><strong>nullptr</strong>：</h6>
<p>引入了nullptr作为空指针的字面量，替代了原来的NULL宏，提高了代码的安全性和可读性。</p>
<ul>
<li><code>nullptr</code> 是一个特殊的关键字，其类型是 <code>std::nullptr_t</code>。这个类型只能被隐式转换为指针类型，而不能被转换为整数类型，从而避免了类型不匹配的问题。</li>
<li>相比之下，<code>NULL</code> 通常被定义为 <code>0</code> 或 <code>((void*)0)</code>，可以隐式地转换为任何指针类型或整数类型，这可能导致意外的类型转换错误。</li>
</ul>
<h6 id="基于范围的for循环："><strong>基于范围的for循环</strong>：</h6>
<p>提供了一种更简洁的遍历容器或数组的方式，使得代码更加简洁易读。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression) &#123;  </span><br><span class="line">    <span class="comment">// 循环体  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>元素类型</strong>：在<code>declaration</code>中声明的类型应该与容器中元素的类型相匹配，或者至少是容器中元素类型的可隐式转换类型。</li>
<li><strong>修改元素</strong>：如果你需要在循环中修改元素的值，并且这个修改对容器是可见的，你应该使用元素的引用（通过<code>&amp;</code>）来声明变量。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span>&amp; num : nums) &#123;  </span><br><span class="line">    num *= <span class="number">2</span>; <span class="comment">// 将会修改容器中的元素  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使用基于范围的for循环遍历vector  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;  </span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="变长参数模板："><strong>变长参数模板</strong>：</h6>
<p>允许模板参数的数量在编译时确定，为泛型编程提供了更强大的能力。（没看懂，以后再说）</p>
<h6 id="constexpr："><strong>constexpr</strong>：</h6>
<p>允许在编译时计算表达式的值，并用于常量表达式的定义，提高了程序的运行效率。使用 <code>constexpr</code> 可以提高程序的性能，因为它允许编译器在编译时进行更多的优化，而不是在运行时计算表达式的值。</p>
<ul>
<li>变量：当用于变量时，<code>constexpr</code> 变量必须在声明时初始化，并且其值必须是编译时常量。这意味着它不能依赖于运行时才能确定的值，如用户输入或文件读取。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> max_value = <span class="number">100</span>; <span class="comment">// 正确：编译时常量  </span></span><br><span class="line"><span class="comment">// constexpr int x = get_value_from_user(); // 错误：不是编译时常量  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 可以在编译时计算  </span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> x * x;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> result = <span class="built_in">square</span>(<span class="number">5</span>); <span class="comment">// 正确：result 的值是 25，在编译时确定</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数：当用于函数时，<code>constexpr</code> 函数表示该函数可以在编译时求值，但并非所有 <code>constexpr</code> 函数都必须在编译时调用。如果一个 <code>constexpr</code> 函数在编译时没有被用于需要常量表达式的上下文中，它也可以像普通函数一样在运行时被调用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? <span class="number">1</span> : n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> value = <span class="built_in">factorial</span>(<span class="number">5</span>); <span class="comment">// 在编译时计算  </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Factorial of 5 is &quot;</span> &lt;&lt; <span class="built_in">factorial</span>(<span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">// 在运行时计算  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-与Java">C++与Java</h4>
<p>以下是对C++和Java更详细的比较，包括语法、跨平台性、性能、安全性以及各自的优势和应用场景等方面的详细分析：</p>
<h5 id="一、语法和风格">一、语法和风格</h5>
<p><strong>C++</strong></p>
<ul>
<li><strong>面向对象</strong>：C++是一种支持面向对象的编程语言，但它也支持面向过程和泛型编程。</li>
<li><strong>复杂性</strong>：C++的语法相对复杂，包含指针、手动内存管理、多重继承等特性，这使得它在学习和使用时需要更多的注意和技巧。</li>
<li><strong>灵活性</strong>：由于C++提供了对底层硬件的直接访问能力，它允许开发者编写高度优化的代码，但同时也需要开发者对内存和资源的管理有深入的理解。</li>
</ul>
<p><strong>Java</strong></p>
<ul>
<li><strong>面向对象</strong>：Java是一种纯面向对象的编程语言，所有的代码都封装在类中。</li>
<li><strong>简洁性</strong>：Java的语法比C++更简单、更直观，易于学习和使用。它自动管理内存，减少了内存泄漏和指针错误的风险。</li>
<li><strong>平台无关性</strong>：Java的“一次编写，到处运行”特性使得它可以在任何支持Java虚拟机（JVM）的平台上运行，无需修改代码。</li>
</ul>
<h5 id="二、跨平台性">二、跨平台性</h5>
<p><strong>C++</strong></p>
<ul>
<li><strong>跨平台编译</strong>：C++可以通过编写可移植的代码或使用跨平台库来实现跨平台编译和运行，但这需要开发者对不同的操作系统有一定的了解，并编写相应的适配代码。</li>
<li><strong>平台依赖</strong>：在某些情况下，C++程序可能依赖于特定的操作系统或硬件特性，这限制了其跨平台能力。</li>
</ul>
<p><strong>Java</strong></p>
<ul>
<li><strong>自动跨平台</strong>：Java通过字节码和Java虚拟机（JVM）实现了真正的跨平台能力。Java程序在任何安装了JVM的平台上都可以运行，无需任何修改。</li>
<li><strong>广泛支持</strong>：由于JVM的广泛部署和支持，Java程序几乎可以在所有主流操作系统上运行。</li>
</ul>
<h5 id="三、性能">三、性能</h5>
<p><strong>C++</strong></p>
<ul>
<li><strong>高性能</strong>：C++程序通常比Java程序具有更高的性能，因为它更接近底层硬件，且提供了更多的控制。</li>
<li><strong>编译型语言</strong>：C++是编译型语言，代码在编译时会被转换成机器码，这使得它可以在运行时直接执行，减少了运行时的开销。</li>
</ul>
<p><strong>Java</strong></p>
<ul>
<li><strong>优化性能</strong>：尽管Java在性能上不如C++，但通过即时编译器（JIT）和其他优化技术，Java程序的性能已经非常接近甚至在某些情况下超过C++。</li>
<li><strong>内存管理开销</strong>：Java的自动内存管理和垃圾回收机制虽然简化了编程过程，但也带来了一定的性能开销。</li>
</ul>
<h5 id="四、安全性">四、安全性</h5>
<p><strong>C++</strong></p>
<ul>
<li><strong>潜在风险</strong>：C++的复杂性使得它更容易出现安全问题，如缓冲区溢出、内存泄漏等。开发者需要更加小心地管理资源和避免常见的编程错误。</li>
<li><strong>直接硬件访问</strong>：C++的直接硬件访问能力在带来性能优势的同时，也增加了被恶意利用的风险。</li>
</ul>
<p><strong>Java</strong></p>
<ul>
<li><strong>较高安全性</strong>：Java通过其自动内存管理、强类型检查和运行时环境等特性提供了相对较高的安全性。</li>
<li><strong>沙箱模型</strong>：Java的沙箱模型限制了程序对系统资源的访问，进一步提高了安全性。</li>
</ul>
<h5 id="五、优势和应用场景">五、优势和应用场景</h5>
<p><strong>C++</strong></p>
<ul>
<li><strong>优势</strong>：高性能、直接硬件访问、丰富的库和生态系统、多范式编程支持。</li>
<li><strong>应用场景</strong>：系统级编程（如操作系统、驱动程序）、游戏开发、嵌入式系统、高频交易等。</li>
</ul>
<p><strong>Java</strong></p>
<ul>
<li><strong>优势</strong>：跨平台性、自动内存管理、丰富的类库和框架、强大的社区支持。</li>
<li><strong>应用场景</strong>：企业级应用（如ERP、CRM）、Web开发（如Servlet、JSP）、移动应用开发（如Android）、大数据处理（如Hadoop）等。</li>
</ul>
<h4 id="C-和Python">C++和Python</h4>
<p>C++和Python是两种非常流行的编程语言，它们各自具有独特的特性和优势，适用于不同的编程场景和需求。以下是对C++和Python的详细比较和归纳：</p>
<h5 id="C">C++</h5>
<h5 id="性能与效率"><strong>性能与效率</strong></h5>
<ul>
<li><strong>编译型语言</strong>：C++是一种编译型语言，其代码被编译成机器码后直接在计算机上执行，因此执行速度通常比解释型语言快。</li>
<li><strong>高效性</strong>：C++编译生成的机器码效率高，可以直接与硬件进行交互，适合在性能要求较高的应用中使用。</li>
</ul>
<h5 id="底层控制"><strong>底层控制</strong></h5>
<ul>
<li><strong>内存管理</strong>：C++允许程序员直接管理内存，包括分配和释放内存，这提供了更大的灵活性和性能优势，但也增加了内存泄漏和悬挂指针的风险。</li>
<li><strong>指针操作</strong>：C++支持指针操作，允许直接访问内存地址，这在系统编程和嵌入式系统开发中非常有用。</li>
</ul>
<h5 id="面向对象编程"><strong>面向对象编程</strong></h5>
<ul>
<li><strong>支持面向对象编程</strong>：C++支持面向对象编程，允许使用类和对象来组织代码，提高了代码的可重用性和可维护性。</li>
<li><strong>多范式编程</strong>：除了面向对象编程外，C++还支持泛型编程和函数式编程等不同的编程范式。</li>
</ul>
<h5 id="标准库与移植性"><strong>标准库与移植性</strong></h5>
<ul>
<li><strong>丰富的标准库</strong>：C++标准库提供了丰富的数据结构和算法，帮助开发者更容易地实现各种功能。</li>
<li><strong>良好的移植性</strong>：C++编写的程序可以在多个平台上编译和运行，具有很好的移植性。</li>
</ul>
<h5 id="复杂性与学习曲线"><strong>复杂性与学习曲线</strong></h5>
<ul>
<li><strong>相对复杂</strong>：C++的语法相对较为复杂，需要程序员更加关注内存管理和指针操作，因此学习曲线较陡。</li>
<li><strong>开发速度</strong>：由于需要手动管理内存和进行更多的底层操作，相比Python等高级语言，C++的开发速度通常较慢。</li>
</ul>
<h5 id="Python">Python</h5>
<h5 id="简洁易读"><strong>简洁易读</strong></h5>
<ul>
<li><strong>简洁的语法</strong>：Python以其简洁优美的语法而闻名，代码量通常更少，更易于阅读和理解。</li>
<li><strong>动态类型</strong>：Python是一种动态类型语言，在运行时可以根据赋值来自动推断变量的类型，增加了代码的灵活性。</li>
</ul>
<h5 id="高级特性"><strong>高级特性</strong></h5>
<ul>
<li><strong>自动内存管理</strong>：Python使用垃圾回收机制自动管理内存，开发者无需操心内存释放的问题，这使得Python编程更加安全和简单。</li>
<li><strong>支持多种编程范式</strong>：Python支持面向对象编程、函数式编程等高级特性，提供了更高的开发效率。</li>
</ul>
<h5 id="丰富的库与生态系统"><strong>丰富的库与生态系统</strong></h5>
<ul>
<li><strong>庞大的标准库和第三方库</strong>：Python拥有庞大且活跃的社区，提供了丰富的第三方库和工具，使得开发者能够快速解决各种问题。</li>
<li><strong>广泛的应用领域</strong>：Python广泛用于Web开发、数据分析、人工智能、科学计算等领域，是人工智能领域的主要编程语言之一。</li>
</ul>
<h5 id="开发速度与易用性"><strong>开发速度与易用性</strong></h5>
<ul>
<li><strong>易学易用</strong>：Python的语法简单清晰，易于学习和阅读，适合初学者入门编程。</li>
<li><strong>快速开发</strong>：Python的简洁性和丰富的库使得开发者能够快速编写和测试代码，提高开发效率。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++特性</tag>
      </tags>
  </entry>
  <entry>
    <title>C++编译和内存管理</title>
    <url>/2024/07/01/C-%E7%BC%96%E8%AF%91%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="C-编译和内存管理">C++编译和内存管理</h3>
<h4 id="内存管理">内存管理</h4>
<h5 id="ELF文件（可执行可链接文件）：">ELF文件（可执行可链接文件）：</h5>
<p>是Linux等类Unix操作系统中用于表示可执行文件、共享库、目标文件和核心转储文件的标准二进制文件格式。每个 ELFELF 文件都由一个 <code>ELF header</code> 和紧跟其后的文件数据部分组成。</p>
<h5 id="C-内存分区：">C++内存分区：</h5>
<p>C++内存分区在程序执行时，为了更有效地管理内存资源，通常将内存划分为不同的区域。</p>
<table>
<thead>
<tr>
<th>程序存储区</th>
<th>全局/静态存储</th>
<th>栈区</th>
<th>堆区</th>
<th>常量存储区</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统管理，运行期间不变</td>
<td>执行时已分配好，运行期间不变</td>
<td>编译器管理，分配和释放的效率很高</td>
<td>程序员管理，要自己要求和释放</td>
<td>存放常量，运行期间不变</td>
</tr>
</tbody>
</table>
<p>以下是C++内存分区的详细解释：</p>
<h6 id="程序存储区（程序代码区）">程序存储区（程序代码区）</h6>
<ul>
<li>功能：存放函数体的二进制代码，由操作系统进行管理。</li>
<li>特点：这部分内存主要存储了程序的指令和数据结构，它们在程序开始执行时就已经加载到内存中，并在程序运行期间保持不变</li>
</ul>
<h6 id="全局-静态存储区">全局/静态存储区</h6>
<ul>
<li>功能：存放全局变量和静态变量（包括全局静态变量和局部静态变量）。</li>
<li>特点：
<ul>
<li>在程序开始执行时，这部分内存就已经分配好了，并且它们的存储单元是固定的。</li>
<li>变量的生命周期与程序的运行时间相同，程序结束时才会释放这部分内存。</li>
<li>由于静态分配，其访问速度相对较快。</li>
</ul>
</li>
</ul>
<h6 id="栈区（Stack）">栈区（Stack）</h6>
<ul>
<li>功能：
<ul>
<li>由编译器自动分配和释放。</li>
<li>存放函数的参数值、局部变量等。</li>
</ul>
</li>
<li>特点：
<ul>
<li>栈区采用后进先出（LIFO）的管理方式。</li>
<li>分配和释放的效率非常高，因为栈内存分配运算内置于处理器的指令集中。</li>
<li>但栈区的空间大小是有限制的，过多的局部变量或递归调用可能导致栈溢出。</li>
</ul>
</li>
</ul>
<h6 id="堆区（Heap）">堆区（Heap）</h6>
<ul>
<li>功能：
<ul>
<li>由程序员分配和释放。</li>
<li>若程序员不释放，程序结束时由操作系统回收。</li>
</ul>
</li>
<li>特点：
<ul>
<li>堆区是动态内存分配的主要区域，程序员可以使用<code>new</code>和<code>delete</code>（或<code>new[]</code>和<code>delete[]</code>）来分配和释放内存。</li>
<li>堆区的空间大小相对较大，但在频繁地分配和释放内存时，可能会导致内存碎片。</li>
<li>使用堆区时要特别注意内存泄漏的问题，即分配的内存没有被正确释放。</li>
</ul>
</li>
</ul>
<h6 id="常量存储区">常量存储区</h6>
<ul>
<li>功能：存放常量字符串和其他常量值。</li>
<li>特点：
<ul>
<li>常量存储区中的值在程序运行期间不可修改。</li>
<li>常量字符串通常与其他只读数据一起存放在只读存储区，以防止程序意外修改它们。</li>
</ul>
</li>
</ul>
<h6 id="自由存储区">自由存储区</h6>
<ul>
<li>说明：自由存储区是一个相对抽象的概念，通常指的是通过<code>new</code>操作符分配的内存区域。虽然从技术上来说，这部分内存也属于堆区，但C++标准库允许程序员通过重载<code>new</code>和<code>delete</code>操作符来改变自由存储区的实现。</li>
</ul>
<h6 id="总结">总结</h6>
<p>C++内存分区是程序设计和内存管理的重要基础。了解不同内存分区的功能和特点有助于程序员更合理地使用和管理内存资源，从而提高程序的性能和稳定性。在编写C++程序时，应该尽量避免内存泄漏和栈溢出等问题，以确保程序的正确性和健壮性。</p>
<h4 id="堆和栈">堆和栈</h4>
<h5 id="栈">栈</h5>
<p>当我们讨论操作系统和内存管理时，我们更经常指的是进程或线程的调用栈（Call Stack）或执行栈（Execution Stack），这是一个由操作系统自动管理的内存区域。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动分配和释放</td>
<td>栈内存由系统自动分配和释放。当一个函数被调用时，它的参数和局部变量会在栈上被分配空间。当函数返回时，这些空间会被自动释放。</td>
</tr>
<tr>
<td>后进先出（LIFO）</td>
<td>栈遵循后进先出（Last In First Out）的原则。这意味着最后入栈的元素会最先出栈。</td>
</tr>
<tr>
<td>栈帧（Stack Frame）</td>
<td>每次函数调用时，都会在栈上分配一个栈帧（Stack Frame）。栈帧包含了函数的局部变量、参数、返回地址等信息。</td>
</tr>
<tr>
<td>栈溢出（Stack Overflow）</td>
<td>如果函数递归调用过深，或者局部变量占用了过多的栈空间，就可能导致栈溢出。栈溢出是一种严重的错误，通常会导致程序崩溃。</td>
</tr>
<tr>
<td>栈指针（Stack Pointer）</td>
<td>栈指针是一个指向栈顶的内存地址的指针。当数据入栈时，栈指针会向下移动（在大多数系统中，栈是向下增长的）；当数据出栈时，栈指针会向上移动。</td>
</tr>
<tr>
<td>局部变量和函数参数</td>
<td>在C++中，局部变量（包括自动存储期对象）和函数参数通常都存储在栈上。这意味着它们的生命周期与它们所在的函数或代码块相同。当函数返回或代码块结束时，这些变量就会被销毁。</td>
</tr>
<tr>
<td>返回地址</td>
<td>每次函数调用时，除了局部变量和参数外，还会在栈上保存一个返回地址。这个地址是函数执行完毕后应该跳转到的位置，通常是调用该函数之后的下一条指令。</td>
</tr>
</tbody>
</table>
<h5 id="堆">堆</h5>
<p>在C++中，堆（Heap）是一种重要的内存管理机制，它允许程序员在运行时动态地分配和释放内存。与栈（Stack）不同，堆内存是由程序员显式管理的，而不是由系统自动管理的。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>动态分配</td>
<td>堆内存允许程序在运行时根据需要动态地分配内存。这是通过使用诸如<code>new</code>和<code>delete</code>（在C++中）或<code>malloc</code>和<code>free</code>（在C中）等操作符或函数来实现的。</td>
</tr>
<tr>
<td>显示管理</td>
<td>与栈内存不同，程序员必须显式地管理堆内存。这意味着程序员需要负责在不再需要内存时释放它，以避免内存泄漏。</td>
</tr>
<tr>
<td>内存碎片</td>
<td>由于堆内存是动态分配的，因此可能会产生内存碎片。内存碎片是当小块内存被释放并留下未使用的空间时发生的，这些空间太小而无法容纳其他请求，但又无法合并成更大的连续块。</td>
</tr>
<tr>
<td>分配和释放时间</td>
<td>堆内存的分配和释放通常比栈内存慢，因为堆内存管理涉及到查找可用空间、跟踪分配和释放等复杂操作。</td>
</tr>
<tr>
<td>存储打对象或者长生命周期对象</td>
<td>由于堆内存是动态分配的，因此它通常用于存储大对象或具有长生命周期的对象。这些对象不适合在栈上分配，因为栈的大小通常是有限的。</td>
</tr>
<tr>
<td>异常安全性</td>
<td>在C++中，使用<code>new</code>操作符分配内存时，如果内存分配失败，会抛出<code>std::bad_alloc</code>异常。这使得堆内存分配具有更好的异常安全性，因为它允许程序员处理分配失败的情况。</td>
</tr>
<tr>
<td>智能指针</td>
<td>为了简化堆内存的管理，C++11引入了智能指针（如<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>）。智能指针能够自动管理堆内存的生命周期，减少内存泄漏的风险。</td>
</tr>
</tbody>
</table>
<h5 id="堆和栈的区别">堆和栈的区别</h5>
<p>简而言之，堆是程序员手动管理的动态内存区域，而栈是自动管理的静态内存区域。</p>
<h6 id="堆（Heap）">堆（Heap）</h6>
<ul>
<li>堆用于动态内存分配。程序员使用<code>new</code>或<code>malloc</code>等函数在堆上请求内存，并在不再需要时使用<code>delete</code>或<code>free</code>释放它。</li>
<li>堆内存的生命周期由程序员控制。</li>
<li>堆内存通常用于存储大型对象或对象数组。</li>
</ul>
<h6 id="栈（Stack）">栈（Stack）</h6>
<ul>
<li>栈是自动管理的内存区域，用于存储局部变量和函数调用的信息。</li>
<li>栈内存的生命周期与函数或代码块的执行周期相同。当函数返回时，栈上的内存会被自动释放。</li>
<li>栈内存通常用于存储小型对象和简单数据类型。</li>
</ul>
<h4 id="变量定义和生存周期">变量定义和生存周期</h4>
<h5 id="变量作用域">变量作用域</h5>
<p>在C++中，变量的作用域（Scope）指的是变量可以被访问的代码区域。这决定了变量的生命周期和可见性。C++中有几种不同的作用域：</p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>性质</th>
</tr>
</thead>
<tbody>
<tr>
<td>局部作用域（Local Scope）</td>
<td>局部作用域是在函数、代码块或循环内部定义的变量的作用域。这些变量在它们被声明的代码块内是可见的，一旦代码块结束，这些变量就会被销毁（对于非静态局部变量）。</td>
</tr>
<tr>
<td>全局作用域（Global Scope）</td>
<td>全局作用域是在所有函数外部定义的变量的作用域。这些变量在整个程序中都是可见的，从定义它们的文件开始到文件结束。如果它们被声明为<code>extern</code>，则可以在其他文件中通过包含适当的头文件来访问。</td>
</tr>
<tr>
<td>命名空间作用域（Namespace Scope）</td>
<td>命名空间作用域是在命名空间中定义的变量的作用域。命名空间用于将相关的标识符（如变量、函数、类等）组合在一起，以避免命名冲突。</td>
</tr>
<tr>
<td>类作用域（Class Scope）</td>
<td>类作用域是在类中定义的成员变量的作用域。这些变量是类的实例（对象）的一部分，并且只能通过类的对象或指针来访问。</td>
</tr>
</tbody>
</table>
<p>在下面这段代码中，我们定义了：</p>
<ul>
<li>一个全局变量 <code>globalVar</code>。</li>
<li>一个命名空间 <code>MyNamespace</code>，其中包含一个命名空间变量 <code>namespaceVar</code>。</li>
<li>一个类 <code>MyClass</code>，其中包含一个类成员变量 <code>classVar</code> 和一个成员函数 <code>printVar</code>。</li>
<li>一个函数 <code>foo</code>，其中包含一个局部变量 <code>localVar</code>，并访问了全局变量、命名空间变量和类实例的变量。</li>
<li>在 <code>main</code> 函数中，我们访问了全局变量、命名空间变量，并创建了一个 <code>MyClass</code> 的实例来访问其成员变量。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>    </span></span><br><span class="line"><span class="comment">// 全局作用域  </span></span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">100</span>;  </span><br><span class="line"><span class="comment">// 命名空间作用域  </span></span><br><span class="line"><span class="keyword">namespace</span> MyNamespace &#123;  </span><br><span class="line">    <span class="type">int</span> namespaceVar = <span class="number">200</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 类作用域  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="type">int</span> classVar = <span class="number">300</span>; <span class="comment">// 类成员变量（实例变量）  </span></span><br><span class="line">    <span class="comment">// 成员函数（也在类作用域内）  </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printVar</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;classVar: &quot;</span> &lt;&lt; classVar &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">// 函数作用域（包括局部作用域）  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">42</span>; <span class="comment">// 局部变量  </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;localVar: &quot;</span> &lt;&lt; localVar &lt;&lt; std::endl;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;globalVar: &quot;</span> &lt;&lt; globalVar &lt;&lt; std::endl;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MyNamespace::namespaceVar: &quot;</span> &lt;&lt; MyNamespace::namespaceVar &lt;&lt; std::endl;  </span><br><span class="line">    MyClass obj; <span class="comment">// 创建MyClass的实例  </span></span><br><span class="line">    obj.<span class="built_in">printVar</span>(); <span class="comment">// 调用成员函数打印classVar  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;globalVar: &quot;</span> &lt;&lt; globalVar &lt;&lt; std::endl;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MyNamespace::namespaceVar: &quot;</span> &lt;&lt; MyNamespace::namespaceVar &lt;&lt; std::endl;  </span><br><span class="line">    <span class="built_in">foo</span>(); <span class="comment">// 调用foo函数，该函数将打印其局部变量和全局/命名空间变量  </span></span><br><span class="line">    MyClass obj; <span class="comment">// 在main函数中创建MyClass的实例  </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj.classVar: &quot;</span> &lt;&lt; obj.classVar &lt;&lt; std::endl; <span class="comment">// 直接访问obj的classVar </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="变量生命周期">变量生命周期</h5>
<p>在C++中，变量的生命周期指的是变量从创建到销毁的时间段。这取决于变量在何处以及如何被声明。以下是C++中变量生命周期的几种主要情况：</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>局部变量（Local Variables）</td>
<td>局部变量在函数、代码块或循环内定义。它们的生命周期从定义点开始，到包含它们的代码块执行完毕时结束。一旦变量离开其作用域（即包含它的代码块），它就会被销毁，其占用的内存会被释放。</td>
</tr>
<tr>
<td>全局变量（Global Variables）</td>
<td>全局变量在函数外部定义，通常在所有函数外部的文件顶部。它们的生命周期是整个程序的执行期间，从程序开始执行到程序结束。</td>
</tr>
<tr>
<td>静态局部变量（Static Local Variables）</td>
<td>静态局部变量在函数内部定义，但它们的生命周期与全局变量类似。它们在第一次进入包含它们的函数时被初始化，并在程序执行期间一直存在，即使函数返回也不会被销毁。在下次函数调用时，静态局部变量的值保持不变。</td>
</tr>
<tr>
<td>动态分配的内存（Dynamically Allocated Memory）</td>
<td>使用<code>new</code>操作符在堆上动态分配的内存的生命周期是由程序员控制的。当使用<code>new</code>分配内存时，该内存会一直存在，直到显式地使用<code>delete</code>操作符释放它。忘记释放内存会导致内存泄漏。</td>
</tr>
<tr>
<td>类的成员变量（Class Member Variables）</td>
<td>类的成员变量（包括静态和非静态）的生命周期取决于类的实例（对象）的生命周期。非静态成员变量与对象一起创建和销毁，而静态成员变量在第一次创建类的对象时初始化，并在程序执行期间一直存在，即使所有对象都被销毁。</td>
</tr>
</tbody>
</table>
<p>在接下来这段代码中，我们有：</p>
<ul>
<li>一个全局变量<code>globalVar</code></li>
<li>一个类<code>MyClass</code>，它有一个非静态成员变量<code>instanceVar</code>和一个静态成员变量<code>staticVar</code>。</li>
<li>在<code>main</code>函数中，我们访问了全局变量并创建了一个<code>MyClass</code>的实例，然后通过这个实例访问了其成员变量。</li>
<li>我们还定义了一个函数<code>foo</code>，其中包含了静态局部变量<code>staticLocalVar</code>和局部变量<code>localVar</code>。</li>
<li>此外，我们还在<code>foo</code>函数中动态分配了一个整数，并在使用后立即释放了它。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="comment">// 全局变量  </span></span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">100</span>;  </span><br><span class="line"><span class="comment">// 类的声明  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="type">int</span> instanceVar; <span class="comment">// 类的非静态成员变量（实例变量）  </span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar; <span class="comment">// 类的静态成员变量  </span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">instanceVar</span>(value) &#123;&#125; <span class="comment">// 构造函数  </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printVars</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Instance variable: &quot;</span> &lt;&lt; instanceVar &lt;&lt; std::endl;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Static variable: &quot;</span> &lt;&lt; staticVar &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">// 类的静态成员变量的初始化  </span></span><br><span class="line"><span class="type">int</span> MyClass::staticVar = <span class="number">200</span>;  </span><br><span class="line"><span class="comment">// 函数定义  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 静态局部变量  </span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticLocalVar = <span class="number">0</span>;  </span><br><span class="line">    staticLocalVar++;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Static local variable: &quot;</span> &lt;&lt; staticLocalVar &lt;&lt; std::endl;  </span><br><span class="line">    <span class="comment">// 局部变量  </span></span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">42</span>;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Local variable: &quot;</span> &lt;&lt; localVar &lt;&lt; std::endl;  </span><br><span class="line">    <span class="comment">// 动态分配的内存  </span></span><br><span class="line">    <span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">84</span>);  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Dynamically allocated variable: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;  </span><br><span class="line">    <span class="keyword">delete</span> ptr; <span class="comment">// 释放内存  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 访问全局变量  </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Global variable: &quot;</span> &lt;&lt; globalVar &lt;&lt; std::endl;  </span><br><span class="line">    <span class="comment">// 创建MyClass的实例并访问其成员变量  </span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">300</span>)</span></span>;  </span><br><span class="line">    obj.<span class="built_in">printVars</span>();  </span><br><span class="line">    <span class="comment">// 调用foo函数，访问静态局部变量和局部变量  </span></span><br><span class="line">    <span class="built_in">foo</span>();  </span><br><span class="line">    <span class="comment">// 注意：在main函数结束时，全局变量和静态成员变量仍然存在，但局部变量（包括静态局部变量在foo函数外部）已经销毁  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内存对齐">内存对齐</h4>
<p>在C++中，内存对齐（Memory Alignment）是计算机内存访问性能优化的一种技术。当数据在内存中按照某种特定的规则对齐时，处理器可以更高效地访问这些数据。这是因为现代处理器在访问内存时，通常会一次性读取多个字节（比如4字节、8字节等），这种读取方式被称为“字”（word）或“双字”（doubleword）访问。如果数据没有正确对齐，那么处理器可能需要执行额外的操作来访问这些数据，这会降低访问速度。</p>
<h5 id="alignas关键字">alignas关键字</h5>
<p>在大多数情况下，最好让编译器自动处理内存对齐,你也可以使用特定的编译器指令或C++17引入的<code>alignas</code>关键字来指定对齐要求。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span>  </span></span><br><span class="line"><span class="comment">// 指定16字节对齐的结构体  </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">16</span>) AlignedStruct &#123;  </span><br><span class="line">    <span class="type">int32_t</span> a;  </span><br><span class="line">    <span class="type">double</span> b;  </span><br><span class="line">    <span class="comment">// ... 可能还有其他成员 ...  </span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    AlignedStruct s;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Alignment of s: &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(s) &lt;&lt; <span class="string">&quot; bytes\n&quot;</span>;  </span><br><span class="line">    <span class="comment">// 输出应该是 16 bytes（取决于平台和编译器）  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="智能指针">智能指针</h4>
<p>C++中的智能指针是一种特殊的指针，它们可以自动管理动态分配的内存的生命周期，从而避免内存泄漏和其他与内存管理相关的问题。C++11标准引入了三种主要的智能指针：<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>。需要注意的是，智能指针不能像普通指针那样支持加减运算。</p>
<table>
<thead>
<tr>
<th>指针</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>unique_ptr</td>
<td><code>unique_ptr</code> 独占其指向的对象。这意味着两个 <code>unique_ptr</code> 不能指向同一个对象。 当 <code>unique_ptr</code> 被销毁（例如，离开其作用域）时，它所指向的对象也会被自动删除。 <code>unique_ptr</code> 提供了对原始指针的独占所有权语义。</td>
</tr>
<tr>
<td>shared_ptr</td>
<td><code>shared_ptr</code> 实现共享所有权的语义。多个 <code>shared_ptr</code> 可以指向同一个对象，并且当最后一个拥有该对象的 <code>shared_ptr</code> 被销毁时，对象才会被删除。 <code>shared_ptr</code> 使用引用计数来跟踪有多少 <code>shared_ptr</code> 指向一个对象。当计数变为0时，对象会被删除。</td>
</tr>
<tr>
<td>weak_ptr</td>
<td><code>weak_ptr</code> 是对 <code>shared_ptr</code> 所管理对象的一个弱引用，它不会增加对象的引用计数。 <code>weak_ptr</code> 主要用于解决 <code>shared_ptr</code> 之间的循环引用问题。 <code>weak_ptr</code> 可以安全地用于检查一个对象是否仍然存在，并且可以通过它获取到 <code>shared_ptr</code>（如果对象仍然存在的话）。##### 指针建立</td>
</tr>
</tbody>
</table>
<h5 id="指针建立">指针建立</h5>
<ul>
<li>优先选用 <code>std::make_unique</code> 和 <code>std::make_shared</code>,而非直接 <code>new</code>。</li>
<li>make_unique：减少代码量，能够加快编译速度，定义两遍类型时，编译器需要进行类型推导会降低编译速度，某些意外意外情况下可能会导致内存泄漏。</li>
<li><code>make_shared</code>：这个主要是可以减少对堆中申请内存的次数，只需要申请一次即可，<code>make_share</code> 虽然效率高，但是同样不能自定义析构器。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; ptr=std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>);  </span><br><span class="line"><span class="comment">// ... 使用 ptr  </span></span><br><span class="line"><span class="comment">// 当 ptr 离开作用域时，它指向的 int 会被自动删除</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>);  </span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1;  <span class="comment">// ptr1 和 ptr2 现在共享同一个 int  </span></span><br><span class="line"><span class="comment">// ... 使用 ptr1 和 ptr2  </span></span><br><span class="line"><span class="comment">// 当 ptr1 和 ptr2 都离开作用域时，它们共享的 int 才会被删除</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; shared = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>);  </span><br><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; weak = shared;   </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> strong = weak.<span class="built_in">lock</span>()) &#123;  </span><br><span class="line">    <span class="comment">// strong 是一个有效的 shared_ptr，我们可以使用它  </span></span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">// 原始对象可能已经被删除了  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="代码示例">代码示例</h5>
<p>这段代码将会展示如何使用<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>来管理<code>MyClass</code>对象的生命周期。你可以看到，当智能指针离开其作用域时，它们会自动删除所指向的对象（除非有其他的<code>shared_ptr</code>仍然指向该对象）。<code>std::weak_ptr</code>用于避免循环引用问题，并允许你检查原始对象是否仍然存在。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  </span></span><br><span class="line"><span class="comment">// 一个简单的类  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">value_</span>(value) &#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass(&quot;</span> &lt;&lt; value_ &lt;&lt; <span class="string">&quot;) created.\n&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass(&quot;</span> &lt;&lt; value_ &lt;&lt; <span class="string">&quot;) destroyed.\n&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value_ &lt;&lt; <span class="string">&quot;\n&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> value_;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 使用std::unique_ptr  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="function">std::unique_ptr&lt;MyClass&gt; <span class="title">uniquePtr</span><span class="params">(<span class="keyword">new</span> MyClass(<span class="number">10</span>))</span></span>;  </span><br><span class="line">        uniquePtr-&gt;<span class="built_in">printValue</span>();  </span><br><span class="line">        <span class="comment">// 当uniquePtr离开作用域时，它指向的对象会被自动删除  </span></span><br><span class="line">    &#125; <span class="comment">// 这里MyClass(10)对象会被销毁  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使用std::shared_ptr  </span></span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; sharedPtr1 = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(<span class="number">20</span>);  </span><br><span class="line">    sharedPtr1-&gt;<span class="built_in">printValue</span>();  </span><br><span class="line">    &#123;  </span><br><span class="line">        std::shared_ptr&lt;MyClass&gt; sharedPtr2 = sharedPtr1; <span class="comment">// sharedPtr1和sharedPtr2现在共享同一个对象  </span></span><br><span class="line">        sharedPtr2-&gt;<span class="built_in">printValue</span>();  </span><br><span class="line">        <span class="comment">// 当sharedPtr2离开作用域时，它指向的对象不会被删除，因为sharedPtr1仍然指向它  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 当sharedPtr1离开作用域时，如果这是最后一个shared_ptr指向该对象，则对象会被删除  </span></span><br><span class="line">    <span class="comment">// 这里MyClass(20)对象会被销毁  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 尝试使用std::weak_ptr  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        std::shared_ptr&lt;MyClass&gt; sharedPtr3 = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(<span class="number">30</span>);  </span><br><span class="line">        std::weak_ptr&lt;MyClass&gt; weakPtr = sharedPtr3;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> shared = weakPtr.<span class="built_in">lock</span>()) &#123; <span class="comment">// 尝试获取shared_ptr  </span></span><br><span class="line">            shared-&gt;<span class="built_in">printValue</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 当sharedPtr3离开作用域时，它指向的对象会被删除  </span></span><br><span class="line">        <span class="comment">// 因为weakPtr只是一个弱引用，所以它不会影响对象的生命周期  </span></span><br><span class="line">    &#125; <span class="comment">// 这里MyClass(30)对象会被销毁  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译和链接">编译和链接</h4>
<p>在C++中，编译和链接是两个不同的步骤，尽管它们通常在一个命令中一起执行。可以分为四个阶段：</p>
<ul>
<li>预处理（Preprocessing）</li>
<li>编译（Compilation）</li>
<li>汇编（Assembly）</li>
<li>链接（Linking）</li>
</ul>
<h5 id="预处理">预处理</h5>
<ul>
<li>替换所有的宏定义（<code>#define</code>）。</li>
<li>插入包含的头文件内容（<code>#include</code>）。</li>
<li>删除注释。</li>
<li>添加行号和文件名信息（用于调试）。</li>
</ul>
<h5 id="编译">编译</h5>
<ul>
<li>检查代码中的语法错误。</li>
<li>将代码转换为更低级别的表示形式（通常称为“汇编代码”）。</li>
<li>简单来说编译的过程即为将 <code>.cpp</code> 源文件翻译成 <code>.s</code> 的汇编代码</li>
</ul>
<h5 id="汇编">汇编</h5>
<ul>
<li>将编译步骤中生成的汇编代码转换为机器码，这是计算机可以直接执行的指令。</li>
<li>将汇编代码 <code>.s</code> 翻译成机器指令 <code>.o</code> 文件，一个 <code>.cpp</code> 文件只会生成一个 <code>.o</code> 文件</li>
</ul>
<h5 id="链接">链接</h5>
<ul>
<li>合并程序中所有单独编译的部分（多个<code>.o</code>文件链接到一起）。</li>
<li>解决程序中引用的外部函数或变量（例如库函数）的地址。</li>
<li>生成一个可执行文件（例如<code>.exe</code>文件在Windows上），这个文件可以被计算机直接执行。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -c main.cpp -o main.o  #生成main.o文件，-c表示只进行编译步骤，并生成目标代码文件</span><br><span class="line">g++ -c utility.cpp -o utility.o#生成utility.o文件，如果使用外部库，要加-l +库名或-L +库路径</span><br><span class="line">g++ main.o utility.o -o my_program#链接成my_program可执行文件</span><br></pre></td></tr></table></figure>
<h6 id="静态链接与动态链接">静态链接与动态链接</h6>
<p>静态链接和动态链接是程序编译和链接过程中的两种不同方式，它们在程序运行时对外部库文件的依赖和处理方式上有所不同。静态链接和动态链接各有优缺点，具体选择哪种方式取决于实际需求和应用场景。</p>
<ul>
<li>如果对程序的独立性和安全性要求较高，可以选择静态链接</li>
<li>如果对程序的体积和升级方便性要求较高，可以选择动态链接。</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>静态链接</th>
<th>动态链接</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>定义</strong></td>
<td>编译时将外部库直接嵌入到可执行文件中</td>
<td>编译时只生成可执行文件和必要的资源文件，运行时加载外部库</td>
</tr>
<tr>
<td><strong>完整性</strong></td>
<td>包含所有代码和数据，无需额外加载</td>
<td>依赖外部库文件，运行时加载</td>
</tr>
<tr>
<td><strong>稳定性</strong></td>
<td>运行时库不会被卸载或替换，稳定性高</td>
<td>运行时库可以被卸载或替换，可能影响稳定性</td>
</tr>
<tr>
<td><strong>独立性</strong></td>
<td>与目标程序依赖性强，修改库需重新编译程序</td>
<td>与目标程序依赖性弱，修改库无需重新编译程序</td>
</tr>
<tr>
<td><strong>体积</strong></td>
<td>体积较大，包含所有代码和数据</td>
<td>体积较小，多个程序可共享同一个库</td>
</tr>
<tr>
<td><strong>资源占用</strong></td>
<td>磁盘和内存占用较大</td>
<td>磁盘和内存占用较小</td>
</tr>
<tr>
<td><strong>升级和维护</strong></td>
<td>升级或维护需要替换所有相关库并重新编译程序</td>
<td>升级或维护库时，无需重新编译程序，只需替换库文件</td>
</tr>
<tr>
<td><strong>兼容性</strong></td>
<td>不易出现兼容性问题，因为所有代码和数据都在一起</td>
<td>可能出现兼容性问题，特别是当多个程序共享同一个库时</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>安全性较高，因为不依赖于外部文件</td>
<td>安全性较低，可能受到外部文件的影响</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>对独立性和安全性要求较高的程序</td>
<td>对体积和升级方便性要求较高的程序</td>
</tr>
</tbody>
</table>
<h4 id="大端小端">大端小端</h4>
<h5 id="字节序">字节序</h5>
<p>字节序是指多字节数据在计算机内存中存储或者网络传输时各字节的存储顺序。具体来说，它决定了在一个多字节的数据项中，字节的哪一端存储在该数据项的起始地址处。</p>
<h5 id="大端-Big-Endian">大端(Big-Endian)</h5>
<p>高位字节在前，低位字节在后。即数据的高位字节存放在内存的低地址处，而数据的低位字节存放在内存的高地址处。例如，一个32位整数<code>0x12345678</code>在大端序系统中会被存储为<code>12 34 56 78</code>（十六进制表示）。</p>
<h5 id="小端-Little-Endian">小端(Little-Endian)</h5>
<p>低位字节在前，高位字节在后。与大端序相反，数据的低位字节存放在内存的低地址处，而数据的高位字节存放在内存的高地址处。同样以32位整数<code>0x12345678</code>为例，在小端序系统中它会被存储为<code>78 56 34 12</code>。</p>
<h5 id="影响">影响</h5>
<p>在网络编程中，网络字节序通常指的是大端序（Big-Endian）。因此，当数据需要在网络上进行传输时，如果主机字节序是小端序（Little-Endian），则需要在发送前将数据从主机字节序转换为网络字节序，接收端在接收到数据后也需要进行相应的转换。</p>
<h4 id="内存泄漏">内存泄漏</h4>
<p>内存泄漏（Memory Leak）是指程序在运行过程中，未能正确释放已经不再需要使用的内存空间，导致系统中的可用内存逐渐减少，直至耗尽所有可用内存并可能引发系统崩溃的严重问题。常见：</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义</td>
<td>程序在运行过程中未能正确释放不再使用的内存空间，导致系统可用内存减少，可能引发系统崩溃。</td>
</tr>
<tr>
<td>原因</td>
<td>程序员忘记释放内存、异常处理不当、循环引用、资源未关闭等。</td>
</tr>
<tr>
<td>类型</td>
<td>常发性、偶发性、一次性、隐式内存泄漏。</td>
</tr>
<tr>
<td>影响</td>
<td>系统性能下降、内存占用持续增加、可能导致系统崩溃。</td>
</tr>
<tr>
<td>解决办法</td>
<td>及时释放内存、正确处理异常、解除循环引用、正确关闭资源、使用检测工具、养成良好编程习惯。</td>
</tr>
<tr>
<td>重要性</td>
<td>内存泄漏是严重的编程错误，需要特别注意预防和修复。</td>
</tr>
</tbody>
</table>
<p>内存泄漏缺陷具有隐蔽性、积累性的特征，比其他内存非法访问错误更难检测。因此，程序员需要特别注意在编写代码时避免内存泄漏的发生，并定期检查代码以发现和修复可能存在的内存泄漏问题。</p>
<h4 id="include-与">#include&quot; &quot;与&lt; &gt;</h4>
<p>以下是一个表格，展示了 <code>#include</code> 指令中使用尖括号 <code>&lt; &gt;</code> 和双引号 <code>&quot;&quot;</code> 的区别：</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>尖括号 <code>&lt; &gt;</code></th>
<th>双引号 <code>&quot;&quot;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>用途</strong></td>
<td>通常用于包含编译器提供的标准库头文件</td>
<td>通常用于包含项目中的自定义头文件</td>
</tr>
<tr>
<td><strong>搜索路径</strong></td>
<td>编译器会在其标准库路径中查找文件</td>
<td>编译器首先在当前源文件所在的目录中查找文件，如果找不到，则会查找编译器设置的其他路径</td>
</tr>
<tr>
<td><strong>处理自定义头文件</strong></td>
<td>如果尝试使用尖括号来包含自定义头文件，并且该文件不在标准库路径中，编译器通常会报错</td>
<td>使用双引号可以包含当前目录或编译器设置的其他路径中的自定义头文件</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td><code>&lt;iostream&gt;</code>、<code>&lt;stdio.h&gt;</code></td>
<td><code>&quot;myheader.h&quot;</code>（假设 <code>myheader.h</code> 在当前目录或编译器设置的其他路径中）</td>
</tr>
<tr>
<td><strong>注意事项</strong></td>
<td>编译器可能会根据设置来改变默认行为</td>
<td>编译器可能会根据设置来改变默认行为，但通常优先查找当前目录</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编译和内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象的特性</title>
    <url>/2024/07/03/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h4 id="面向对象">面向对象</h4>
<p>面向对象（Object-Oriented, 简称OO）是一种编程范式或编程风格，它使用“对象”来设计软件。面向对象的思想将现实世界中的事物（称为“对象”）映射到软件系统中，使得软件的设计更加符合人类的思维方式，提高了软件的可重用性、可维护性和可扩展性。</p>
<p>面向对象编程（Object-Oriented Programming, 简称OOP）是这种思想的具体实现方式。</p>
<h4 id="三大特性">三大特性</h4>
<p>面向对象三大特性：封装（Encapsulation）、继承（Inheritance）和多态（Polymorphism）。</p>
<h5 id="封装"><strong>封装</strong></h5>
<ul>
<li>作用：封装是面向对象编程的核心思想之一。它通过将对象的属性和方法结合在一个单独的单元中，并对对象内部的细节进行隐藏，只对外提供有限的接口（方法）来与对象进行交互。这样做的好处是提高了数据的安全性，防止外部代码直接访问或修改对象的内部状态，同时也降低了系统的耦合度，使得各个部分更加独立和易于维护。</li>
</ul>
<h5 id="继承"><strong>继承</strong></h5>
<ul>
<li>作用：继承是面向对象编程中实现代码复用的一种机制。它允许我们定义一个类（子类）来继承另一个类（父类）的属性和方法。子类可以继承父类的所有非私有属性和方法，并且可以添加新的属性和方法或覆盖（重写）父类的方法。继承提高了代码的重用性，使得我们不需要从头开始编写代码，而是可以在现有代码的基础上进行扩展和定制。</li>
</ul>
<h5 id="多态"><strong>多态</strong></h5>
<ul>
<li>作用：多态性是面向对象编程中一个非常重要的概念，它允许我们以统一的接口去调用不同的实现，从而提高代码的灵活性和可扩展性。多态性主要分为编译时多态（方法重载）和运行时多态（动态绑定或方法重写）。通过多态，我们可以在不知道对象具体类型的情况下，调用对象的方法，而方法的实际执行将取决于对象的类型。</li>
</ul>
<h4 id="重载、重写和隐藏">重载、重写和隐藏</h4>
<ul>
<li><strong>重载</strong>：是同一类中方法的多态性表现，通过不同的参数列表来区分不同的方法。</li>
<li><strong>重写</strong>：是子类对父类方法的重新实现，发生在具有继承关系的类之间，且必须保持方法签名的一致性。即方法名称、参数列表和返回类型必须与被重写的方法完全相同</li>
<li><strong>隐藏</strong>：是派生类函数对基类同名函数的屏蔽，无论参数列表是否相同，都会导致基类函数被隐藏。</li>
</ul>
<h4 id="多态-2">多态</h4>
<p>多态允许我们将父类类型的指针或引用指向子类对象，并通过该指针或引用来调用成员函数，而具体调用的是哪个类的成员函数，则在运行时决定，这增加了程序的灵活性和可扩展性。</p>
<p>示例函数：一个C++中多态性的示例，通过虚函数来实现。在这个例子中，我们创建一个基类<code>Animal</code>，它有一个虚函数<code>makeSound()</code>。然后，我们将创建两个派生类<code>Dog</code>和<code>Cat</code>，它们分别重写（Override）了<code>makeSound()</code>函数来提供各自的实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Some generic animal sound\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 虚析构函数，确保通过基类指针删除派生类对象时能够正确调用派生类的析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Dog</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重写虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// C++11及以后版本推荐使用override关键字</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Woof!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Cat</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重写虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Meow!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用多态性的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeItSound</span><span class="params">(Animal* animal)</span> </span>&#123;</span><br><span class="line">    animal-&gt;<span class="built_in">makeSound</span>(); <span class="comment">// 运行时根据animal指向的实际对象类型调用相应的makeSound()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal* myAnimal = <span class="keyword">new</span> <span class="built_in">Dog</span>(); <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">    <span class="built_in">makeItSound</span>(myAnimal); <span class="comment">// 输出: Woof!</span></span><br><span class="line">    <span class="keyword">delete</span> myAnimal; <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    myAnimal = <span class="keyword">new</span> <span class="built_in">Cat</span>(); <span class="comment">// 现在基类指针指向另一个派生类对象</span></span><br><span class="line">    <span class="built_in">makeItSound</span>(myAnimal); <span class="comment">// 输出: Meow!</span></span><br><span class="line">    <span class="keyword">delete</span> myAnimal; <span class="comment">// 再次释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该例中，<code>makeItSound</code>函数接受一个指向<code>Animal</code>类型的指针。由于<code>makeSound</code>是一个虚函数，因此当<code>makeItSound</code>被调用时，实际调用的是指针所指向对象的<code>makeSound</code>函数版本，这取决于指针在运行时指向的具体对象类型（即<code>Dog</code>或<code>Cat</code>）。</p>
<h4 id="虚函数、纯虚函数">虚函数、纯虚函数</h4>
<p>在C++中，虚函数和纯虚函数允许派生类重写基类的成员函数，以实现不同的行为。</p>
<h5 id="虚函数">虚函数</h5>
<ul>
<li><strong>定义</strong>：在基类中，使用<code>virtual</code>关键字声明的成员函数称为虚函数。虚函数允许在派生类中被重写（Override），以提供特定于派生类的实现。</li>
<li><strong>用途</strong>：虚函数用于实现多态性，允许基类指针或引用指向派生类对象，并通过该指针或引用来调用成员函数，而具体调用哪个函数则在运行时决定。</li>
</ul>
<h5 id="纯虚函数">纯虚函数</h5>
<ul>
<li><strong>定义</strong>：在基类中，使用<code>virtual</code>关键字和<code>= 0</code>语法声明的成员函数称为纯虚函数。纯虚函数没有实现（即没有函数体），它要求派生类必须提供该函数的实现。</li>
<li><strong>用途</strong>：纯虚函数用于定义接口，<strong>强制</strong>派生类实现特定的成员函数。它允许基类定义一组操作，但不提供这些操作的具体实现，而是由派生类来提供。</li>
</ul>
<h3 id="示例">示例</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base show&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pureVirtualFunction</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重写虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived show&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须实现纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pureVirtualFunction</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived pureVirtualFunction&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>(); <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">    basePtr-&gt;<span class="built_in">show</span>(); <span class="comment">// 调用Derived的show()</span></span><br><span class="line">    basePtr-&gt;<span class="built_in">pureVirtualFunction</span>(); <span class="comment">// 调用Derived的pureVirtualFunction()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> basePtr; <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="虚函数的实现机制">虚函数的实现机制</h4>
<p>虚函数在C++中的实现机制主要涉及虚函数表和虚指针（vptr）的使用，以及编译器如何通过这些机制在运行时确定应该调用哪个函数。</p>
<h5 id="虚函数表">虚函数表</h5>
<ul>
<li><strong>创建</strong>：编译器为每个包含虚函数的类创建一个虚函数表。虚函数表中的元素是指向类中所有虚函数地址的指针，按照虚函数在类中声明的顺序排列。</li>
<li><strong>内容</strong>：虚函数表中存储的是虚函数的地址，这些地址指向类中定义的虚函数实现。</li>
<li><strong>继承</strong>：当子类继承基类时，如果子类重写了基类的虚函数，则子类的虚函数表中相应位置的指针将指向子类重写的函数地址；如果子类没有重写基类的某个虚函数，则该位置的指针仍指向基类中的函数地址。</li>
</ul>
<h5 id="虚指针">虚指针</h5>
<ul>
<li><strong>定义</strong>：编译器为每个包含虚函数的类对象添加一个隐藏的虚指针（vptr），该指针指向对象所属类的虚函数表。</li>
<li><strong>位置</strong>：虚指针通常作为类对象的第一个成员变量（但C++标准没有明确要求这一点，实际位置由编译器决定）。</li>
<li><strong>作用</strong>：在调用虚函数时，通过对象的虚指针找到其所属类的虚函数表，再根据虚函数表找到并调用相应的虚函数实现。</li>
</ul>
<h5 id="动态联编（Dynamic-Binding）">动态联编（Dynamic Binding）</h5>
<ul>
<li><strong>过程</strong>：当通过基类指针或引用来调用虚函数时，编译器会在运行时通过虚指针和虚函数表来确定应该调用哪个类的虚函数实现。这种机制称为动态联编或晚期绑定。</li>
<li><strong>对比</strong>：与静态联编（在编译时确定函数调用）不同，动态联编允许在运行时根据对象的实际类型来确定函数调用，从而实现了多态性。</li>
</ul>
<h5 id="虚函数表的访问">虚函数表的访问</h5>
<ul>
<li><strong>方式</strong>：当执行虚函数调用时，编译器首先检查调用指针或引用的类型，如果指向的类中有虚函数表，则通过虚指针找到虚函数表，然后在表中根据函数声明的位置索引找到相应的函数指针，并调用该函数。</li>
<li><strong>示例</strong>：假设有基类<code>Base</code>和派生类<code>Derived</code>，<code>Base</code>中定义了一个虚函数<code>show()</code>。当通过基类指针<code>Base* ptr = new Derived(); ptr-&gt;show();</code>调用<code>show()</code>时，编译器会首先找到<code>ptr</code>指向对象的虚函数表，然后在表中找到<code>show()</code>函数的地址，并调用<code>Derived</code>类中重写的<code>show()</code>函数（如果<code>Derived</code>类重写了<code>show()</code>）。</li>
</ul>
<h4 id="构造、析构函数的虚化">构造、析构函数的虚化</h4>
<p>构造函数不能定义为虚函数，而析构函数可以定义为虚函数。</p>
<ul>
<li><strong>初始化的需要</strong>：构造函数的主要目的是初始化对象。在面向对象编程中，对象的初始化通常与其确切类型紧密相关，因此不需要多态性来决定使用哪个构造函数。</li>
<li><strong>资源释放需求</strong>：在析构函数中，通常会释放对象占用的资源（如动态分配的内存、文件句柄等）。如果析构函数不是虚函数，那么派生类特有的资源可能无法被正确释放。</li>
</ul>
<h4 id="多继承的问题">多继承的问题</h4>
<p>多继承在C++中是一种常见的代码复用机制，在JAVA等语言中不支持。容易出现命名冲突、二义性和菱形继承等问题</p>
<ul>
<li>
<p><strong>命名冲突</strong>：当多个父类中存在相同名称的属性和方法时，子类在调用这些成员时会产生二义性，编译器无法确定使用哪个父类的成员。</p>
</li>
<li>
<p><strong>二义性</strong>：类似于命名冲突，但更侧重于成员函数。如果多个父类中都实现了同一个成员函数，并且子类没有覆盖该成员函数，那么在使用该成员函数时会产生二义性，编译器无法确定调用哪个父类的成员函数。</p>
</li>
<li>
<p><strong>菱形继承（钻石继承）</strong>：一个类同时继承了两个不相关的父类，并且这两个父类又继承了同一个父类，从而形成一个菱形的继承关系。这会导致基类成员在派生类中有多个拷贝，造成内存浪费和数据冗余，并且可能引发二义性问题。</p>
</li>
</ul>
<h4 id="深拷贝和浅拷贝">深拷贝和浅拷贝</h4>
<p>深拷贝（Deep Copy）和浅拷贝（Shallow Copy）是在进行对象或数据结构复制时常用的两种方式，它们之间的主要区别在于复制的程度以及对原始对象内部结构的影响。</p>
<h5 id="浅拷贝：">浅拷贝：</h5>
<ul>
<li>浅拷贝是指创建一个新的对象，但只复制原始对象的基本数据类型的字段或引用（地址），而不复制引用指向的对象。</li>
<li>这意味着新对象和原始对象中的引用指向相同的对象。如果原始对象中的字段是基本数据类型，那么这些字段会被复制到新对象中；而如果字段是引用类型，则新对象和原始对象的对应字段将引用同一个对象。</li>
<li>因此，对新对象所做的修改可能会影响到原始对象，因为它们共享相同的引用。</li>
</ul>
<h5 id="深拷贝：">深拷贝：</h5>
<ul>
<li>深拷贝是指创建一个新的对象，并且递归地复制原始对象的所有字段和引用指向的对象，而不仅仅是复制引用本身。</li>
<li>深拷贝会递归复制整个对象结构，包括对象内部的对象，确保新对象和原始对象之间的所有关系都是独立的。</li>
<li>这意味着对新对象所做的修改不会影响到原始对象，因为它们拥有彼此独立的副本。</li>
</ul>
<h5 id="具体区别：">具体区别：</h5>
<ul>
<li>浅拷贝：简单地把指向别人的值的一个指针给复制过来，新对象和原始对象共享某些引用类型的数据。</li>
<li>深拷贝：实实在在地把别人的值给复制过来，新对象和原始对象在内存中是完全独立的。</li>
</ul>
<h5 id="实现方式">实现方式</h5>
<ul>
<li>浅拷贝：可以使用一些内置方法如列表的 <code>.copy()</code> 方法、<code>list()</code> 函数，或使用 <code>copy</code> 模块的 <code>copy()</code> 函数。</li>
<li>深拷贝：通常使用 <code>copy</code> 模块的 <code>deepcopy()</code> 函数。</li>
</ul>
<h4 id="默认构造函数">默认构造函数</h4>
<p>在C++中，默认构造函数（Default Constructor）是一种特殊的构造函数，它在没有显式提供任何参数的情况下被调用以创建类的对象。默认构造函数可以是用户定义的，也可以是编译器自动生成的。</p>
<ul>
<li>**编译器默认构造函数：**如果类中没有定义任何构造函数（无论是默认构造函数还是带参数的构造函数），编译器会隐式地生成一个默认构造函数。这个构造函数是公有的，并且不接受任何参数。</li>
<li>**用户定义默认构造函数：**用户可以通过不接受任何参数或所有参数都有默认值的构造函数来显式地定义一个默认构造函数。但是，C++11及更高版本提供了一种更直接的方式来声明默认构造函数，即使它带有参数列表（尽管这些参数都有默认值）。这就是使用<code>= default;</code>语法。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>() = <span class="keyword">default</span>; <span class="comment">// 显式地声明为默认构造函数（即使它没有参数）  </span></span><br><span class="line">    <span class="comment">// 或者，如果构造函数带有参数但所有参数都有默认值，也可以被视为默认构造函数  </span></span><br><span class="line">    <span class="comment">// MyClass(int a = 0, double b = 0.0) &#123;&#125;  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="禁止构造函数">禁止构造函数</h4>
<p>在面向对象编程中，有时我们可能希望禁止对象的实例化，即不希望其他代码通过调用类的构造函数来创建类的实例。这通常是因为该类被设计为工具类、静态类或者仅包含静态成员和静态方法，不依赖于类的实例状态。</p>
<p>在C++中，可以通过将构造函数声明为<code>private</code>来禁止外部代码创建类的实例。也可以将析构函数声明为<code>private</code>或<code>protected</code>（通常推荐<code>protected</code>，因为它允许类的析构函数在派生类中被调用，这是RAII模式所必需的）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Utility</span> &#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="comment">// 禁止外部代码通过构造函数创建实例  </span></span><br><span class="line">    <span class="built_in">Utility</span>() &#123;&#125;  </span><br><span class="line">    <span class="comment">// 如果还需要防止继承，可以将析构函数也设为private或protected  </span></span><br><span class="line">    <span class="comment">// 但通常，设为protected更合适  </span></span><br><span class="line">    <span class="comment">// ~Utility() &#123;&#125;  </span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="comment">// 静态成员函数  </span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// ...  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>C++11引入了<code>delete</code>关键字，它提供了一种更直接、更明确的方式来禁止或删除成员函数。通过在函数声明后加上<code>= delete</code>，可以告诉编译器这个函数被删除了，不能被调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">Uncopyable</span>() = <span class="keyword">default</span>; <span class="comment">// 使用默认构造函数  </span></span><br><span class="line">    <span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止拷贝构造函数  </span></span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止赋值运算符  </span></span><br><span class="line">    ~<span class="built_in">Uncopyable</span>() = <span class="keyword">default</span>; <span class="comment">// 使用默认析构函数  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="减少构造函数开销">减少构造函数开销</h4>
<p>在C++中，减少构造函数（Constructor）的开销是一个重要的性能优化方向，特别是当构造函数被频繁调用，或者处理大量对象时。构造函数时尽量使用类初始化列表，会减少调用默认的构造函数产生的开销。</p>
<ul>
<li>使用初始化列表可以提高性能，因为它允许直接初始化成员变量，避免了在构造函数体中先默认初始化成员变量然后再赋值的开销。</li>
<li>初始化列表紧跟在构造函数的参数列表之后，冒号（<code>:</code>）开头，后跟成员变量名和它们的初始化值，成员之间用逗号分隔。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> a;  </span><br><span class="line">    <span class="type">double</span> b;  </span><br><span class="line">    std::string c;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="comment">// 使用初始化列表的构造函数  </span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x, <span class="type">double</span> y, <span class="type">const</span> std::string&amp; z)  </span><br><span class="line">        : <span class="built_in">a</span>(x), <span class="built_in">b</span>(y), <span class="built_in">c</span>(z) <span class="comment">// 初始化列表  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">// 构造函数体可以为空，因为成员已经在初始化列表中初始化了  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, c = &quot;</span> &lt;&lt; c &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<h4 id="委托构造函数">委托构造函数</h4>
<p>初始化列表还可以用于委托构造函数（C++11及更高版本），即一个构造函数调用同一个类中的另一个构造函数来初始化对象。但是，这并不是通过初始化列表直接完成的，而是通过在构造函数体内部调用另一个构造函数（注意，这种调用必须是构造函数体中的第一条语句，且只能是构造函数体中的第一条语句）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">MyClass</span>(<span class="number">0</span>, <span class="number">0.0</span>, <span class="string">&quot;Default&quot;</span>) &#123;&#125; <span class="comment">// 委托构造函数  </span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x, <span class="type">double</span> y, <span class="type">const</span> std::string&amp; z) : <span class="built_in">a</span>(x), <span class="built_in">b</span>(y), <span class="built_in">c</span>(z) &#123;&#125;  </span><br><span class="line">    <span class="comment">// ... 其他成员和函数 ...  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="友元函数">友元函数</h4>
<p>友元函数在C++中扮演着特殊的角色，它允许一个非成员函数访问类的私有成员和保护成员。（不建议使用，过度使用友元函数可能会降低代码的安全性和可维护性）</p>
<h5 id="特点">特点</h5>
<ul>
<li><strong>访问私有成员</strong>：友元函数可以访问类的私有成员和保护成员，这是它最基本也是最重要的作用。通过友元函数，类可以允许外部函数或类在必要时访问其内部数据，而无需将这些数据公开为公有成员。</li>
<li><strong>提高程序灵活性</strong>：友元函数的存在使得类的设计更加灵活。在需要时，可以通过声明友元函数来扩展类的功能，而无需修改类的内部实现。</li>
<li><strong>提高执行效率</strong>：友元函数可以直接访问类的私有成员，而不需要通过公有接口（如getter和setter函数）进行访问。这可以减少函数调用的开销，从而提高程序的执行效率。</li>
</ul>
<h5 id="用处">用处</h5>
<ul>
<li><strong>运算符重载</strong>：在某些情况下，友元函数被用于运算符重载。例如，当需要为自定义类型实现自定义的算术运算时，可以将这些运算定义为友元函数，以便它们能够访问类的私有成员。</li>
<li><strong>友元类</strong>：当两个或多个类需要共享数据时，可以将一个类声明为另一个类的友元类，或者将某个函数声明为这些类的友元函数。这样，这些类或函数就可以访问彼此的私有成员，从而实现数据共享。</li>
<li><strong>全局函数访问私有成员</strong>：当需要在全局范围内定义一个函数来访问类的私有成员时，可以将该函数声明为友元函数。这样，该函数就可以在不破坏类封装性的前提下访问类的私有成员。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 声明友元函数  </span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">(<span class="type">const</span> Circle&amp; c)</span></span>;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">double</span> radius; <span class="comment">// 私有成员变量  </span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="comment">// 构造函数  </span></span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> r = <span class="number">0.0</span>) : <span class="built_in">radius</span>(r) &#123;&#125;  </span><br><span class="line">    <span class="comment">// 设置半径的公有成员函数  </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setRadius</span><span class="params">(<span class="type">double</span> r)</span> </span>&#123;  </span><br><span class="line">        radius = r;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 声明友元函数  </span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">double</span> <span class="title">calculateArea</span><span class="params">(<span class="type">const</span> Circle&amp; c)</span></span>;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数  </span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">(<span class="type">const</span> Circle&amp; c)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 直接访问私有成员变量radius  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.14159</span> * c.radius * c.radius;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译时多态和运行时多态">编译时多态和运行时多态</h4>
<p>在面向对象编程中，多态性是一个核心概念，它允许我们以统一的方式处理不同类型的对象。多态性可以分为两种主要类型：编译时多态（也称为静态多态或早绑定）和运行时多态（也称为动态多态或晚绑定）。</p>
<h5 id="编译时多态（静态多态）">编译时多态（静态多态）</h5>
<p>编译时多态主要通过函数重载（Function Overloading）和模板（Templates）实现。</p>
<ul>
<li>
<p><strong>函数重载</strong>：在同一作用域内，可以声明几个功能类似的同名函数，但这些函数的参数列表（参数个数、类型或顺序）必须不同。编译器在编译时会根据函数的参数列表和调用时提供的参数类型来选择最合适的函数进行调用。这种多态性在编译时就已经确定了，因此称为编译时多态。</p>
</li>
<li>
<p><strong>模板</strong>：模板是C++支持泛型编程的工具，它允许程序员编写与类型无关的代码。通过模板，可以创建函数模板和类模板。当编译器看到模板的使用时，它会根据提供的具体类型来生成相应的函数或类代码。这也是在编译时确定的，因此也被归类为编译时多态。</p>
</li>
</ul>
<h5 id="运行时多态（动态多态）">运行时多态（动态多态）</h5>
<p>运行时多态主要通过虚函数（Virtual Functions）和继承（Inheritance）实现，它允许在基类的指针或引用上调用派生类中的成员函数。</p>
<ul>
<li>
<p><strong>虚函数</strong>：在基类中，可以将某个成员函数声明为虚函数，这意味着该函数在派生类中可以被重写（Override）。当通过基类类型的指针或引用来调用虚函数时，实际调用的是指针或引用所指向的对象的成员函数版本。这个决定是在运行时做出的，因为编译器在编译时无法确定指针或引用将指向哪个派生类的对象。这种多态性称为运行时多态。</p>
</li>
<li>
<p><strong>抽象基类</strong>：通常，至少含有一个纯虚函数的类被称为抽象基类。抽象基类不能被实例化，但可以用作派生类的基类。纯虚函数是必须在派生类中重写的虚函数，它在基类中没有实现。抽象基类在面向对象的设计中非常重要，因为它们允许定义一组接口，这些接口在派生类中具体实现。</p>
</li>
</ul>
<h5 id="简述区别">简述区别</h5>
<ul>
<li><strong>编译时多态</strong>：在编译时就确定了函数或方法的调用版本，主要通过函数重载和模板实现。</li>
<li><strong>运行时多态</strong>：在运行时才确定函数或方法的调用版本，主要通过虚函数和继承实现。</li>
</ul>
<h4 id="C-模板编程">C++模板编程</h4>
<p>C++ 模板编程是 C++ 语言的一个强大特性，它允许程序员编写与类型无关的代码。通过使用模板，可以编写出通用的函数和类，这些函数和类可以工作于多种数据类型上，而无需为每种数据类型都编写专门的代码。模板通常分为函数模板和类模板两种。</p>
<h5 id="函数模板">函数模板</h5>
<p>函数模板允许你定义一个函数框架，该框架可以作用于多种数据类型上。模板的定义以 <code>template &lt;typename T&gt;</code> 或 <code>template &lt;class T&gt;</code> 开头，其中 <code>T</code> 是一个占位符，代表将在函数调用时指定的数据类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The max of 3 and 5 is &quot;</span> &lt;&lt; <span class="built_in">max</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 使用 int 类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The max of 3.14 and 2.71 is &quot;</span> &lt;&lt; <span class="built_in">max</span>(<span class="number">3.14</span>, <span class="number">2.71</span>) &lt;&lt; std::endl; <span class="comment">// 使用 double 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="类模板">类模板</h5>
<p>类模板与函数模板类似，但它定义了一个类的框架，该类可以工作于多种数据类型上。通过类模板，可以创建出泛型的数据结构，如泛型容器、泛型算法等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Box</span>(T val) : <span class="built_in">m_value</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Box contains: &quot;</span> &lt;&lt; m_value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Box&lt;<span class="type">int</span>&gt; <span class="title">intBox</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    intBox.<span class="built_in">display</span>(); <span class="comment">// 输出: Box contains: 10</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Box&lt;<span class="type">double</span>&gt; <span class="title">doubleBox</span><span class="params">(<span class="number">3.14</span>)</span></span>;</span><br><span class="line">    doubleBox.<span class="built_in">display</span>(); <span class="comment">// 输出: Box contains: 3.14</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="模板特化">模板特化</h5>
<p>模板特化是模板编程中的一个高级特性，它允许你为模板的特定类型提供定制的实现。这在你需要为特定类型优化模板代码时非常有用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">store</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通用实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化 Storage 类以用于 char* 类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Storage</span>&lt;<span class="type">char</span>*&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">store</span><span class="params">(<span class="type">char</span>* value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为 char* 类型定制的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="如何禁止拷贝">如何禁止拷贝</h4>
<p>从C++11开始，<code>delete</code>关键字被引入用于显式地删除函数，包括拷贝构造函数和拷贝赋值运算符。当你想要禁止拷贝时，可以将它们声明为<code>delete</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonCopyable</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">NonCopyable</span>() = <span class="keyword">default</span>; <span class="comment">// 默认构造函数  </span></span><br><span class="line">    <span class="built_in">NonCopyable</span>(<span class="type">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止拷贝构造  </span></span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止拷贝赋值  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 可以提供移动构造函数和移动赋值运算符（如果需要）  </span></span><br><span class="line">    <span class="built_in">NonCopyable</span>(NonCopyable&amp;&amp;) = <span class="keyword">default</span>; <span class="comment">// 默认移动构造  </span></span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(NonCopyable&amp;&amp;) = <span class="keyword">default</span>; <span class="comment">// 默认移动赋值  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 其他成员函数...  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="拷贝构造函数">拷贝构造函数</h4>
<p>拷贝构造函数是C++中的一个特殊成员函数，它用于创建一个新对象作为另一个同类型对象的副本。当使用现有对象来初始化新对象时，会调用拷贝构造函数。拷贝构造函数的一个重要用途是确保资源（如动态分配的内存、文件句柄等）被正确地复制或管理。</p>
<ul>
<li>函数声明：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ClassName</span>(<span class="type">const</span> ClassName&amp; other);</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义拷贝与深拷贝：为类定义自己的拷贝构造函数，以执行深拷贝</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="type">int</span>* data;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 自定义拷贝构造函数  </span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) &#123;  </span><br><span class="line">        <span class="comment">// 分配新内存  </span></span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(*other.data);  </span><br><span class="line">        <span class="comment">// 注意：如果 MyClass 有其他成员，也需要在这里进行复制  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 析构函数  </span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;  </span><br><span class="line">        <span class="keyword">delete</span> data;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 禁用拷贝赋值运算符（可选，但推荐）  </span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp;) = <span class="keyword">delete</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ... 其他成员函数 ...  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="对象的实例化">对象的实例化</h4>
<ol>
<li>例子：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="comment">// 定义一个类  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="type">int</span> x, y; <span class="comment">// 成员变量  </span></span><br><span class="line">    <span class="comment">// 带参数的构造函数  </span></span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> xVal, <span class="type">int</span> yVal) : <span class="built_in">x</span>(xVal), <span class="built_in">y</span>(yVal) &#123;&#125;  </span><br><span class="line">    <span class="comment">// 成员函数，用于打印点的坐标  </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 使用带参数的构造函数实例化对象  </span></span><br><span class="line">    <span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;  </span><br><span class="line">    p2.<span class="built_in">print</span>(); <span class="comment">// 输出: (10, 20)  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>过程：</li>
</ol>
<ul>
<li>
<p>内存分配在实例化对象之前，需要为对象分配内存空间。根据对象的创建方式，内存可能分配在栈上或堆上。</p>
</li>
<li>
<p>构造函数调用：在内存分配之后，会调用类的构造函数来初始化对象。构造函数是一个特殊的成员函数，它在对象创建时自动调用，用于设置对象的初始状态。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>面向对象（OOP）</tag>
      </tags>
  </entry>
  <entry>
    <title>Per_FedAVG源码分析总领</title>
    <url>/2024/06/28/Per-FedAVG%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%80%BB%E9%A2%86/</url>
    <content><![CDATA[<h3 id="data-dataset-py">data_dataset.py</h3>
<p>这段代码定义了两个自定义的PyTorch数据集类：<code>MNISTDataset</code> 和 <code>CIFARDataset</code>。这两个类都继承自PyTorch提供的<code>Dataset</code>类，这使得它们能够与PyTorch的数据加载器一起使用。<br>
<code>MNISTDataset</code>是为MNIST数据集设计的，该数据集包含28x28像素的灰度手写数字图像。<code>CIFARDataset</code>是为CIFAR数据集设计的，该数据集包含32x32像素的彩色图像，分为10个不同的类别（飞机、汽车、鸟、猫、鹿、狗、青蛙、马、船和卡车）。<br>
这两个数据集的构造函数和方法都相同，唯一的区别是数据集的名称（这并不影响其功能）。构造函数接受数据子集和目标，或者单独的数据和目标张量。它还接受可选的transform和target_transform函数，这些函数可以在迭代数据集时用于对数据和目标应用变换。<br>
<code>__getitem__</code>方法为给定的索引返回一个数据样本及其相应的目标。如果提供了变换函数，它将应用于数据样本。如果提供了target_transform函数，它将应用于目标。<br>
<code>__len__</code>方法返回数据集中的样本数量。</p>
<h3 id="data-utils-py">data_utils.py</h3>
<p>这段代码提供了两个函数，<code>get_dataloader</code> 和 <code>get_client_id_indices</code>，用于加载预处理后的联邦学习数据集的数据加载器，以及获取客户端ID的索引。</p>
<ol>
<li><code>get_dataloader</code> 函数接受数据集名称（“mnist” 或 “cifar”）、客户端ID、批处理大小和验证集比例作为参数。它首先检查是否存在预处理的数据集pickle文件，如果没有，则抛出运行时错误。然后，它加载指定客户端的数据集，并将其随机划分为训练集和验证集。最后，它为训练集和验证集创建数据加载器，并返回它们。</li>
<li><code>get_client_id_indices</code> 函数接受数据集名称作为参数。它加载保存的客户端分离信息（“seperation.pkl”），并返回训练客户端、测试客户端和总客户端数的索引列表。<br>
这些函数允许在联邦学习设置中为每个客户端加载和分割数据集，以便进行模型训练和验证。使用这些函数，可以轻松地获取每个客户端的数据加载器，以及客户端的索引信息。</li>
</ol>
<h3 id="data-perprocess-py">data_perprocess.py</h3>
<p>这段代码是一个Python脚本，用于预处理MNIST或CIFAR10数据集，以适应联邦学习设置。它随机地为每个客户端分配类别，将数据集分为训练集和测试集，然后将这些数据集保存为磁盘上的pickle文件。它还将客户端数据分布的统计信息保存为JSON文件。<br>
以下是代码的详细说明：</p>
<ol>
<li>脚本导入了必要的库，包括PyTorch、<a href="http://xn--torchvisionpath-hb5z.py">torchvision和path.py</a>，用于文件系统操作。</li>
<li><code>DATASET</code>、<code>MEAN</code>和<code>STD</code>字典定义了数据集、平均值和标准差的信息，用于数据归一化。</li>
<li><code>preprocess</code>函数是主要的功能，负责处理数据：
<ul>
<li>它设置数据集目录和pickle目录。</li>
<li>它为随机数生成器设置种子，以确保可重复性。</li>
<li>它根据客户端总数和训练客户端的比例计算训练和测试客户端的数量。</li>
<li>它定义了用于归一化的数据转换。</li>
<li>它加载原始数据集，并使用<code>randomly_alloc_classes</code>函数为客户端分配类别。</li>
<li>它将各个客户端的数据集保存为pickle文件，并将客户端分为训练和测试的分离信息保存为&quot;seperation.pkl&quot;。</li>
<li>它将数据集分布的统计信息保存为&quot;all_stats.json&quot;。</li>
</ul>
</li>
<li><code>randomly_alloc_classes</code>函数接受原始数据集、目标数据集类、客户端数量、每个客户端的类别数量以及可选的转换。它使用<code>noniid_slicing</code>函数以非独立同分布的方式切分数据集，为每个客户端创建一个包含指定类别数量的数据集列表。它还计算并返回客户端数据分布的统计信息。</li>
<li><code>__main__</code>块解析命令行参数，包括数据集选择、客户端总数、训练客户端的比例、每个客户端的类别数量和随机种子，然后调用<code>preprocess</code>函数。<br>
要运行此脚本，通常会在命令行中执行它，并提供必要的参数。例如：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python preprocess.py --dataset mnist --client_num_in_total 100 --fraction 0.8 --classes 2 --seed 123</span><br></pre></td></tr></table></figure>
<p>这将预处理MNIST数据集，用于有100个客户端的联邦学习设置，其中80%是训练客户端，每个客户端有2个类别的数据，并使用随机种子123确保结果的可重复性。</p>
<h3 id="model-py"><a href="http://model.py">model.py</a></h3>
<p>这段代码定义了两个模型类，<code>MLP_MNIST</code> 和 <code>MLP_CIFAR10</code>，分别用于MNIST和CIFAR10数据集。这两个模型都是多层感知机（MLP），包含三个全连接层，每个层后面都有一个ELU激活函数。<br>
此外，代码还定义了一个<code>MODEL_DICT</code>字典，用于根据数据集名称获取相应的模型类。<br>
最后，<code>get_model</code>函数接受数据集名称和设备（CPU或GPU）作为参数，并返回相应的模型实例。<br>
以下是代码的详细说明：</p>
<ol>
<li><code>elu</code>类是一个自定义的ELU激活函数，它使用<code>torch.where</code>来判断输入是否大于0，并返回相应的值。对于小于0的输入，它使用0.2乘以指数函数减1的结果。</li>
<li><code>linear</code>类是一个自定义的全连接层，它包含权重矩阵<code>w</code>和偏置<code>b</code>。权重矩阵是通过随机初始化得到的，其标准差是输入特征数目的倒数。</li>
<li><code>MLP_MNIST</code>和<code>MLP_CIFAR10</code>类是MNIST和CIFAR10数据集的MLP模型。它们包含三个全连接层，每个层后面都跟着一个ELU激活函数。在MNIST模型中，输入特征是28x28像素的图像，而在CIFAR10模型中，输入特征是32x32x3的图像。</li>
<li><code>MODEL_DICT</code>字典包含两个模型类，分别对应MNIST和CIFAR10数据集。</li>
<li><code>get_model</code>函数根据传入的数据集名称和设备，从<code>MODEL_DICT</code>中获取相应的模型类，并实例化模型。如果设备是GPU，它将模型移动到GPU上；如果设备是CPU，它将模型移动到CPU上。</li>
</ol>
<h3 id="utils-py"><a href="http://utils.py">utils.py</a></h3>
<p>这段代码提供了一个命令行参数解析函数 <code>get_args</code>，以及两个用于模型评估和随机种子固定的辅助函数 <code>eval</code> 和 <code>fix_random_seed</code>。</p>
<ol>
<li><code>get_args</code> 函数使用 <code>ArgumentParser</code> 从命令行中解析参数。这些参数包括学习率、正则化参数、全局和局部训练轮次、个性化阶段的轮次、批处理大小、验证集比例、数据集名称、每轮训练的客户端数量、随机种子、是否使用GPU、是否在训练过程中进行评估，以及是否记录日志。</li>
<li><code>eval</code> 函数是一个用于评估模型的函数，它接受模型、数据加载器、损失函数和设备作为参数。该函数在评估模式下运行模型，并计算在数据加载器上的总损失和准确率。它返回总损失和准确率。</li>
<li><code>fix_random_seed</code> 函数用于固定PyTorch和其他库的随机种子，以确保实验的可重复性。它接受一个种子值作为参数，并设置相应的随机种子。此外，它还清空了GPU缓存，并设置了CUDA的确定性选项。<br>
这些函数为联邦学习实验提供了一个基础框架，用于处理命令行参数、评估模型和确保实验的可重复性。</li>
</ol>
<h3 id="perfedavg-py"><a href="http://perfedavg.py">perfedavg.py</a></h3>
<p>这段代码定义了一个名为 <code>PerFedAvgClient</code> 的类，用于在联邦学习中训练一个客户端的模型。该类支持两种不同的训练模式：<code>Per-FedAvg(FO)</code> 和 <code>Per-FedAvg(HF)</code>。<br>
以下是代码的详细说明：</p>
<ol>
<li><strong>初始化方法</strong>：
<ul>
<li>客户端ID（<code>client_id</code>）：标识客户端的唯一ID。</li>
<li><code>alpha</code> 和 <code>beta</code>：学习率和正则化参数。</li>
<li><code>global_model</code>：全局模型，即所有客户端共享的模型。</li>
<li><code>criterion</code>：损失函数。</li>
<li><code>batch_size</code>：批量大小。</li>
<li><code>dataset</code>：数据集名称，支持MNIST和CIFAR10。</li>
<li><code>local_epochs</code>：本地训练轮次。</li>
<li><code>valset_ratio</code>：验证集比例。</li>
<li><code>logger</code>：日志记录器。</li>
<li><code>gpu</code>：是否使用GPU。</li>
</ul>
</li>
<li><strong>训练方法</strong>：
<ul>
<li>首先，客户端加载全局模型的状态字典。</li>
<li>然后，客户端进行本地训练。对于 <code>Per-FedAvg(HF)</code> 模式，训练分为两个阶段，每个阶段都包含一个梯度计算和模型更新。对于 <code>Per-FedAvg(FO)</code> 模式，代码中包含了注释掉的联邦平均（FedAvg）训练步骤。</li>
<li>如果设置了 <code>eval_while_training</code>，客户端在本地训练前后都会进行评估。</li>
<li>训练完成后，客户端返回序列化的模型状态。</li>
</ul>
</li>
<li><strong>计算梯度方法</strong>：
<ul>
<li>该方法计算模型参数的梯度。</li>
<li>对于 <code>Per-FedAvg(HF)</code> 模式，它还会计算二阶导数。</li>
</ul>
</li>
<li><strong>个性化评估方法</strong>：
<ul>
<li>该方法用于个性化评估。客户端首先加载全局模型的状态字典，然后进行个性化训练和评估。</li>
<li>个性化训练包括一个梯度计算和模型更新。</li>
<li>评估完成后，客户端返回损失和准确率的变化。</li>
</ul>
</li>
<li><strong>辅助方法</strong>：
<ul>
<li><code>get_data_batch</code>：获取一个数据批量的方法。</li>
<li><code>utils.eval</code>：评估模型的方法，从 <code>utils</code> 模块导入。</li>
<li><code>SerializationTool.serialize_model</code>：序列化模型的方法，从 <code>SerializationTool</code> 模块导入。<br>
这个类为联邦学习中的客户端提供了训练和评估模型的功能，支持不同的训练模式和个性化评估。</li>
</ul>
</li>
</ol>
<h3 id="main-py"><a href="http://main.py">main.py</a></h3>
<p>这段代码是一个联邦学习实验的主程序，它负责初始化客户端、进行训练和评估，并记录日志。以下是代码的详细说明：</p>
<ol>
<li><strong>命令行参数解析</strong>：
<ul>
<li>代码首先使用 <code>get_args</code> 函数解析命令行参数，并使用 <code>fix_random_seed</code> 函数设置随机种子。</li>
<li>检查是否存在日志目录，如果不存在则创建。</li>
</ul>
</li>
<li><strong>设备选择</strong>：
<ul>
<li>如果指定了GPU并且GPU可用，则选择GPU作为设备；否则选择CPU。</li>
</ul>
</li>
<li><strong>全局模型初始化</strong>：
<ul>
<li>使用 <code>get_model</code> 函数根据数据集名称初始化全局模型。</li>
<li>创建日志记录器。</li>
</ul>
</li>
<li><strong>客户端初始化</strong>：
<ul>
<li>创建一个客户端列表，每个客户端都使用 <code>PerFedAvgClient</code> 类初始化。</li>
</ul>
</li>
<li><strong>训练循环</strong>：
<ul>
<li>使用 <code>track</code> 函数跟踪训练进度。</li>
<li>随机选择客户端进行本地训练，并将序列化的模型参数存储在 <code>model_params_cache</code> 中。</li>
<li>使用 <code>Aggregators.fedavg_aggregate</code> 函数聚合模型参数。</li>
<li>反序列化聚合后的模型参数到全局模型。</li>
</ul>
</li>
<li><strong>评估循环</strong>：
<ul>
<li>使用 <code>track</code> 函数跟踪评估进度。</li>
<li>对每个评估客户端执行个性化评估，并记录损失和准确率。</li>
</ul>
</li>
<li><strong>结果展示</strong>：
<ul>
<li>打印评估结果。</li>
</ul>
</li>
<li><strong>日志记录</strong>：
<ul>
<li>如果设置了日志记录，使用 <code>logger.save_html</code> 函数将日志保存为HTML文件。<br>
这个程序为联邦学习实验提供了一个完整的框架，包括客户端的初始化、模型的训练和评估，以及日志的记录和保存。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Per_FedAVG</tag>
      </tags>
  </entry>
  <entry>
    <title>STL标准模板库</title>
    <url>/2024/06/26/STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/</url>
    <content><![CDATA[<h3 id="概述：">概述：</h3>
<p>STL（Standard Template Library，标准模板库）是C++标准库的一部分，它提供了大量的模板类和函数，用于执行常见的算法和数据结构操作。STL的主要目的是提供一个统一、高效、可重用的数据结构和算法库，以减少程序员在编写这些基础代码时的重复工作。</p>
<h3 id="优点：">优点：</h3>
<ul>
<li>STL 是 C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</li>
<li>程序员可以不用思考 STL 具体的实现过程，只要能够熟练使用 STL 就 OK 了。</li>
<li>STL 具有高可重用性，高性能，高移植性，跨平台的优点。</li>
</ul>
<h3 id="组成：">组成：</h3>
<ul>
<li>容器、迭代器、算法、函数对象、适配器和分配器</li>
</ul>
<table>
<thead>
<tr>
<th>类别</th>
<th>示例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>容器（Containers）</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>序列容器</td>
<td><code>vector</code></td>
<td>动态数组，支持快速随机访问</td>
</tr>
<tr>
<td></td>
<td><code>deque</code></td>
<td>双端队列，支持在两端快速插入和删除</td>
</tr>
<tr>
<td></td>
<td><code>list</code></td>
<td>双向链表，支持在任何位置快速插入和删除</td>
</tr>
<tr>
<td>关联容器</td>
<td><code>set</code></td>
<td>有序集合，不允许重复元素</td>
</tr>
<tr>
<td></td>
<td><code>multiset</code></td>
<td>有序集合，允许重复元素</td>
</tr>
<tr>
<td></td>
<td><code>map</code></td>
<td>键值对集合，键唯一，值可重复</td>
</tr>
<tr>
<td></td>
<td><code>multimap</code></td>
<td>键值对集合，键可重复</td>
</tr>
<tr>
<td>容器适配器</td>
<td><code>stack</code></td>
<td>后进先出（LIFO）容器</td>
</tr>
<tr>
<td></td>
<td><code>queue</code></td>
<td>先进先出（FIFO）容器</td>
</tr>
<tr>
<td></td>
<td><code>priority_queue</code></td>
<td>优先级队列，元素根据优先级排序</td>
</tr>
<tr>
<td><strong>迭代器（Iterators）</strong></td>
<td></td>
<td>访问容器中元素的通用接口</td>
</tr>
<tr>
<td></td>
<td><code>begin()</code></td>
<td>返回指向容器第一个元素的迭代器</td>
</tr>
<tr>
<td></td>
<td><code>end()</code></td>
<td>返回指向容器尾后位置的迭代器（不指向任何元素）</td>
</tr>
<tr>
<td><strong>算法（Algorithms）</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>sort()</code></td>
<td>对容器中的元素进行排序</td>
</tr>
<tr>
<td></td>
<td><code>find()</code></td>
<td>在容器中查找元素</td>
</tr>
<tr>
<td></td>
<td><code>copy()</code></td>
<td>复制容器中的元素</td>
</tr>
<tr>
<td></td>
<td>…</td>
<td>其他各种算法，如 <code>remove()</code>, <code>reverse()</code>, <code>binary_search()</code> 等</td>
</tr>
<tr>
<td><strong>函数对象（Function Objects）</strong></td>
<td></td>
<td>类似于函数，但可以作为对象传递和存储</td>
</tr>
<tr>
<td></td>
<td><code>less&lt;T&gt;</code></td>
<td>比较两个对象是否小于（默认用于<code>set</code>, <code>map</code>等）</td>
</tr>
<tr>
<td></td>
<td><code>greater&lt;T&gt;</code></td>
<td>比较两个对象是否大于</td>
</tr>
<tr>
<td></td>
<td>自定义函数对象</td>
<td>自定义比较或操作函数</td>
</tr>
<tr>
<td><strong>适配器（Adapters）</strong></td>
<td></td>
<td>修改已有接口以适应不同需求</td>
</tr>
<tr>
<td></td>
<td><code>reverse_iterator</code></td>
<td>反向迭代器，用于反向遍历容器</td>
</tr>
<tr>
<td></td>
<td><code>istream_iterator</code></td>
<td>读取输入流中的元素</td>
</tr>
<tr>
<td></td>
<td><code>ostream_iterator</code></td>
<td>将元素写入输出流</td>
</tr>
<tr>
<td><strong>分配器（Allocators）</strong></td>
<td></td>
<td>管理容器中的内存分配</td>
</tr>
<tr>
<td></td>
<td><code>allocator&lt;T&gt;</code></td>
<td>默认分配器，使用<code>new</code>和<code>delete</code></td>
</tr>
<tr>
<td></td>
<td>自定义分配器</td>
<td>根据特定需求管理内存</td>
</tr>
</tbody>
</table>
<h3 id="常用容器">常用容器</h3>
<h4 id="string容器">string容器</h4>
<h5 id="构造函数：">构造函数：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>();<span class="comment">//创建一个空的字符串 例如: string str;      </span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp; str);<span class="comment">//使用一个string对象初始化另一个string对象</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span>* s);<span class="comment">//使用字符串s初始化</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">int</span> n, <span class="type">char</span> c);<span class="comment">//使用n个字符c初始化 </span></span><br></pre></td></tr></table></figure>
<h5 id="基本赋值：">基本赋值：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span>* s);<span class="comment">//char*类型字符串 赋值给当前的字符串</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>=(<span class="type">const</span> string &amp;s);<span class="comment">//把字符串s赋给当前的字符串</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>=(<span class="type">char</span> c);<span class="comment">//字符赋值给当前的字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;<span class="comment">//把字符串s赋给当前的字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> n)</span></span>;<span class="comment">//把字符串s的前n个字符赋给当前的字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;<span class="comment">//把字符串s赋给当前字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> c)</span></span>;<span class="comment">//用n个字符c赋给当前字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> start, <span class="type">int</span> n)</span></span>;<span class="comment">//将s从start开始n个字符赋值给字符</span></span><br></pre></td></tr></table></figure>
<h5 id="存取字符：">存取字符：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> n);<span class="comment">//通过[]方式取字符</span></span><br><span class="line"><span class="function"><span class="type">char</span>&amp; <span class="title">at</span><span class="params">(<span class="type">int</span> n)</span></span>;<span class="comment">//通过at方法获取字符</span></span><br></pre></td></tr></table></figure>
<h5 id="拼接操作：">拼接操作：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> string&amp; str);<span class="comment">//重载+=操作符</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span>* str);<span class="comment">//重载+=操作符</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span> c);<span class="comment">//重载+=操作符</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;<span class="comment">//把字符串s连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> n)</span></span>;<span class="comment">//把字符串s的前n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;<span class="comment">//同operator+=()</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> pos, <span class="type">int</span> n)</span></span>;<span class="comment">//把字符串s中从pos开始的n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> c)</span></span>;<span class="comment">//在当前字符串结尾添加n个字符c</span></span><br></pre></td></tr></table></figure>
<h5 id="查找替换：">查找替换：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">//查找str第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;  <span class="comment">//查找s第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos, <span class="type">int</span> n)</span> <span class="type">const</span></span>;  <span class="comment">//从pos位置查找s的前n个字符第一次位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;  <span class="comment">//查找字符c第一次出现位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//查找str最后一次位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//查找s最后一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos, <span class="type">int</span> n)</span> <span class="type">const</span></span>;<span class="comment">//从pos查找s的前n个字符最后一次位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">//查找字符c最后一次出现位置</span></span><br><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">const</span> string&amp; str)</span></span>; <span class="comment">//替换从pos开始n个字符为字符串str</span></span><br><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">const</span> <span class="type">char</span>* s)</span></span>; <span class="comment">//替换从pos开始的n个字符为字符串s</span></span><br></pre></td></tr></table></figure>
<h5 id="比较操作：">比较操作：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。</span></span><br><span class="line"><span class="comment">比较区分大小写，比较时参考字典顺序，排越前面的越小。</span></span><br><span class="line"><span class="comment">大写的A比小写的a小。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> string &amp;s)</span> <span class="type">const</span></span>;<span class="comment">//与字符串s比较</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> <span class="type">const</span></span>;<span class="comment">//与字符串s比较</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="取出子串：">取出子串：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">substr</span><span class="params">(<span class="type">int</span> pos = <span class="number">0</span>, <span class="type">int</span> n = npos)</span> <span class="type">const</span></span>;<span class="comment">//返回由pos开始的n个字符组成的字符串</span></span><br></pre></td></tr></table></figure>
<h5 id="插入删除：">插入删除：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">const</span> <span class="type">char</span>* s)</span></span>; <span class="comment">//插入字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">const</span> string&amp; str)</span></span>; <span class="comment">//插入字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">char</span> c)</span></span>;<span class="comment">//在指定位置插入n个字符c</span></span><br><span class="line"><span class="function">string&amp; <span class="title">erase</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n = npos)</span></span>;<span class="comment">//删除从Pos开始的n个字符 </span></span><br></pre></td></tr></table></figure>
<h5 id="c-style转换：">c-style转换：</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//string 转 char*</span></span><br><span class="line">string str = <span class="string">&quot;it&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cstr = str.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="comment">//char* 转 string </span></span><br><span class="line"><span class="type">char</span>* s = <span class="string">&quot;it&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(s)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="vector容器">vector容器</h4>
<h5 id="构造函数">构造函数</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;T&gt; v; <span class="comment">//采用模板实现类实现，默认构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">//将v[begin(), end())区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(n, elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector &amp;vec);<span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure>
<h5 id="赋值操作">赋值操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assign</span>(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">assign</span>(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line">vector&amp; <span class="keyword">operator</span>=(<span class="type">const</span> vector  &amp;vec);<span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="built_in">swap</span>(vec);<span class="comment">// 将vec与本身的元素互换。</span></span><br></pre></td></tr></table></figure>
<h5 id="大小操作">大小操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">size</span>();<span class="comment">//返回容器中元素的个数</span></span><br><span class="line"><span class="built_in">empty</span>();<span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="built_in">resize</span>(<span class="type">int</span> num);<span class="comment">//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"><span class="built_in">resize</span>(<span class="type">int</span> num, elem);<span class="comment">//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。</span></span><br><span class="line"><span class="built_in">capacity</span>();<span class="comment">//容器的容量</span></span><br><span class="line"><span class="built_in">reserve</span>(<span class="type">int</span> len);<span class="comment">//容器预留len个元素长度，预留位置不初始化，元素不可访问。</span></span><br></pre></td></tr></table></figure>
<h5 id="数据存取">数据存取</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">at</span>(<span class="type">int</span> idx); <span class="comment">//返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</span></span><br><span class="line"><span class="keyword">operator</span>[];<span class="comment">//返回索引idx所指的数据，越界时，运行直接报错</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回容器中第一个数据元素</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回容器中最后一个数据元素</span></span><br></pre></td></tr></table></figure>
<h5 id="插入删除">插入删除</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">insert</span>(const_iterator pos, <span class="type">int</span> count,ele);<span class="comment">//迭代器指向位置pos插入count个元素ele.</span></span><br><span class="line"><span class="built_in">push_back</span>(ele); <span class="comment">//尾部插入元素ele</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除最后一个元素</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator start, const_iterator end);<span class="comment">//删除迭代器从start到end之间的元素</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator pos);<span class="comment">//删除迭代器指向的元素</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//删除容器中所有元素</span></span><br></pre></td></tr></table></figure>
<h4 id="deque容器">deque容器</h4>
<h5 id="构造函数-2">构造函数</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;T&gt; deqT;<span class="comment">//默认构造形式</span></span><br><span class="line"><span class="built_in">deque</span>(beg, end);<span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(n, elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="type">const</span> deque &amp;deq);<span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure>
<h5 id="赋值操作-2">赋值操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assign</span>(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">assign</span>(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line">deque&amp; <span class="keyword">operator</span>=(<span class="type">const</span> deque &amp;deq); <span class="comment">//重载等号操作符 </span></span><br><span class="line"><span class="built_in">swap</span>(deq);<span class="comment">// 将deq与本身的元素互换</span></span><br></pre></td></tr></table></figure>
<h5 id="大小操作-2">大小操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque.<span class="built_in">size</span>();<span class="comment">//返回容器中元素的个数</span></span><br><span class="line">deque.<span class="built_in">empty</span>();<span class="comment">//判断容器是否为空</span></span><br><span class="line">deque.<span class="built_in">resize</span>(num);<span class="comment">//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line">deque.<span class="built_in">resize</span>(num, elem); <span class="comment">//重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br></pre></td></tr></table></figure>
<h5 id="插入删除-2">插入删除</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">insert</span>(pos,elem);<span class="comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,n,elem);<span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,beg,end);<span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//移除容器的所有数据</span></span><br><span class="line"><span class="built_in">erase</span>(beg,end);<span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br></pre></td></tr></table></figure>
<h5 id="数据存取-2">数据存取</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">at</span>(idx);<span class="comment">//返回索引idx所指的数据，如果idx越界，抛出out_of_range。</span></span><br><span class="line"><span class="keyword">operator</span>[];<span class="comment">//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个数据。</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个数据</span></span><br></pre></td></tr></table></figure>
<h5 id="双端插入删除">双端插入删除</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(elem);<span class="comment">//在容器尾部添加一个数据</span></span><br><span class="line"><span class="built_in">push_front</span>(elem);<span class="comment">//在容器头部插入一个数据</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除容器最后一个数据</span></span><br><span class="line"><span class="built_in">pop_front</span>();<span class="comment">//删除容器第一个数据</span></span><br></pre></td></tr></table></figure>
<h4 id="stack容器">stack容器</h4>
<h5 id="构造函数-3">构造函数</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&lt;T&gt; stkT;<span class="comment">//stack采用模板类实现， stack对象的默认构造形式： </span></span><br><span class="line"><span class="built_in">stack</span>(<span class="type">const</span> stack &amp;stk);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<h5 id="赋值操作-3">赋值操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> stack &amp;stk);<span class="comment">//重载等号操作符</span></span><br></pre></td></tr></table></figure>
<h5 id="大小操作-3">大小操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push</span>(elem);<span class="comment">//向栈顶添加元素</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//从栈顶移除第一个元素</span></span><br><span class="line"><span class="built_in">top</span>();<span class="comment">//返回栈顶元素</span></span><br></pre></td></tr></table></figure>
<h5 id="数据存取-3">数据存取</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push</span>(elem);<span class="comment">//向栈顶添加元素</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//从栈顶移除第一个元素</span></span><br><span class="line"><span class="built_in">top</span>();<span class="comment">//返回栈顶元素</span></span><br></pre></td></tr></table></figure>
<h4 id="queue容器">queue容器</h4>
<h5 id="构造函数-4">构造函数</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;T&gt; queT;<span class="comment">//queue采用模板类实现，queue对象的默认构造形式：</span></span><br><span class="line"><span class="built_in">queue</span>(<span class="type">const</span> queue &amp;que);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<h5 id="赋值操作-4">赋值操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> queue &amp;que);<span class="comment">//重载等号操作符</span></span><br></pre></td></tr></table></figure>
<h5 id="大小操作-4">大小操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> queue &amp;que);<span class="comment">//重载等号操作符</span></span><br></pre></td></tr></table></figure>
<h5 id="存取插入删除">存取插入删除</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push</span>(elem);<span class="comment">//往队尾添加元素</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//从队头移除第一个元素</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个元素</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个元素</span></span><br></pre></td></tr></table></figure>
<h4 id="list容器">list容器</h4>
<h5 id="构造函数-5">构造函数</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;T&gt; lstT;<span class="comment">//list采用采用模板类实现,对象的默认构造形式：</span></span><br><span class="line"><span class="built_in">list</span>(beg,end);<span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">list</span>(n,elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">list</span>(<span class="type">const</span> list &amp;lst);<span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure>
<h5 id="赋值操作-5">赋值操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assign</span>(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">assign</span>(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line">list&amp; <span class="keyword">operator</span>=(<span class="type">const</span> list &amp;lst);<span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="built_in">swap</span>(lst);<span class="comment">//将lst与本身的元素互换。</span></span><br></pre></td></tr></table></figure>
<h5 id="大小操作-5">大小操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">size</span>();<span class="comment">//返回容器中元素的个数</span></span><br><span class="line"><span class="built_in">empty</span>();<span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="built_in">resize</span>(num);<span class="comment">//重新指定容器的长度为num，</span></span><br><span class="line">若容器变长，则以默认值填充新位置。</span><br><span class="line">如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line"><span class="built_in">resize</span>(num, elem);<span class="comment">//重新指定容器的长度为num，</span></span><br><span class="line">若容器变长，则以elem值填充新位置。</span><br><span class="line">如果容器变短，则末尾超出容器长度的元素被删除。</span><br></pre></td></tr></table></figure>
<h5 id="插入删除-3">插入删除</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(elem);<span class="comment">//在容器尾部加入一个元素</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除容器中最后一个元素</span></span><br><span class="line"><span class="built_in">push_front</span>(elem);<span class="comment">//在容器开头插入一个元素</span></span><br><span class="line"><span class="built_in">pop_front</span>();<span class="comment">//从容器开头移除第一个元素</span></span><br><span class="line"><span class="built_in">insert</span>(pos,elem);<span class="comment">//在pos位置插elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,n,elem);<span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,beg,end);<span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//移除容器的所有数据</span></span><br><span class="line"><span class="built_in">erase</span>(beg,end);<span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="built_in">remove</span>(elem);<span class="comment">//删除容器中所有与elem值匹配的元素。</span></span><br></pre></td></tr></table></figure>
<h5 id="数据存取-4">数据存取</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个元素。</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个元素。</span></span><br></pre></td></tr></table></figure>
<h5 id="反转排序">反转排序</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reverse</span>();<span class="comment">//反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。</span></span><br><span class="line"><span class="built_in">sort</span>(); <span class="comment">//list排序</span></span><br></pre></td></tr></table></figure>
<h4 id="set-multiset容器">set/multiset容器</h4>
<h5 id="构造函数-6">构造函数</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;T&gt; st;<span class="comment">//set默认构造函数：</span></span><br><span class="line">mulitset&lt;T&gt; mst; <span class="comment">//multiset默认构造函数: </span></span><br><span class="line"><span class="built_in">set</span>(<span class="type">const</span> set &amp;st);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<h5 id="赋值操作-6">赋值操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&amp; <span class="keyword">operator</span>=(<span class="type">const</span> set &amp;st);<span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="built_in">swap</span>(st);<span class="comment">//交换两个集合容器</span></span><br></pre></td></tr></table></figure>
<h5 id="大小操作-6">大小操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&amp; <span class="keyword">operator</span>=(<span class="type">const</span> set &amp;st);<span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="built_in">swap</span>(st);<span class="comment">//交换两个集合容器</span></span><br></pre></td></tr></table></figure>
<h5 id="插入删除-4">插入删除</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">insert</span>(elem);<span class="comment">//在容器中插入元素。</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//清除所有元素</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">erase</span>(beg, end);<span class="comment">//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">erase</span>(elem);<span class="comment">//删除容器中值为elem的元素。</span></span><br></pre></td></tr></table></figure>
<h5 id="查找操作">查找操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span>(key);<span class="comment">//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</span></span><br><span class="line"><span class="built_in">count</span>(key);<span class="comment">//查找键key的元素个数</span></span><br><span class="line"><span class="built_in">lower_bound</span>(keyElem);<span class="comment">//返回第一个key&gt;=keyElem元素的迭代器。</span></span><br><span class="line"><span class="built_in">upper_bound</span>(keyElem);<span class="comment">//返回第一个key&gt;keyElem元素的迭代器。</span></span><br><span class="line"><span class="built_in">equal_range</span>(keyElem);<span class="comment">//返回容器中key与keyElem相等的上下限的两个迭代器。</span></span><br></pre></td></tr></table></figure>
<h5 id="对组（pair）">对组（pair）</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种方法创建一个对组</span></span><br><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">pair1</span><span class="params">(string(<span class="string">&quot;name&quot;</span>), <span class="number">20</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; pair1.first &lt;&lt; endl; <span class="comment">//访问pair第一个值</span></span><br><span class="line">cout &lt;&lt; pair1.second &lt;&lt; endl;<span class="comment">//访问pair第二个值</span></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; pair2 = <span class="built_in">make_pair</span>(<span class="string">&quot;name&quot;</span>, <span class="number">30</span>);</span><br><span class="line">cout &lt;&lt; pair2.first &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pair2.second &lt;&lt; endl;</span><br><span class="line"><span class="comment">//pair=赋值</span></span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; pair3 = pair2;</span><br><span class="line">cout &lt;&lt; pair3.first &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pair3.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h4 id="map-multimap">map/multimap</h4>
<h5 id="构造函数-7">构造函数</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;T1, T2&gt; mapTT;<span class="comment">//map默认构造函数: </span></span><br><span class="line"><span class="built_in">map</span>(<span class="type">const</span> map &amp;mp);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<h5 id="赋值操作-7">赋值操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&amp; <span class="keyword">operator</span>=(<span class="type">const</span> map &amp;mp);<span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="built_in">swap</span>(mp);<span class="comment">//交换两个集合容器</span></span><br></pre></td></tr></table></figure>
<h5 id="大小操作-7">大小操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">size</span>();<span class="comment">//返回容器中元素的数目</span></span><br><span class="line"><span class="built_in">empty</span>();<span class="comment">//判断容器是否为空</span></span><br></pre></td></tr></table></figure>
<h5 id="插入删除-5">插入删除</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map.<span class="built_in">insert</span>(...); <span class="comment">//往容器插入元素，返回pair&lt;iterator,bool&gt;</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; mapStu;</span><br><span class="line"><span class="comment">// 第一种 通过pair的方式插入对象</span></span><br><span class="line">mapStu.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;小张&quot;</span>));</span><br><span class="line"><span class="comment">// 第二种 通过pair的方式插入对象</span></span><br><span class="line">mapStu.<span class="built_in">inset</span>(<span class="built_in">make_pair</span>(<span class="number">-1</span>, <span class="string">&quot;校长&quot;</span>));</span><br><span class="line"><span class="comment">// 第三种 通过value_type的方式插入对象</span></span><br><span class="line">mapStu.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span>(<span class="number">1</span>, <span class="string">&quot;小李&quot;</span>));</span><br><span class="line"><span class="comment">// 第四种 通过数组的方式插入值</span></span><br><span class="line">mapStu[<span class="number">3</span>] = <span class="string">&quot;小刘&quot;</span>;</span><br><span class="line">mapStu[<span class="number">5</span>] = <span class="string">&quot;小王&quot;</span>;</span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//删除所有元素</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">erase</span>(beg,end);<span class="comment">//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">erase</span>(keyElem);<span class="comment">//删除容器中key为keyElem的对组。</span></span><br></pre></td></tr></table></figure>
<h5 id="查找操作-2">查找操作</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span>(key);<span class="comment">//查找键key是否存在,若存在，返回该键的元素的迭代器；/若不存在，返回map.end();</span></span><br><span class="line"><span class="built_in">count</span>(keyElem);<span class="comment">//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</span></span><br><span class="line"><span class="built_in">lower_bound</span>(keyElem);<span class="comment">//返回第一个key&gt;=keyElem元素的迭代器。</span></span><br><span class="line"><span class="built_in">upper_bound</span>(keyElem);<span class="comment">//返回第一个key&gt;keyElem元素的迭代器。</span></span><br><span class="line"><span class="built_in">equal_range</span>(keyElem);<span class="comment">//返回容器中key与keyElem相等的上下限的两个迭代器。</span></span><br></pre></td></tr></table></figure>
<h4 id=""></h4>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>c++关键字</title>
    <url>/2024/06/23/c-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="概述：">概述：</h3>
<p>C++ 是一种广泛使用的、通用的、面向对象的编程语言，它支持过程化编程、数据抽象、面向对象编程和泛型编程等多种编程范式。C++ 是在 C 语言的基础上发展起来的，它增加了许多新的特性，如类、继承、多态、模板、异常处理、命名空间等。</p>
<p>以下是 C++ 的一些基本特点：</p>
<table>
<thead>
<tr>
<th style="text-align:left">特点</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">面向对象</td>
<td style="text-align:left">C++ 支持面向对象编程（OOP），通过类（class）和对象（object）的概念。</td>
</tr>
<tr>
<td style="text-align:left">继承</td>
<td style="text-align:left">一个类可以从另一个类继承，从而重用代码并扩展功能。</td>
</tr>
<tr>
<td style="text-align:left">多态</td>
<td style="text-align:left">通过虚函数（virtual functions）和继承，C++ 支持运行时多态，允许不同的对象对同一消息做出不同的响应。</td>
</tr>
<tr>
<td style="text-align:left">模板</td>
<td style="text-align:left">C++ 提供了模板（templates），允许程序员编写适用于多种数据类型的通用代码。</td>
</tr>
<tr>
<td style="text-align:left">异常处理</td>
<td style="text-align:left">C++ 引入了异常处理机制，用于处理程序运行时的错误情况。</td>
</tr>
<tr>
<td style="text-align:left">命名空间</td>
<td style="text-align:left">C++ 支持命名空间（namespaces），用于避免名称冲突和组织代码。</td>
</tr>
<tr>
<td style="text-align:left">标准库</td>
<td style="text-align:left">C++ 标准库提供了大量的函数和类，用于处理常见的编程任务，如字符串处理、文件操作、内存管理等。</td>
</tr>
<tr>
<td style="text-align:left">与C语言兼容</td>
<td style="text-align:left">C++ 是 C 语言的超集，这意味着任何有效的 C 程序也是有效的 C++ 程序（但可能不是最优的 C++ 程序）。</td>
</tr>
</tbody>
</table>
<p>以下是一个简单的 C++ 程序示例，用于输出 “Hello, World!”：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该示例中，<code>#include &lt;iostream&gt;</code> 指令告诉编译器包含标准输入输出流库。<code>int main()</code> 是程序的入口点。<code>std::cout</code> 是一个输出流对象，用于将文本发送到标准输出（通常是屏幕）。<code>&lt;&lt;</code> 是一个插入运算符，用于将数据插入到输出流中。<code>std::endl</code> 是一个操纵符，用于在输出中插入一个新行。最后，<code>return 0;</code> 表示程序正常退出。</p>
<h3 id="对C的扩充：">对C的扩充：</h3>
<p>下面是一个简化的表格，展示了C++在非面向对象方面对C语言的主要扩充点：</p>
<table>
<thead>
<tr>
<th style="text-align:left">扩充点</th>
<th>C++特性</th>
<th>C语言对应/比较</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">类型安全性</td>
<td>强类型检查</td>
<td>弱类型检查，依赖程序员注意</td>
</tr>
<tr>
<td style="text-align:left">输入输出流</td>
<td><code>iostream</code>库</td>
<td>标准I/O库（如<code>stdio.h</code>）</td>
</tr>
<tr>
<td style="text-align:left">内存管理</td>
<td><code>new</code>和<code>delete</code></td>
<td><code>malloc</code>和<code>free</code></td>
</tr>
<tr>
<td style="text-align:left">引用（Reference）</td>
<td>变量别名</td>
<td>指针操作</td>
</tr>
<tr>
<td style="text-align:left">函数重载</td>
<td>允许同名不同参数函数</td>
<td>不支持</td>
</tr>
<tr>
<td style="text-align:left">缺省参数</td>
<td>允许函数参数有默认值</td>
<td>不支持</td>
</tr>
<tr>
<td style="text-align:left">内联函数</td>
<td>提高函数调用效率</td>
<td>无直接对应</td>
</tr>
<tr>
<td style="text-align:left">命名空间</td>
<td>组织代码，避免命名冲突</td>
<td>全局作用域，可能导致冲突</td>
</tr>
<tr>
<td style="text-align:left">运算符重载</td>
<td>允许重载运算符</td>
<td>不支持</td>
</tr>
<tr>
<td style="text-align:left">条件编译</td>
<td><code>#ifdef</code>, <code>#ifndef</code>等</td>
<td><code>#if</code>, <code>#else</code>, <code>#endif</code></td>
</tr>
<tr>
<td style="text-align:left">宏定义</td>
<td><code>#define</code></td>
<td><code>#define</code></td>
</tr>
<tr>
<td style="text-align:left">预处理撤销</td>
<td><code>#undef</code></td>
<td>无直接对应</td>
</tr>
<tr>
<td style="text-align:left">模板（Templates）</td>
<td>泛型编程</td>
<td>无直接对应</td>
</tr>
<tr>
<td style="text-align:left">异常处理</td>
<td><code>try</code>, <code>catch</code>, <code>throw</code></td>
<td>无直接对应，使用错误码</td>
</tr>
</tbody>
</table>
<p>C++的关键字是编程语言中预先保留的标识符，用于定义语言的结构和语法。在C++中，这些关键字不能被用作变量名、函数名或其他标识符的名称。以下是C++（不包括C++11新增的关键字）中的一部分主要关键字，按照不同的功能分类进行简述：</p>
<h3 id="数据类型关键字">数据类型关键字:</h3>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>布尔类型，用于表示逻辑值（true或false）</td>
</tr>
<tr>
<td>char</td>
<td>字符类型，用于存储字符值</td>
</tr>
<tr>
<td>int</td>
<td>整型，用于存储整数</td>
</tr>
<tr>
<td>float、double、long double</td>
<td>浮点型，用于存储小数</td>
</tr>
<tr>
<td>signed、unsigned</td>
<td>用于指定整数类型是有符号还是无符号的</td>
</tr>
<tr>
<td>short、long</td>
<td>用于指定整数类型的长度</td>
</tr>
<tr>
<td>void</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>复合数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>class</td>
<td>用于定义类</td>
</tr>
<tr>
<td>struct</td>
<td>用于定义结构体</td>
</tr>
<tr>
<td>union</td>
<td>用于定义联合体</td>
</tr>
<tr>
<td>enum</td>
<td>用于定义枚举类型</td>
</tr>
</tbody>
</table>
<h3 id="控制语句关键字">控制语句关键字:</h3>
<table>
<thead>
<tr>
<th>循环语句</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>for</td>
<td>用于执行固定次数的循环</td>
</tr>
<tr>
<td>while</td>
<td>用于在条件为真时重复执行代码块</td>
</tr>
<tr>
<td>do…while</td>
<td>与<code>while</code>类似，但循环体至少会执行一次</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>条件语句</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>if</td>
<td>用于根据条件执行不同的代码块</td>
</tr>
<tr>
<td>else</td>
<td>与<code>if</code>一起使用，用于指定条件为假时执行的代码块</td>
</tr>
<tr>
<td>switch</td>
<td>用于根据表达式的值选择不同的代码块执行</td>
</tr>
<tr>
<td>case</td>
<td>与<code>switch</code>一起使用，用于指定表达式可能的值</td>
</tr>
<tr>
<td>default</td>
<td>与<code>switch</code>一起使用，用于指定表达式不匹配任何<code>case</code>时执行的代码块</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>跳转语句</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>break</td>
<td>用于跳出当前循环或<code>switch</code>语句</td>
</tr>
<tr>
<td>continue</td>
<td>用于跳过当前循环的剩余部分，直接进入下一次循环</td>
</tr>
<tr>
<td>goto</td>
<td>无条件跳转到指定的标签位置（在现代编程中很少使用）</td>
</tr>
<tr>
<td>return</td>
<td>用于从函数中返回值并结束函数执行</td>
</tr>
</tbody>
</table>
<h3 id="存储类型关键字">存储类型关键字:</h3>
<table>
<thead>
<tr>
<th>存储关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>auto</td>
<td>尽管在C++11中有更多用途，但在C++98/03中主要用于自动存储期变量的声明</td>
</tr>
<tr>
<td>extern</td>
<td>用于声明在其他文件中定义的变量或函数</td>
</tr>
<tr>
<td>register</td>
<td>建议编译器将变量存储在寄存器中（但现代编译器通常忽略此建议）</td>
</tr>
<tr>
<td>static</td>
<td>用于声明静态变量或静态成员函数</td>
</tr>
</tbody>
</table>
<h3 id="其他关键字">其他关键字:</h3>
<table>
<thead>
<tr>
<th>另外的常用关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sizeof</td>
<td>用于计算数据类型或变量的大小（以字节为单位）</td>
</tr>
<tr>
<td>typedef</td>
<td>用于为数据类型定义别名</td>
</tr>
<tr>
<td>volatile</td>
<td>用于修饰变量，表示该变量可能在程序外部被意外地改变（如多线程或硬件操作）</td>
</tr>
<tr>
<td>namespace</td>
<td>用于定义命名空间，以避免命名冲突</td>
</tr>
<tr>
<td>using</td>
<td>用于在当前作用域中引入命名空间中的名称</td>
</tr>
<tr>
<td>friend</td>
<td>用于声明友元函数或友元类，它们可以访问类的私有和保护成员</td>
</tr>
<tr>
<td>explicit</td>
<td>用于防止类构造函数被用于隐式类型转换</td>
</tr>
<tr>
<td>mutable</td>
<td>用于修饰类的非静态成员变量，即使在<code>const</code>成员函数中也可以修改它</td>
</tr>
</tbody>
</table>
<h3 id="c-11新引入：">c++11新引入：</h3>
<table>
<thead>
<tr>
<th>关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>alignas</code></td>
<td>用于指定变量或类型的对齐要求</td>
</tr>
<tr>
<td><code>alignof</code></td>
<td>用于获取变量或类型的对齐要求</td>
</tr>
<tr>
<td><code>char16_t</code></td>
<td>16位字符类型</td>
</tr>
<tr>
<td><code>char32_t</code></td>
<td>32位字符类型</td>
</tr>
<tr>
<td><code>constexpr</code></td>
<td>声明编译时常量表达式</td>
</tr>
<tr>
<td><code>decltype</code></td>
<td>用于类型推导，返回表达式的类型</td>
</tr>
<tr>
<td><code>final</code></td>
<td>禁止类被继承，或禁止虚函数被重写</td>
</tr>
<tr>
<td><code>noexcept</code></td>
<td>指定函数不会抛出异常</td>
</tr>
<tr>
<td><code>nullptr</code></td>
<td>表示空指针常量</td>
</tr>
<tr>
<td><code>override</code></td>
<td>检查子类虚函数是否重写了某个基类虚函数</td>
</tr>
<tr>
<td><code>static_assert</code></td>
<td>在编译时进行断言</td>
</tr>
<tr>
<td><code>thread_local</code></td>
<td>声明变量的线程局部存储期</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Per_FedAVG源码分析</title>
    <url>/2024/06/27/Per-FedAVG%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="Per-FeAVG源码分析——根目录下：">Per_FeAVG源码分析——根目录下：</h3>
<p>KarhouTam的Per_FedAVG.源码链接：<a href="https://github.com/KarhouTam/Per-FedAvg">请使用到的点个star</a></p>
<h4 id="utils-py"><a href="http://utils.py">utils.py</a></h4>
<h5 id="函数：get-args（）">函数：get_args（）</h5>
<p>功能：用于加载参数:使用ArgumentParser()输入了<strong>联邦参数</strong>，<strong>模型参数</strong>，<strong>其他参数</strong>三类参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Iterator, <span class="type">Tuple</span>, <span class="type">Union</span></span><br><span class="line"><span class="keyword">from</span> argparse <span class="keyword">import</span> ArgumentParser</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_args</span>():</span><br><span class="line">    parser = ArgumentParser()</span><br><span class="line">    <span class="comment">##‘--alpha’表示参数名称，type代表参数类型，default代表默认值设置，help则是对alpha的描述性解释。</span></span><br><span class="line">    parser.add_argument(<span class="string">&quot;--alpha&quot;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">1e-2</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--beta&quot;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">1e-3</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--global_epochs&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">200</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--local_epochs&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">4</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--pers_epochs&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        default=<span class="number">1</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Indicate how many data batches would be used for personalization. Negatives means that equal to train phase.&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--hf&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        default=<span class="number">0</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;0 for performing Per-FedAvg(FO), others for Per-FedAvg(HF)&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--batch_size&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">40</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--valset_ratio&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">float</span>,</span><br><span class="line">        default=<span class="number">0.1</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Proportion of val set in the entire client local dataset&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--dataset&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, choices=[<span class="string">&quot;mnist&quot;</span>, <span class="string">&quot;cifar&quot;</span>], default=<span class="string">&quot;mnist&quot;</span></span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--client_num_per_round&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">10</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--seed&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">17</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--gpu&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        default=<span class="number">1</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Non-zero value for using gpu, 0 for using cpu&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--eval_while_training&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        default=<span class="number">1</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Non-zero value for performing local evaluation before and after local training&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--log&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> parser.parse_args() <span class="comment">#解析了命令行参数，并将解析结果作为函数的返回值，以便在其他地方可以使用参数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="函数：eval（）">函数：eval（）</h5>
<p>功能：用于在PyTorch中评估给定模型的性能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@torch.no_grad() </span><span class="comment">#这个装饰器确保在评估模型时不会计算梯度，从而节省内存和计算资源。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eval</span>(<span class="params"></span></span><br><span class="line"><span class="params">    model: torch.nn.Module,<span class="comment">#评价的模型</span></span></span><br><span class="line"><span class="params">    dataloader: torch.utils.data.DataLoader,<span class="comment">#数据集加载器</span></span></span><br><span class="line"><span class="params">    criterion: <span class="type">Union</span>[torch.nn.MSELoss, torch.nn.CrossEntropyLoss],<span class="comment">#损失函数，可以是均方误差（MSE）或交叉熵损失。</span></span></span><br><span class="line"><span class="params">    device=torch.device(<span class="params"><span class="string">&quot;cpu&quot;</span></span>),<span class="comment">#用于运行模型的设备（默认为cpu）</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="type">Tuple</span>[torch.Tensor, torch.Tensor]:</span><br><span class="line">    <span class="comment">#将模型设置为评估模式，确保如Dropout或BatchNorm这样的层在评估时以不同的方式工作。</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    total_loss = <span class="number">0</span></span><br><span class="line">    num_samples = <span class="number">0</span></span><br><span class="line">    acc = <span class="number">0</span></span><br><span class="line">    <span class="comment">#对于数据加载器中的每一批数据，计算损失和准确率。</span></span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> dataloader:</span><br><span class="line">        x, y = x.to(device), y.to(device)</span><br><span class="line">        logit = model(x)</span><br><span class="line">        <span class="comment"># total_loss += criterion(logit, y) / y.size(-1)</span></span><br><span class="line">        total_loss += criterion(logit, y) <span class="comment">#使用给定的损失函数计算预测（logit）和真实标签（y）之间的损失。</span></span><br><span class="line">        pred = torch.softmax(logit, -<span class="number">1</span>).argmax(-<span class="number">1</span>)<span class="comment">#使用 torch.softmax 和 argmax 获取预测的类别索引，然后与真实标签比较，统计正确的预测。</span></span><br><span class="line">        acc += torch.eq(pred, y).<span class="built_in">int</span>().<span class="built_in">sum</span>()</span><br><span class="line">        num_samples += y.size(-<span class="number">1</span>)</span><br><span class="line">    model.train()<span class="comment">#在评估结束后将模型重置为训练模式，尽管这通常不是必需的，因为下一个使用模型的操作可能会自动设置它。</span></span><br><span class="line">    <span class="keyword">return</span> total_loss, acc / num_samples</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="函数：fix-random-seed-seed-int">函数：fix_random_seed(seed: int)</h5>
<p>作用：设置随机种子以确保结果的可复现性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fix_random_seed</span>(<span class="params">seed: <span class="built_in">int</span></span>):</span><br><span class="line">    torch.cuda.empty_cache()<span class="comment">#这个函数会清空CUDA缓存。</span></span><br><span class="line">    torch.manual_seed(seed)</span><br><span class="line">    torch.cuda.manual_seed(seed)<span class="comment">#这分别设置CPU和GPU上的随机种子，以确保PyTorch操作的随机性是可复现的。这是正确的。</span></span><br><span class="line">    random.seed(seed)</span><br><span class="line">    np.random.seed(seed)<span class="comment">#这两个函数分别设置Python标准库中的random模块和NumPy库中的随机数生成器的种子。这也是为了确保其他库中的随机操作是可复现的。</span></span><br><span class="line">    torch.backends.cudnn.deterministic = <span class="literal">True</span><span class="comment">#当你设置deterministic=True时，你告诉cuDNN（CUDA Deep Neural Network library）在卷积操作中使用确定性的算法，而不是可能更快但不太确定的算法。这有助于确保即使在GPU上，结果也是可复现的。</span></span><br><span class="line">    torch.backends.cudnn.benchmark = <span class="literal">True</span><span class="comment">#这个设置告诉cuDNN为特定的配置自动寻找最快的卷积算法。但是，当benchmark=True时，cuDNN会尝试不同的算法并保留最佳的一个，这可能会导致结果不可复现，因为每次运行都可能选择不同的算法。</span></span><br></pre></td></tr></table></figure>
<h4 id="model-py"><a href="http://model.py">model.py</a></h4>
<h5 id="函数：elu-nn-Module">函数：elu(nn.Module)</h5>
<p>作用：它实现了指数线性单元（Exponential Linear Unit, ELU）激活函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">elu</span>(nn.Module):<span class="comment">#继承自nn.Module的类elu。</span></span><br><span class="line">    <span class="comment">#调用了父类nn.Module的__init__方法来确保基类的初始化。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>(elu, self).__init__()</span><br><span class="line">	<span class="comment">#实现了ELU激活函数。对于输入x，如果x大于或等于0，则返回x本身；否则，返回0.2 * (torch.exp(x) - 1)。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> torch.where(x &gt;= <span class="number">0</span>, x, <span class="number">0.2</span> * (torch.exp(x) - <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h5 id="类：linear-nn-Module">类：linear(nn.Module)</h5>
<p>作用：<code>__init__</code>方法用于初始化权重（<code>w</code>）和偏置（<code>b</code>），而<code>forward</code>方法定义了数据通过网络层的前向传播过程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">linear</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_c, out_c</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>(linear, self).__init__()</span><br><span class="line">        <span class="comment">#使用了torch.randn(out_c, in_c) * torch.sqrt(torch.tensor(2 / in_c))来初始化权重，这是He初始化（也称为Kaiming初始化）的一个变种，它通常用于ReLU或其变种激活函数。</span></span><br><span class="line">        self.w = nn.Parameter(</span><br><span class="line">            torch.randn(out_c, in_c) * torch.sqrt(torch.tensor(<span class="number">2</span> / in_c))</span><br><span class="line">        )</span><br><span class="line">        self.b = nn.Parameter(torch.randn(out_c))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> F.linear(x, self.w, self.b)</span><br></pre></td></tr></table></figure>
<h5 id="类：MLP-MNIST">类：MLP_MNIST</h5>
<p>作用：构建不同类型的神经网络模型，分别是MLP（多层感知机）、CNNMnist（用于MNIST手写数字数据集的卷积神经网络）和CNNCifar（用于CIFAR-10数据集的卷积神经网络）。实现了神经网络的前向传播过程，并用于分类任务。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MLP_MNIST</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>(MLP_MNIST, self).__init__()</span><br><span class="line">        self.fc1 = linear(<span class="number">28</span> * <span class="number">28</span>, <span class="number">80</span>)</span><br><span class="line">        self.fc2 = linear(<span class="number">80</span>, <span class="number">60</span>)</span><br><span class="line">        self.fc3 = linear(<span class="number">60</span>, <span class="number">10</span>)</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">        self.activation = elu()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.flatten(x)</span><br><span class="line"></span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = self.activation(x)</span><br><span class="line"></span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        x = self.activation(x)</span><br><span class="line"></span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        x = self.activation(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MLP_CIFAR10</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>(MLP_CIFAR10, self).__init__()</span><br><span class="line">        self.fc1 = linear(<span class="number">32</span> * <span class="number">32</span> * <span class="number">3</span>, <span class="number">80</span>)</span><br><span class="line">        self.fc2 = linear(<span class="number">80</span>, <span class="number">60</span>)</span><br><span class="line">        self.fc3 = linear(<span class="number">60</span>, <span class="number">10</span>)</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">        self.activation = elu()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.flatten(x)</span><br><span class="line"></span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = self.activation(x)</span><br><span class="line"></span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        x = self.activation(x)</span><br><span class="line"></span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        x = self.activation(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h5 id="类：MLP-CIFAR10">类：MLP_CIFAR10</h5>
<p>作用：构建不同类型的神经网络模型，分别是MLP（多层感知机）、CNNMnist（用于MNIST手写数字数据集的卷积神经网络）和CNNCifar（用于CIFAR-10数据集的卷积神经网络）。实现了神经网络的前向传播过程，并用于分类任务。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MLP_CIFAR10</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>(MLP_CIFAR10, self).__init__()</span><br><span class="line">        self.fc1 = linear(<span class="number">32</span> * <span class="number">32</span> * <span class="number">3</span>, <span class="number">80</span>)</span><br><span class="line">        self.fc2 = linear(<span class="number">80</span>, <span class="number">60</span>)</span><br><span class="line">        self.fc3 = linear(<span class="number">60</span>, <span class="number">10</span>)</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">        self.activation = elu()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.flatten(x)</span><br><span class="line"></span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = self.activation(x)</span><br><span class="line"></span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        x = self.activation(x)</span><br><span class="line"></span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        x = self.activation(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h5 id="字典：MODEL-DICT">字典：MODEL_DICT</h5>
<p>作用：关联键<code>&quot;mnist&quot;</code>和<code>&quot;cifar&quot;</code>到它们各自的多层感知机（MLP）模型类<code>MLP_MNIST</code>和<code>MLP_CIFAR10</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MODEL_DICT = &#123;<span class="string">&quot;mnist&quot;</span>: MLP_MNIST, <span class="string">&quot;cifar&quot;</span>: MLP_CIFAR10&#125;</span><br></pre></td></tr></table></figure>
<h5 id="函数：get-model-dataset-device">函数：get_model(dataset, device)</h5>
<p>作用：根据数据集名称从<code>MODEL_DICT</code>字典中获取相应的模型类，并实例化模型，然后将模型移动到指定的设备上（CPU或GPU）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_model</span>(<span class="params">dataset, device</span>):</span><br><span class="line">    <span class="keyword">return</span> MODEL_DICT[dataset]().to(device)</span><br></pre></td></tr></table></figure>
<h4 id="perfedavg-py"><a href="http://perfedavg.py">perfedavg.py</a></h4>
<h5 id="函数：init">函数：<strong>init</strong>()</h5>
<p>作用：类的初始化方法，用于配置和初始化类的实例变量。该方法接收多个参数，包括客户端ID、学习率参数（alpha和beta，可能是某种优化算法中的参数，如Momentum或Adam中的beta1和beta2）、全局模型、损失函数、批量大小、数据集名称、本地训练轮数、验证集比例、日志记录器和GPU设备ID。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">    self,</span></span><br><span class="line"><span class="params">    client_id: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">    alpha: <span class="built_in">float</span>,</span></span><br><span class="line"><span class="params">    beta: <span class="built_in">float</span>,</span></span><br><span class="line"><span class="params">    global_model: torch.nn.Module,</span></span><br><span class="line"><span class="params">    criterion: <span class="type">Union</span>[torch.nn.CrossEntropyLoss, torch.nn.MSELoss],</span></span><br><span class="line"><span class="params">    batch_size: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">    dataset: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    local_epochs: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">    valset_ratio: <span class="built_in">float</span>,</span></span><br><span class="line"><span class="params">    logger: rich.console.Console,</span></span><br><span class="line"><span class="params">    gpu: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="comment">#设备选择：根据传入的gpu参数和torch.cuda.is_available()的结果，选择使用CPU还是GPU进行计算。</span></span><br><span class="line">    <span class="keyword">if</span> gpu <span class="keyword">and</span> torch.cuda.is_available():</span><br><span class="line">        self.device = torch.device(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.device = torch.device(<span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">    <span class="comment">#日志记录器：将传入的logger实例保存在类的实例变量中，以便在类的其他方法中使用。</span></span><br><span class="line">    self.logger = logger</span><br><span class="line">	<span class="comment">#本地训练参数：保存了本地训练轮数（local_epochs）和损失函数（criterion）。</span></span><br><span class="line">    self.local_epochs = local_epochs</span><br><span class="line">    self.criterion = criterion</span><br><span class="line">    <span class="comment">#客户端ID和模型：保存了客户端ID（client_id）和全局模型的深拷贝（global_model）。</span></span><br><span class="line">    self.<span class="built_in">id</span> = client_id</span><br><span class="line">    self.model = deepcopy(global_model)</span><br><span class="line">    <span class="comment">#学习率参数：保存了alpha和beta参数，这些参数可能是优化算法的一部分。</span></span><br><span class="line">    self.alpha = alpha</span><br><span class="line">    self.beta = beta</span><br><span class="line">    <span class="comment">#数据加载器：调用get_dataloader函数来获取训练和验证的数据加载器（trainloader和valloader）。这个函数根据数据集名称、客户端ID、批量大小和验证集比例来返回相应的数据加载器。</span></span><br><span class="line">    self.trainloader, self.valloader = get_dataloader(</span><br><span class="line">        dataset, client_id, batch_size, valset_ratio</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">#迭代训练加载器：将训练数据加载器转换为迭代器并保存在iter_trainloader中。这样做可能是为了在类的其他方法中方便地从训练集中获取批量数据。</span></span><br><span class="line">    self.iter_trainloader = <span class="built_in">iter</span>(self.trainloader)</span><br></pre></td></tr></table></figure>
<h5 id="函数：get-data-batch-self">函数：get_data_batch(self)</h5>
<p>作用：用于从训练数据加载器中获取下一批数据，并处理<code>StopIteration</code>异常（当迭代器耗尽时触发）。当<code>iter_trainloader</code>中的数据被完全迭代一遍后，该方法会重新初始化迭代器并获取新的数据批次。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_data_batch</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment">#尝试获取数据：try块尝试从self.iter_trainloader（一个迭代器）中获取下一批数据（x为输入数据，y为标签）</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x, y = <span class="built_in">next</span>(self.iter_trainloader)</span><br><span class="line">     <span class="comment">#异常处理：</span></span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        self.iter_trainloader = <span class="built_in">iter</span>(self.trainloader)<span class="comment">#重新初始化iter_trainloader，通过调用iter(self.trainloader)来创建一个新的迭代器。</span></span><br><span class="line">        x, y = <span class="built_in">next</span>(self.iter_trainloader)<span class="comment">#再次尝试从新的迭代器中获取下一批数据。</span></span><br><span class="line">	<span class="comment">#无论数据是直接从原始迭代器中获取，还是通过重新初始化迭代器后获取，都会将数据（x和y）移动到self.device（即CPU或GPU）上，并返回它们。</span></span><br><span class="line">    <span class="keyword">return</span> x.to(self.device), y.to(self.device)</span><br></pre></td></tr></table></figure>
<h5 id="函数：train（）">函数：train（）</h5>
<p>作用：是一个用于在本地客户端上训练模型的函数。该方法接收全局模型、一个布尔值<code>hessian_free</code>（用于指示是否使用Hessian-free优化）和一个布尔值<code>eval_while_training</code>（用于指示是否在训练前后评估模型性能）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params"></span></span><br><span class="line"><span class="params">    self,</span></span><br><span class="line"><span class="params">    global_model: torch.nn.Module,</span></span><br><span class="line"><span class="params">    hessian_free=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params">    eval_while_training=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    self.model.load_state_dict(global_model.state_dict())</span><br><span class="line">    <span class="comment">#训练前评估（可选）：如果eval_while_training为True，则在训练开始前使用utils.eval函数评估模型在验证集上的性能，并保存损失和准确率。</span></span><br><span class="line">    <span class="keyword">if</span> eval_while_training:</span><br><span class="line">        loss_before, acc_before = utils.<span class="built_in">eval</span>(</span><br><span class="line">            self.model, self.valloader, self.criterion, self.device</span><br><span class="line">        )</span><br><span class="line">    <span class="comment">#执行训练：调用_train方法</span></span><br><span class="line">    self._train(hessian_free)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">#训练后评估（可选）：如果eval_while_training为True，则在训练结束后再次使用utils.eval函数评估模型在验证集上的性能，并保存损失和准确率。</span></span><br><span class="line">    <span class="keyword">if</span> eval_while_training:</span><br><span class="line">        loss_after, acc_after = utils.<span class="built_in">eval</span>(</span><br><span class="line">            self.model, self.valloader, self.criterion, self.device</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">#记录并返回模型：使用self.logger记录训练前后的损失和准确率变化。然后，使用SerializationTool.serialize_model方法将训练后的模型序列化为某种格式，并返回该序列化模型。</span></span><br><span class="line">        self.logger.log(</span><br><span class="line">            <span class="string">&quot;client [&#123;&#125;] [red]loss: &#123;:.4f&#125; -&gt; &#123;:.4f&#125;   [blue]acc: &#123;:.2f&#125;% -&gt; &#123;:.2f&#125;%&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                self.<span class="built_in">id</span>,</span><br><span class="line">                loss_before,</span><br><span class="line">                loss_after,</span><br><span class="line">                acc_before * <span class="number">100.0</span>,</span><br><span class="line">                acc_after * <span class="number">100.0</span>,</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> SerializationTool.serialize_model(self.model)</span><br></pre></td></tr></table></figure>
<h5 id="函数：-train">函数：_train()</h5>
<p>作用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_train</span>(<span class="params">self, hessian_free=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="comment">#使用Hessian-free方法的Per-FedAvg（HF）</span></span><br><span class="line">    <span class="comment">#当hessian_free为True时，该方法将执行Hessian-free的Per-FedAvg训练过程。这通常涉及计算二阶导数（Hessian）的近似，以优化模型参数。</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">if</span> hessian_free:  <span class="comment"># Per-FedAvg(HF)</span></span><br><span class="line">        <span class="comment">#对于每个本地训练周期（self.local_epochs），首先复制当前模型（self.model）到一个临时模型（temp_model）中。</span></span><br><span class="line">        <span class="comment">#使用get_data_batch方法获取第一批数据（data_batch_1），并计算关于临时模型的一阶梯度（grads）。</span></span><br><span class="line">        <span class="comment">#使用这些梯度来更新临时模型的参数（这里使用了简单的SGD更新，但学习率self.alpha可能需要根据实际情况调整）。</span></span><br><span class="line">        <span class="comment">#接着，获取第二批数据（data_batch_2），并再次计算关于临时模型的一阶梯度（grads_1st）。</span></span><br><span class="line">        <span class="comment">#然后，获取第三批数据（data_batch_3），但这次计算的是关于原始模型（self.model）的二阶梯度（Hessian向量积，即grads_2nd）。注意，这里的计算可能需要特定的函数或库，因为直接计算完整的Hessian矩阵是计算密集且不可行的。</span></span><br><span class="line">        <span class="comment">#最后，使用这些一阶梯度和二阶梯度来更新原始模型的参数。更新规则似乎结合了梯度下降和二阶优化方法（具体是哪种方法取决于self.beta和self.alpha的值）。</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.local_epochs):</span><br><span class="line">            temp_model = deepcopy(self.model)</span><br><span class="line">            data_batch_1 = self.get_data_batch()</span><br><span class="line">            grads = self.compute_grad(temp_model, data_batch_1)</span><br><span class="line">            <span class="keyword">for</span> param, grad <span class="keyword">in</span> <span class="built_in">zip</span>(temp_model.parameters(), grads):</span><br><span class="line">                param.data.sub_(self.alpha * grad)</span><br><span class="line"></span><br><span class="line">            data_batch_2 = self.get_data_batch()</span><br><span class="line">            grads_1st = self.compute_grad(temp_model, data_batch_2)</span><br><span class="line"></span><br><span class="line">            data_batch_3 = self.get_data_batch()</span><br><span class="line"></span><br><span class="line">            grads_2nd = self.compute_grad(</span><br><span class="line">                self.model, data_batch_3, v=grads_1st, second_order_grads=<span class="literal">True</span></span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># <span class="doctag">NOTE:</span> Go check https://github.com/KarhouTam/Per-FedAvg/issues/2 if you confuse about the model update.</span></span><br><span class="line">            <span class="keyword">for</span> param, grad1, grad2 <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">                self.model.parameters(), grads_1st, grads_2nd</span><br><span class="line">            ):</span><br><span class="line">                param.data.sub_(self.beta * grad1 - self.beta * self.alpha * grad2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># Per-FedAvg(FO）</span></span><br><span class="line">        	<span class="comment">#只使用一阶梯度的Per-FedAvg（FO）</span></span><br><span class="line">            <span class="comment">#首先在一个临时模型（temp_model）上计算第一个数据批次（data_batch_1）的梯度，并更新临时模型的参数。</span></span><br><span class="line">            <span class="comment">#然后，它获取第二个数据批次（data_batch_2）并计算梯度，但这次它直接在原始模型（self.model）上应用这些梯度的更新，而不是临时模型。</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.local_epochs):</span><br><span class="line">            <span class="comment"># ========================== FedAvg ==========================</span></span><br><span class="line">            <span class="comment"># <span class="doctag">NOTE:</span> You can uncomment those codes for running FedAvg.</span></span><br><span class="line">            <span class="comment">#       When you&#x27;re trying to run FedAvg, comment other codes in this branch.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># data_batch = self.get_data_batch()</span></span><br><span class="line">            <span class="comment"># grads = self.compute_grad(self.model, data_batch)</span></span><br><span class="line">            <span class="comment"># for param, grad in zip(self.model.parameters(), grads):</span></span><br><span class="line">            <span class="comment">#     param.data.sub_(self.beta * grad)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># ============================================================</span></span><br><span class="line"></span><br><span class="line">            temp_model = deepcopy(self.model)</span><br><span class="line">            data_batch_1 = self.get_data_batch()</span><br><span class="line">            grads = self.compute_grad(temp_model, data_batch_1)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> param, grad <span class="keyword">in</span> <span class="built_in">zip</span>(temp_model.parameters(), grads):</span><br><span class="line">                param.data.sub_(self.alpha * grad)</span><br><span class="line"></span><br><span class="line">            data_batch_2 = self.get_data_batch()</span><br><span class="line">            grads = self.compute_grad(temp_model, data_batch_2)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> param, grad <span class="keyword">in</span> <span class="built_in">zip</span>(self.model.parameters(), grads):</span><br><span class="line">                param.data.sub_(self.beta * grad)</span><br></pre></td></tr></table></figure>
<h5 id="函数：compute-grad">函数：compute_grad()</h5>
<p>作用：根据给定的数据批次<code>data_batch</code>计算模型<code>model</code>的梯度。如果<code>second_order_grads</code>为<code>True</code>，它将计算二阶梯度（Hessian-vector积的一个近似），否则，它将计算标准的一阶梯度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute_grad</span>(<span class="params"></span></span><br><span class="line"><span class="params">    self,</span></span><br><span class="line"><span class="params">    model: torch.nn.Module,</span></span><br><span class="line"><span class="params">    data_batch: <span class="type">Tuple</span>[torch.Tensor, torch.Tensor],</span></span><br><span class="line"><span class="params">    v: <span class="type">Union</span>[<span class="type">Tuple</span>[torch.Tensor, ...], <span class="literal">None</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    second_order_grads=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    x, y = data_batch</span><br><span class="line">    <span class="keyword">if</span> second_order_grads:</span><br><span class="line">        frz_model_params = deepcopy(model.state_dict())</span><br><span class="line">        delta = <span class="number">1e-3</span></span><br><span class="line">        dummy_model_params_1 = OrderedDict()</span><br><span class="line">        dummy_model_params_2 = OrderedDict()</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            <span class="keyword">for</span> (layer_name, param), grad <span class="keyword">in</span> <span class="built_in">zip</span>(model.named_parameters(), v):</span><br><span class="line">                dummy_model_params_1.update(&#123;layer_name: param + delta * grad&#125;)</span><br><span class="line">                dummy_model_params_2.update(&#123;layer_name: param - delta * grad&#125;)</span><br><span class="line"></span><br><span class="line">        model.load_state_dict(dummy_model_params_1, strict=<span class="literal">False</span>)</span><br><span class="line">        logit_1 = model(x)</span><br><span class="line">        loss_1 = self.criterion(logit_1, y)</span><br><span class="line">        grads_1 = torch.autograd.grad(loss_1, model.parameters())</span><br><span class="line"></span><br><span class="line">        model.load_state_dict(dummy_model_params_2, strict=<span class="literal">False</span>)</span><br><span class="line">        logit_2 = model(x)</span><br><span class="line">        loss_2 = self.criterion(logit_2, y)</span><br><span class="line">        grads_2 = torch.autograd.grad(loss_2, model.parameters())</span><br><span class="line"></span><br><span class="line">        model.load_state_dict(frz_model_params)</span><br><span class="line"></span><br><span class="line">        grads = []</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            <span class="keyword">for</span> g1, g2 <span class="keyword">in</span> <span class="built_in">zip</span>(grads_1, grads_2):</span><br><span class="line">                grads.append((g1 - g2) / (<span class="number">2</span> * delta))</span><br><span class="line">        <span class="keyword">return</span> grads</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logit = model(x)</span><br><span class="line">        loss = self.criterion(logit, y)</span><br><span class="line">        grads = torch.autograd.grad(loss, model.parameters())</span><br><span class="line">        <span class="keyword">return</span> grads</span><br></pre></td></tr></table></figure>
<h5 id="函数：pers-N-eval">函数：pers_N_eval()</h5>
<p>作用：在给定全局模型（<code>global_model</code>）和个性化训练轮次（<code>pers_epochs</code>）之后，该函数首先加载全局模型的参数到客户端的本地模型（<code>self.model</code>），然后在本地数据集上进行训练和评估。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pers_N_eval</span>(<span class="params">self, global_model: torch.nn.Module, pers_epochs: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="comment">#加载全局模型参数：</span></span><br><span class="line">    self.model.load_state_dict(global_model.state_dict())</span><br><span class="line">	</span><br><span class="line">    <span class="comment">#评估初始模型性能：</span></span><br><span class="line">    loss_before, acc_before = utils.<span class="built_in">eval</span>(</span><br><span class="line">        self.model, self.valloader, self.criterion, self.device</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">#定义优化器：</span></span><br><span class="line">    optimizer = torch.optim.SGD(self.model.parameters(), lr=self.alpha)</span><br><span class="line">    <span class="comment">#个性化训练：这部分代码执行了 pers_epochs 轮次的个性化训练。在每次迭代中，它首先从 self.get_data_batch() 获取一个数据批次，然后使用这个数据批次来更新模型的参数。</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(pers_epochs):</span><br><span class="line">        x, y = self.get_data_batch()</span><br><span class="line">        logit = self.model(x)</span><br><span class="line">        loss = self.criterion(logit, y)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">     <span class="comment">#评估训练后的模型性能：在个性化训练完成后，再次评估模型的性能。</span></span><br><span class="line">    loss_after, acc_after = utils.<span class="built_in">eval</span>(</span><br><span class="line">        self.model, self.valloader, self.criterion, self.device</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">#记录并输出日志：使用日志记录器（self.logger）来记录训练前后的损失和准确率。这里还使用了颜色代码（如 [red] 和 [blue]），但这些可能不会在纯文本日志中显示，除非日志记录器进</span></span><br><span class="line">    self.logger.log(</span><br><span class="line">        <span class="string">&quot;client [&#123;&#125;] [red]loss: &#123;:.4f&#125; -&gt; &#123;:.4f&#125;   [blue]acc: &#123;:.2f&#125;% -&gt; &#123;:.2f&#125;%&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            self.<span class="built_in">id</span>, loss_before, loss_after, acc_before * <span class="number">100.0</span>, acc_after * <span class="number">100.0</span></span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">#返回评估结果：</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;loss_before&quot;</span>: loss_before,</span><br><span class="line">        <span class="string">&quot;acc_before&quot;</span>: acc_before,</span><br><span class="line">        <span class="string">&quot;loss_after&quot;</span>: loss_after,</span><br><span class="line">        <span class="string">&quot;acc_after&quot;</span>: acc_after,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="main-py"><a href="http://main.py">main.py</a></h4>
<p>用于启动分布式或联邦学习中的客户端或服务器进程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    </span><br><span class="line">    args = get_args()<span class="comment">#使用get_args()从命令行获取参数，并将这些参数存储在一个对象中</span></span><br><span class="line">    fix_random_seed(args.seed)<span class="comment">#用于设置随机种子，确保实验的可重复性。</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(<span class="string">&quot;./log&quot;</span>) == <span class="literal">False</span>:<span class="comment">#这行代码检查当前目录下是否存在一个名为log的目录。如果不存在，则执行下一行代码。</span></span><br><span class="line">        os.mkdir(<span class="string">&quot;./log&quot;</span>)<span class="comment">#如果log目录不存在，这行代码会创建它。os.mkdir用于创建新目录。</span></span><br><span class="line">    <span class="comment">#首先，检查args对象中是否有gpu参数且其值为True；其次，检查是否有可用的CUDA设备（即是否有NVIDIA GPU并安装了适当的CUDA和PyTorch版本）。</span></span><br><span class="line">    <span class="keyword">if</span> args.gpu <span class="keyword">and</span> torch.cuda.is_available():</span><br><span class="line">        device = torch.device(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        device = torch.device(<span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">     </span><br><span class="line">    global_model = get_model(args.dataset, device)<span class="comment">#创建了一个日志记录器对象logger</span></span><br><span class="line">    logger = Console(record=args.log)</span><br><span class="line">    logger.log(<span class="string">f&quot;Arguments:&quot;</span>, <span class="built_in">dict</span>(args._get_kwargs()))</span><br><span class="line">    clients_4_training, clients_4_eval, client_num_in_total = get_client_id_indices(</span><br><span class="line">        args.dataset</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># init clients </span></span><br><span class="line">    <span class="comment">#初始化一个客户端列表，每个客户端都是PerFedAvgClient类的实例。</span></span><br><span class="line">    clients = [</span><br><span class="line">        PerFedAvgClient(</span><br><span class="line">            client_id=client_id,</span><br><span class="line">            alpha=args.alpha,</span><br><span class="line">            beta=args.beta,</span><br><span class="line">            global_model=global_model,</span><br><span class="line">            criterion=torch.nn.CrossEntropyLoss(),</span><br><span class="line">            batch_size=args.batch_size,</span><br><span class="line">            dataset=args.dataset,</span><br><span class="line">            local_epochs=args.local_epochs,</span><br><span class="line">            valset_ratio=args.valset_ratio,</span><br><span class="line">            logger=logger,</span><br><span class="line">            gpu=args.gpu,</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">for</span> client_id <span class="keyword">in</span> <span class="built_in">range</span>(client_num_in_total)</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment"># training</span></span><br><span class="line">    <span class="comment">#开始训练过程的，并且它使用了日志记录器（logger）来输出到log。</span></span><br><span class="line">    logger.log(<span class="string">&quot;=&quot;</span> * <span class="number">20</span>, <span class="string">&quot;TRAINING&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">20</span>, style=<span class="string">&quot;bold red&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> track(			<span class="comment">#全局训练循环:</span></span><br><span class="line">        <span class="built_in">range</span>(args.global_epochs), <span class="string">&quot;Training...&quot;</span>, console=logger, disable=args.log</span><br><span class="line">    ):</span><br><span class="line">        <span class="comment"># select clients   </span></span><br><span class="line">        <span class="comment">#选择客户端:在每次全局迭代中，代码从clients_4_training中随机选择args.client_num_per_round个客户端进行本地训练。</span></span><br><span class="line">        selected_clients = random.sample(clients_4_training, args.client_num_per_round)</span><br><span class="line"></span><br><span class="line">        model_params_cache = []</span><br><span class="line">        <span class="comment"># client local training 客户端本地训练</span></span><br><span class="line">        <span class="comment">#对于选定的每个客户端，代码执行train方法。该方法以当前的全局模型作为起点，并可能在本地数据集上进行训练。train方法返回序列化后的模型参数，这些参数被添加到model_params_cache列表中。</span></span><br><span class="line">        <span class="keyword">for</span> client_id <span class="keyword">in</span> selected_clients:</span><br><span class="line">            serialized_model_params = clients[client_id].train(</span><br><span class="line">                global_model=global_model,</span><br><span class="line">                hessian_free=args.hf,</span><br><span class="line">                eval_while_training=args.eval_while_training,</span><br><span class="line">            )</span><br><span class="line">            model_params_cache.append(serialized_model_params)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># aggregate model parameters聚合模型参数:</span></span><br><span class="line">        <span class="comment">#在所有选定的客户端完成本地训练后，代码使用fedavg_aggregate函数（来聚合模型参数。这个函数将model_params_cache列表中的模型参数进行聚合（通常使用FedAvg算法，即加权平均）。然后，使用deserialize_model函数将聚合后的模型参数反序列化并应用到global_model上，从而更新全局模型。</span></span><br><span class="line">        aggregated_model_params = Aggregators.fedavg_aggregate(model_params_cache)</span><br><span class="line">        SerializationTool.deserialize_model(global_model, aggregated_model_params)</span><br><span class="line">        <span class="comment">#分隔符日志:</span></span><br><span class="line">        <span class="comment">#最后，代码使用logger对象输出一个由60个等号字符组成的分隔符，可能用于在日志中分隔不同的全局迭代轮次</span></span><br><span class="line">        logger.log(<span class="string">&quot;=&quot;</span> * <span class="number">60</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#描述了联邦学习中的评估过程，并且它记录了模型在评估前后的性能。</span></span><br><span class="line">    <span class="comment"># eval</span></span><br><span class="line">    pers_epochs = args.local_epochs <span class="keyword">if</span> args.pers_epochs == -<span class="number">1</span> <span class="keyword">else</span> args.pers_epochs <span class="comment">#确定持久化轮次（Persistent Epochs）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#开始评估日志</span></span><br><span class="line">    <span class="comment">#初始化评估结果列表</span></span><br><span class="line">    <span class="comment">#这四个列表用于存储每个客户端在评估前后的损失和准确率。</span></span><br><span class="line">    logger.log(<span class="string">&quot;=&quot;</span> * <span class="number">20</span>, <span class="string">&quot;EVALUATION&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">20</span>, style=<span class="string">&quot;bold blue&quot;</span>)</span><br><span class="line">    loss_before = []</span><br><span class="line">    loss_after = []</span><br><span class="line">    acc_before = []</span><br><span class="line">    acc_after = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#客户端评估循环</span></span><br><span class="line">    <span class="comment">#代码遍历clients_4_eval列表中的每个客户端ID，并对每个客户端执行pers_N_eval方法。这个方法在评估前对模型进行本地训练（使用pers_epochs指定的轮次），然后评估模型的性能，并返回一个包含损失和准确率的字典。这些值随后被添加到相应的列表中。</span></span><br><span class="line">    <span class="keyword">for</span> client_id <span class="keyword">in</span> track(</span><br><span class="line">        clients_4_eval, <span class="string">&quot;Evaluating...&quot;</span>, console=logger, disable=args.log</span><br><span class="line">    ):</span><br><span class="line">        stats = clients[client_id].pers_N_eval(</span><br><span class="line">            global_model=global_model, pers_epochs=pers_epochs,</span><br><span class="line">        )</span><br><span class="line">        loss_before.append(stats[<span class="string">&quot;loss_before&quot;</span>])</span><br><span class="line">        loss_after.append(stats[<span class="string">&quot;loss_after&quot;</span>])</span><br><span class="line">        acc_before.append(stats[<span class="string">&quot;acc_before&quot;</span>])</span><br><span class="line">        acc_after.append(stats[<span class="string">&quot;acc_after&quot;</span>])</span><br><span class="line">	</span><br><span class="line">    <span class="comment">#输出评估结果</span></span><br><span class="line">    <span class="comment">#代码使用logger对象输出评估结果。它计算了所有客户端的平均损失和准确率，并将它们以格式化的方式输出。</span></span><br><span class="line">    logger.log(<span class="string">&quot;=&quot;</span> * <span class="number">20</span>, <span class="string">&quot;RESULTS&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">20</span>, style=<span class="string">&quot;bold green&quot;</span>)</span><br><span class="line">    logger.log(<span class="string">f&quot;loss_before_pers: <span class="subst">&#123;(<span class="built_in">sum</span>(loss_before) / <span class="built_in">len</span>(loss_before)):<span class="number">.4</span>f&#125;</span>&quot;</span>)</span><br><span class="line">    logger.log(<span class="string">f&quot;acc_before_pers: <span class="subst">&#123;(<span class="built_in">sum</span>(acc_before) * <span class="number">100.0</span> / <span class="built_in">len</span>(acc_before)):<span class="number">.2</span>f&#125;</span>%&quot;</span>)</span><br><span class="line">    logger.log(<span class="string">f&quot;loss_after_pers: <span class="subst">&#123;(<span class="built_in">sum</span>(loss_after) / <span class="built_in">len</span>(loss_after)):<span class="number">.4</span>f&#125;</span>&quot;</span>)</span><br><span class="line">    logger.log(<span class="string">f&quot;acc_after_pers: <span class="subst">&#123;(<span class="built_in">sum</span>(acc_after) * <span class="number">100.0</span> / <span class="built_in">len</span>(acc_after)):<span class="number">.2</span>f&#125;</span>%&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#保存评估结果（如果启用日志）</span></span><br><span class="line">    <span class="keyword">if</span> args.log:</span><br><span class="line">        algo = <span class="string">&quot;HF&quot;</span> <span class="keyword">if</span> args.hf <span class="keyword">else</span> <span class="string">&quot;FO&quot;</span></span><br><span class="line">        logger.save_html(</span><br><span class="line">            <span class="string">f&quot;./log/<span class="subst">&#123;args.dataset&#125;</span>_<span class="subst">&#123;args.client_num_per_round&#125;</span>_<span class="subst">&#123;args.global_epochs&#125;</span>_<span class="subst">&#123;pers_epochs&#125;</span>_<span class="subst">&#123;algo&#125;</span>.html&quot;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<h3 id="Per-FeAVG源码分析——data目录下：">Per_FeAVG源码分析——data目录下：</h3>
<h4 id="init-py"><a href="http://init.py">init.py</a></h4>
<p>不做分析</p>
<h4 id="utils-py-2"><a href="http://utils.py">utils.py</a></h4>
<h5 id="字典：DATASET-DICT">字典：DATASET_DICT</h5>
<p>作用：它将字符串键（如 <code>&quot;mnist&quot;</code> 和 <code>&quot;cifar&quot;</code>）映射到对应的类（<code>MNISTDataset</code> 和 <code>CIFARDataset</code>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATASET_DICT = &#123;</span><br><span class="line">    <span class="string">&quot;mnist&quot;</span>: MNISTDataset,</span><br><span class="line">    <span class="string">&quot;cifar&quot;</span>: CIFARDataset,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="函数：CURRENT-DIR">函数：CURRENT_DIR</h5>
<p>作用：<code>CURRENT_DIR</code> 被设置为当前 Python 脚本文件的父目录的绝对路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CURRENT_DIR = Path(__file__).parent.abspath()</span><br></pre></td></tr></table></figure>
<h5 id="函数：get-dataloader">函数：get_dataloader</h5>
<p>作用：从一个预处理好的 pickle 文件中加载数据集，并根据给定的 <code>client_id</code> 分割为训练集和验证集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_dataloader</span>(<span class="params">dataset: <span class="built_in">str</span>, client_id: <span class="built_in">int</span>, batch_size=<span class="number">20</span>, valset_ratio=<span class="number">0.1</span></span>):</span><br><span class="line">    pickles_dir = CURRENT_DIR / dataset / <span class="string">&quot;pickles&quot;</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(pickles_dir) <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;Please preprocess and create pickles first.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(pickles_dir / <span class="built_in">str</span>(client_id) + <span class="string">&quot;.pkl&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        client_dataset: DATASET_DICT[dataset] = pickle.load(f)</span><br><span class="line"></span><br><span class="line">    val_num_samples = <span class="built_in">int</span>(valset_ratio * <span class="built_in">len</span>(client_dataset))</span><br><span class="line">    train_num_samples = <span class="built_in">len</span>(client_dataset) - val_num_samples</span><br><span class="line"></span><br><span class="line">    trainset, valset = random_split(</span><br><span class="line">        client_dataset, [train_num_samples, val_num_samples]</span><br><span class="line">    )</span><br><span class="line">    trainloader = DataLoader(trainset, batch_size, drop_last=<span class="literal">True</span>)</span><br><span class="line">    valloader = DataLoader(valset, batch_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> trainloader, valloader</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="函数：get-client-id-indices-dataset">函数：get_client_id_indices(dataset)</h5>
<p>作用：从一个特定的 pickle 文件中加载并返回关于数据集分割的信息。从一个 <code>seperation.pkl</code> 文件中读取训练集、测试集以及总数目的索引或标识符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_client_id_indices</span>(<span class="params">dataset</span>):</span><br><span class="line">    dataset_pickles_path = CURRENT_DIR / dataset / <span class="string">&quot;pickles&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(dataset_pickles_path / <span class="string">&quot;seperation.pkl&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        seperation = pickle.load(f)</span><br><span class="line">    <span class="keyword">return</span> (seperation[<span class="string">&quot;train&quot;</span>], seperation[<span class="string">&quot;test&quot;</span>], seperation[<span class="string">&quot;total&quot;</span>])</span><br></pre></td></tr></table></figure>
<h4 id="preprocess-py"><a href="http://preprocess.py">preprocess.py</a></h4>
<h5 id="函数：CURRENT-DIR-2">函数：CURRENT_DIR</h5>
<p>作用：<code>CURRENT_DIR</code> 被设置为当前 Python 脚本文件的父目录的绝对路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CURRENT_DIR = Path(__file__).parent.abspath()</span><br></pre></td></tr></table></figure>
<h5 id="字典：DATASET">字典：DATASET</h5>
<p>作用：数据集名称映射到了两个元组，可以基于数据集名称来动态地加载和实例化相应的数据集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATASET = &#123;</span><br><span class="line">    <span class="string">&quot;mnist&quot;</span>: (MNIST, MNISTDataset),</span><br><span class="line">    <span class="string">&quot;cifar&quot;</span>: (CIFAR10, CIFARDataset),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="字典：MEAN">字典：MEAN</h5>
<p>作用：用来存储不同数据集的像素均值。这些均值通常用于数据归一化，只包含一个灰度通道，因此其均值是一个单元素元组 <code>(0.1307,)</code>。这意味着当你对 MNIST 数据集进行归一化时，你会从每个像素值中减去 0.1307。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MEAN = &#123;</span><br><span class="line">    <span class="string">&quot;mnist&quot;</span>: (<span class="number">0.1307</span>,),</span><br><span class="line">    <span class="string">&quot;cifar&quot;</span>: (<span class="number">0.4914</span>, <span class="number">0.4822</span>, <span class="number">0.4465</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="字典：STD">字典：STD</h5>
<p>作用：存储不同数据集的像素标准差。使用归一化时，标准差通常与均值一起使用，以确保数据的每个特征（在这个案例中是像素值）都有相似的尺度。它只包含一个灰度通道，因此其标准差是一个单元素元组 <code>(0.3015,)</code>。这意味着在归一化 MNIST 数据时，每个像素值都会根据其灰度通道的标准差进行缩放。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">STD = &#123;</span><br><span class="line">    <span class="string">&quot;mnist&quot;</span>: (<span class="number">0.3015</span>,),</span><br><span class="line">    <span class="string">&quot;cifar&quot;</span>: (<span class="number">0.2023</span>, <span class="number">0.1994</span>, <span class="number">0.2010</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="函数：preprocess">函数：preprocess()</h5>
<p>作用：用于预处理数据集，在联邦学习或分布式学习的场景中，数据需要在多个客户端（或节点）之间分配。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preprocess</span>(<span class="params">args: Namespace</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="comment">#参数和目录设置：</span></span><br><span class="line">    <span class="comment">#设置数据集目录（dataset_dir）和pickle文件目录（pickles_dir）。</span></span><br><span class="line">    dataset_dir = CURRENT_DIR / args.dataset</span><br><span class="line">    pickles_dir = CURRENT_DIR / args.dataset / <span class="string">&quot;pickles&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#设置随机数生成器的种子，以确保结果的可重复性。</span></span><br><span class="line">    np.random.seed(args.seed)</span><br><span class="line">    random.seed(args.seed)</span><br><span class="line">    torch.manual_seed(args.seed)</span><br><span class="line">    num_train_clients = <span class="built_in">int</span>(args.client_num_in_total * args.fraction)</span><br><span class="line">    num_test_clients = args.client_num_in_total - num_train_clients</span><br><span class="line"></span><br><span class="line">    <span class="comment">#数据转换</span></span><br><span class="line">    <span class="comment">#定义了一个转换transform，它只包含标准化（假设MEAN和STD是预定义的字典，包含了每个数据集的均值和标准差），初始化了训练集和测试集的统计信息字典</span></span><br><span class="line">    transform = transforms.Compose(</span><br><span class="line">        [transforms.Normalize(MEAN[args.dataset], STD[args.dataset]),]</span><br><span class="line">    )</span><br><span class="line">    target_transform = <span class="literal">None</span></span><br><span class="line">    trainset_stats = &#123;&#125;</span><br><span class="line">    testset_stats = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#目录和文件处理：</span></span><br><span class="line">    <span class="comment">#检查数据集目录是否存在，如果不存在则创建它。</span></span><br><span class="line">    <span class="comment">#如果pickle目录已经存在，则删除它（可能是为了确保没有旧的pickle文件干扰）。</span></span><br><span class="line">    <span class="comment">#创建新的pickle目录。</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(CURRENT_DIR / args.dataset):</span><br><span class="line">        os.mkdir(CURRENT_DIR / args.dataset)</span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(pickles_dir):</span><br><span class="line">        os.system(<span class="string">f&quot;rm -rf <span class="subst">&#123;pickles_dir&#125;</span>&quot;</span>)</span><br><span class="line">    os.mkdir(<span class="string">f&quot;<span class="subst">&#123;pickles_dir&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#加载数据集</span></span><br><span class="line">    <span class="comment">#从预定义的DATASET字典中获取原始和目标数据集。</span></span><br><span class="line">    <span class="comment">#使用ori_dataset类创建训练集和测试集。注意，训练集在加载时还指定了download=True（用于自动下载数据集），而测试集没有。两者都使用了transforms.ToTensor()进行初步的数据转换。</span></span><br><span class="line">    ori_dataset, target_dataset = DATASET[args.dataset]</span><br><span class="line">    trainset = ori_dataset(</span><br><span class="line">        dataset_dir, train=<span class="literal">True</span>, download=<span class="literal">True</span>, transform=transforms.ToTensor()</span><br><span class="line">    )</span><br><span class="line">    testset = ori_dataset(dataset_dir, train=<span class="literal">False</span>, transform=transforms.ToTensor())</span><br><span class="line"></span><br><span class="line">    <span class="comment">#分配类别到客户端</span></span><br><span class="line">    <span class="comment">#根据args.classes确定每个客户端应有的类别数量（默认为10类）</span></span><br><span class="line">    <span class="comment">#使用randomly_alloc_classes函数将类别随机分配给训练集和测试集的客户端</span></span><br><span class="line">    <span class="comment">#randomly_alloc_classes函数还返回每个子集的统计信息（</span></span><br><span class="line">    num_classes = <span class="number">10</span> <span class="keyword">if</span> args.classes &lt;= <span class="number">0</span> <span class="keyword">else</span> args.classes</span><br><span class="line">    all_trainsets, trainset_stats = randomly_alloc_classes(</span><br><span class="line">        ori_dataset=trainset,</span><br><span class="line">        target_dataset=target_dataset,</span><br><span class="line">        num_clients=num_train_clients,</span><br><span class="line">        num_classes=num_classes,</span><br><span class="line">        transform=transform,</span><br><span class="line">        target_transform=target_transform,</span><br><span class="line">    )</span><br><span class="line">    all_testsets, testset_stats = randomly_alloc_classes(</span><br><span class="line">        ori_dataset=testset,</span><br><span class="line">        target_dataset=target_dataset,</span><br><span class="line">        num_clients=num_test_clients,</span><br><span class="line">        num_classes=num_classes,</span><br><span class="line">        transform=transform,</span><br><span class="line">        target_transform=target_transform,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">#将所有训练集和测试集组合到一个列表all_datasets中</span></span><br><span class="line">    all_datasets = all_trainsets + all_testsets</span><br><span class="line"></span><br><span class="line">    <span class="comment">#保存客户端数据集为pickle文件</span></span><br><span class="line">    <span class="comment">#通过enumerate(all_datasets)遍历all_datasets列表中的每个数据集和对应的client_id（即客户端的ID）。</span></span><br><span class="line">    <span class="comment">#使用pathlib的/操作符（如果pickles_dir是pathlib.Path对象）来构建pickle文件的路径。</span></span><br><span class="line">    <span class="comment">#使用pickle.dump()函数将每个数据集保存到对应的pickle文件中。</span></span><br><span class="line">    <span class="keyword">for</span> client_id, dataset <span class="keyword">in</span> <span class="built_in">enumerate</span>(all_datasets):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(pickles_dir / <span class="built_in">str</span>(client_id) + <span class="string">&quot;.pkl&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            pickle.dump(dataset, f)</span><br><span class="line">     </span><br><span class="line">    <span class="comment">#保存客户端索引</span></span><br><span class="line">    <span class="comment">#创建一个字典，其中包含三个键：“train”、“test”和“total”，“total”的值就是总的客户端数量。</span></span><br><span class="line">    <span class="comment">#“train”和“test”的值是客户端ID的列表，分别代表训练集和测试集的客户端。这里假设num_train_clients表示训练集客户端的数量，而args.client_num_in_total表示总的客户端数量。</span></span><br><span class="line">    <span class="comment">#使用pickle.dump()函数将这个字典保存到名为“seperation.pkl”的文件中。这个文件用于在后续的训练和测试过程中区分哪些客户端是训练集，哪些是测试集</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(pickles_dir / <span class="string">&quot;seperation.pkl&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        pickle.dump(</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;train&quot;</span>: [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_train_clients)],</span><br><span class="line">                <span class="string">&quot;test&quot;</span>: [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_train_clients, args.client_num_in_total)],</span><br><span class="line">                <span class="string">&quot;total&quot;</span>: args.client_num_in_total,</span><br><span class="line">            &#125;,</span><br><span class="line">            f,</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#保存数据集统计信息</span></span><br><span class="line">    <span class="comment">#trainset_stats和testset_stats是在之前的预处理步骤中收集的训练集和测试集的统计信息。</span></span><br><span class="line">    <span class="comment">#使用json.dump()函数将这些统计信息保存为JSON格式的文件“all_stats.json”。这个文件用于在后续的模型训练和评估过程中提供数据集的相关信息</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(dataset_dir / <span class="string">&quot;all_stats.json&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        json.dump(&#123;<span class="string">&quot;train&quot;</span>: trainset_stats, <span class="string">&quot;test&quot;</span>: testset_stats&#125;, f)</span><br></pre></td></tr></table></figure>
<h5 id="函数：randomly-alloc-classes">函数：randomly_alloc_classes</h5>
<p>作用：将原始数据集（<code>ori_dataset</code>）中的样本随机分配给多个客户端（或用户），同时确保每个客户端获得指定数量的不同类别的样本。函数还返回了分配给每个客户端的数据集列表和相应的统计信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">randomly_alloc_classes</span>(<span class="params"></span></span><br><span class="line"><span class="params">    ori_dataset: Dataset,</span></span><br><span class="line"><span class="params">    target_dataset: Dataset,</span></span><br><span class="line"><span class="params">    num_clients: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">    num_classes: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">    transform=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    target_transform=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="type">Tuple</span>[<span class="type">List</span>[Dataset], <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]]]:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#分配样本</span></span><br><span class="line">    <span class="comment">#使用noniid_slicing函数来将ori_dataset中的样本分配给num_clients个客户端。这个函数应该返回一个字典，其中键是客户端ID，值是分配给该客户端的样本索引列表。</span></span><br><span class="line">    dict_users = noniid_slicing(ori_dataset, num_clients, num_clients * num_classes)</span><br><span class="line">    stats = &#123;&#125;</span><br><span class="line">    <span class="comment">#收集统计信息</span></span><br><span class="line">    <span class="comment">#对于每个客户端，从ori_dataset中提取标签（ori_dataset.targets），然后根据分配给该客户端的样本索引列表计算标签的类别分布。这些统计信息被存储在stats字典中。</span></span><br><span class="line">    <span class="keyword">for</span> i, indices <span class="keyword">in</span> dict_users.items():</span><br><span class="line">        targets_numpy = np.array(ori_dataset.targets)</span><br><span class="line">        stats[<span class="string">f&quot;client <span class="subst">&#123;i&#125;</span>&quot;</span>] = &#123;<span class="string">&quot;x&quot;</span>: <span class="number">0</span>, <span class="string">&quot;y&quot;</span>: &#123;&#125;&#125;</span><br><span class="line">        stats[<span class="string">f&quot;client <span class="subst">&#123;i&#125;</span>&quot;</span>][<span class="string">&quot;x&quot;</span>] = <span class="built_in">len</span>(indices)</span><br><span class="line">        stats[<span class="string">f&quot;client <span class="subst">&#123;i&#125;</span>&quot;</span>][<span class="string">&quot;y&quot;</span>] = Counter(targets_numpy[indices].tolist())</span><br><span class="line">    datasets = []</span><br><span class="line">    <span class="comment">#创建数据集</span></span><br><span class="line">    <span class="comment">#使用target_dataset类从ori_dataset中创建子集，每个子集对应于一个客户端。这是通过从ori_dataset中提取分配给该客户端的样本，并传递给target_dataset的构造函数来实现的。</span></span><br><span class="line">    <span class="keyword">for</span> indices <span class="keyword">in</span> dict_users.values():</span><br><span class="line">        datasets.append(</span><br><span class="line">            target_dataset(</span><br><span class="line">                [ori_dataset[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices],</span><br><span class="line">                transform=transform,</span><br><span class="line">                target_transform=target_transform,</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> datasets, stats</span><br></pre></td></tr></table></figure>
<h5 id="函数：-name-“main”">函数：__name__==“main”</h5>
<p>作用：基本的命令行参数解析设置，它使用<code>argparse</code>库来从命令行获取参数。这些参数包括数据集类型、客户端总数、训练客户端的比例、每个客户端数据所属的类别数量以及随机种子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = ArgumentParser()</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--dataset&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, choices=[<span class="string">&quot;mnist&quot;</span>, <span class="string">&quot;cifar&quot;</span>], default=<span class="string">&quot;mnist&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--client_num_in_total&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">200</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--fraction&quot;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.9</span>, <span class="built_in">help</span>=<span class="string">&quot;Propotion of train clients&quot;</span></span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--classes&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        default=<span class="number">2</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Num of classes that one client&#x27;s data belong to.&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--seed&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">0</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    preprocess(args)</span><br></pre></td></tr></table></figure>
<h4 id="dataset-py"><a href="http://dataset.py">dataset.py</a></h4>
<h5 id="类：MNISTDataset-Dataset">类：MNISTDataset(Dataset)</h5>
<h6 id="函数：init-2">函数：init</h6>
<p>作用：用于初始化一个对象的状态</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="comment">#参数</span></span></span><br><span class="line"><span class="params">    self,</span></span><br><span class="line"><span class="params">    subset=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    data=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    targets=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    transform=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    target_transform=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="comment">#处理</span></span><br><span class="line">    self.transform = transform</span><br><span class="line">    self.target_transform = target_transform</span><br><span class="line">    <span class="comment">#如果data和targets都非空，它将data增加一个新的维度（使用unsqueeze(1)），并将data和targets设置为对象的属性。</span></span><br><span class="line">    <span class="keyword">if</span> (data <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">and</span> (targets <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>):</span><br><span class="line">        self.data = data.unsqueeze(<span class="number">1</span>)</span><br><span class="line">        self.targets = targets</span><br><span class="line">    <span class="comment"># 如果subset非空，它将遍历subset，检查元组中的每个元素是否为张量。如果不是，它将使用torch.tensor将其转换为张量。然后，它使用torch.stack将数据和标签分别堆叠成张量，并设置为对象的属性。   </span></span><br><span class="line">    <span class="keyword">elif</span> subset <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self.data = torch.stack(</span><br><span class="line">            <span class="built_in">list</span>(</span><br><span class="line">                <span class="built_in">map</span>(</span><br><span class="line">                    <span class="keyword">lambda</span> tup: tup[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">isinstance</span>(tup[<span class="number">0</span>], torch.Tensor)</span><br><span class="line">                    <span class="keyword">else</span> torch.tensor(tup[<span class="number">0</span>]),</span><br><span class="line">                    subset,</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">        self.targets = torch.stack(</span><br><span class="line">            <span class="built_in">list</span>(</span><br><span class="line">                <span class="built_in">map</span>(</span><br><span class="line">                    <span class="keyword">lambda</span> tup: tup[<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">isinstance</span>(tup[<span class="number">1</span>], torch.Tensor)</span><br><span class="line">                    <span class="keyword">else</span> torch.tensor(tup[<span class="number">1</span>]),</span><br><span class="line">                    subset,</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    <span class="comment">#如果data和targets以及subset都为空，则抛出一个ValueError，说明需要提供数据格式。</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(</span><br><span class="line">            <span class="string">&quot;Data Format: subset: Tuple(data: Tensor / Image / np.ndarray, targets: Tensor) OR data: List[Tensor]  targets: List[Tensor]&quot;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<h6 id="函数：getitem">函数：getitem</h6>
<p>作用：允许类的实例像列表、元组或其他可迭代对象那样进行索引访问。在你提供的上下文中，这个方法通常用于数据加载器（如PyTorch的<code>DataLoader</code>），以便在训练或评估模型时能够按索引访问数据集中的单个样本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">    data, targets = self.data[index], self.targets[index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        data = self.transform(self.data[index])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.target_transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        targets = self.target_transform(self.targets[index])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data, targets</span><br></pre></td></tr></table></figure>
<h6 id="函数：len">函数：len</h6>
<p>作用：确定self.data的长度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(self.targets)</span><br></pre></td></tr></table></figure>
<h5 id="类：CIFARDataset-Dataset">类：CIFARDataset(Dataset)</h5>
<h6 id="函数：init-3">函数：init</h6>
<p>作用：用于初始化一个对象的状态</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">    self,</span></span><br><span class="line"><span class="params">    subset=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    data=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    targets=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    transform=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    target_transform=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    self.transform = transform</span><br><span class="line">    self.target_transform = target_transform</span><br><span class="line">    <span class="keyword">if</span> (data <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">and</span> (targets <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>):</span><br><span class="line">        self.data = data.unsqueeze(<span class="number">1</span>)</span><br><span class="line">        self.targets = targets</span><br><span class="line">    <span class="keyword">elif</span> subset <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self.data = torch.stack(</span><br><span class="line">            <span class="built_in">list</span>(</span><br><span class="line">                <span class="built_in">map</span>(</span><br><span class="line">                    <span class="keyword">lambda</span> tup: tup[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">isinstance</span>(tup[<span class="number">0</span>], torch.Tensor)</span><br><span class="line">                    <span class="keyword">else</span> torch.tensor(tup[<span class="number">0</span>]),</span><br><span class="line">                    subset,</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">        self.targets = torch.stack(</span><br><span class="line">            <span class="built_in">list</span>(</span><br><span class="line">                <span class="built_in">map</span>(</span><br><span class="line">                    <span class="keyword">lambda</span> tup: tup[<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">isinstance</span>(tup[<span class="number">1</span>], torch.Tensor)</span><br><span class="line">                    <span class="keyword">else</span> torch.tensor(tup[<span class="number">1</span>]),</span><br><span class="line">                    subset,</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(</span><br><span class="line">            <span class="string">&quot;Data Format: subset: Tuple(data: Tensor / Image / np.ndarray, targets: Tensor) OR data: List[Tensor]  targets: List[Tensor]&quot;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<h6 id="函数：getitem-2">函数：getitem</h6>
<p>作用：允许类的实例像列表、元组或其他可迭代对象那样进行索引访问。在你提供的上下文中，这个方法通常用于数据加载器（如PyTorch的<code>DataLoader</code>），以便在训练或评估模型时能够按索引访问数据集中的单个样本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">    img, targets = self.data[index], self.targets[index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        img = self.transform(self.data[index])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.target_transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        targets = self.target_transform(self.targets[index])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> img, targets</span><br></pre></td></tr></table></figure>
<h6 id="函数：len-2">函数：len</h6>
<p>作用：返回长度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(self.targets)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Per_FedAVG</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb调试工具详解</title>
    <url>/2024/07/01/gdb%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="gdb调试详解">gdb调试详解</h3>
<p>是 GNU 调试器（GNU Debugger）的缩写，它是一个功能强大的 Unix-like 系统下的源代码调试器。使用 <code>gdb</code>，程序员可以查看程序在运行时的状态，设置断点，单步执行代码，检查变量的值，以及执行其他调试任务。(在命令行终端中进行)</p>
<h4 id="gdb启动流程">gdb启动流程</h4>
<ol>
<li>
<p>编译相关：编译链接的时候<code>-g</code>表示可以调试，如果要使用gdb调试记得加上</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -g test.cpp -o test</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>启动gdb，示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gdb test </span><br><span class="line">gbd -q test <span class="comment">//表示不打印gbd版本信息，界面比较干净</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>gdb下查看源码：<code>list</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) list </span><br><span class="line"><span class="number">9</span>	<span class="meta">#<span class="keyword">define</span> MAX_SIZE</span></span><br><span class="line"><span class="number">10</span>	</span><br><span class="line"><span class="number">11</span>	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">12	</span>&#123;</span><br><span class="line"><span class="number">13</span>	    <span class="type">int</span> i,fd,size1 ,size2 ,len;</span><br><span class="line"><span class="number">14</span>	    <span class="type">char</span> *buf = <span class="string">&quot;helo!I&#x27;m liujiangyong &quot;</span>;</span><br><span class="line"><span class="number">15</span>	    <span class="type">char</span> buf_r[<span class="number">15</span>];</span><br><span class="line"><span class="number">16</span>	    len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"><span class="number">17</span>	    fd = <span class="built_in">open</span>(<span class="string">&quot;/home/hello.txt&quot;</span>,O_CREAT | O_TRUNC | O_RDWR,<span class="number">0666</span>);</span><br><span class="line"><span class="number">18</span>	    <span class="keyword">if</span> (fd&lt;<span class="number">0</span>)</span><br><span class="line">(gdb) </span><br><span class="line"><span class="number">19</span>	        &#123;</span><br><span class="line"><span class="number">20</span>	            <span class="built_in">perror</span>(<span class="string">&quot;open :&quot;</span>);</span><br><span class="line"><span class="number">21</span>	            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"><span class="number">22</span>	        &#125;</span><br><span class="line"><span class="number">23</span>	    <span class="keyword">else</span></span><br><span class="line"><span class="number">24</span>	        &#123;</span><br><span class="line"><span class="number">25</span>	        <span class="built_in">printf</span>(<span class="string">&quot;open file:hello.txt %d\n&quot;</span>,fd);</span><br><span class="line"><span class="number">26</span>	        &#125;</span><br><span class="line"><span class="number">27</span>	    size1 = <span class="built_in">write</span>(fd,buf,len);</span><br><span class="line"><span class="number">28</span>	    <span class="keyword">if</span> (fd&lt;<span class="number">0</span>)</span><br><span class="line">(gdb) </span><br><span class="line"><span class="number">29</span>	    &#123;</span><br><span class="line"><span class="number">30</span>	        <span class="built_in">printf</span>(<span class="string">&quot;writre erro;&quot;</span>);</span><br><span class="line"><span class="number">31</span>	</span><br><span class="line"><span class="number">32</span>	    &#125;</span><br><span class="line"><span class="number">33</span>	    <span class="keyword">else</span></span><br><span class="line"><span class="number">34</span>	    &#123;</span><br><span class="line"><span class="number">35</span>	        <span class="built_in">printf</span>(<span class="string">&quot;写入的长度：%d\n写入文本内容：%s\n&quot;</span>,size1,buf);</span><br><span class="line"><span class="number">36</span>	</span><br><span class="line"><span class="number">37</span>	    &#125;</span><br><span class="line"><span class="number">38</span>	    <span class="built_in">lseek</span>(fd,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">(gdb) </span><br><span class="line"><span class="number">39</span>	    size2 = <span class="built_in">read</span>(fd,buf_r,<span class="number">12</span>);</span><br><span class="line"><span class="number">40</span>	    <span class="keyword">if</span> (size2 &lt;<span class="number">0</span>)</span><br><span class="line"><span class="number">41</span>	    &#123;</span><br><span class="line"><span class="number">42</span>	        <span class="built_in">printf</span>(<span class="string">&quot;read  erro\n&quot;</span>);</span><br><span class="line"><span class="number">43</span>	    &#125;</span><br><span class="line"><span class="number">44</span>	    <span class="keyword">else</span></span><br><span class="line"><span class="number">45</span>	    &#123;</span><br><span class="line"><span class="number">46</span>	        <span class="built_in">printf</span>(<span class="string">&quot;读取长度：%d\n 文本内容是：%s\n&quot;</span>,size2,buf_r);</span><br><span class="line"><span class="number">47</span>	    &#125;</span><br><span class="line"><span class="number">48</span>	    <span class="built_in">close</span>(fd);    </span><br><span class="line">(gdb) </span><br><span class="line"><span class="number">49</span>	</span><br><span class="line"><span class="number">50</span>	</span><br><span class="line"><span class="number">51</span>	&#125;</span><br><span class="line">(gdb) </span><br><span class="line">Line number <span class="number">52</span> out of range; write.c has <span class="number">51</span> lines.</span><br><span class="line">(gdb) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>gbd下运行程序：<code>run</code></p>
<p>该命令会运行程序直到结束或者遇到断点等待下一个命令</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y <span class="keyword">or</span> n) y</span><br><span class="line">Starting program: /home/eit/c_test/test </span><br><span class="line">open file:hello.txt <span class="number">3</span></span><br><span class="line">写入的长度：<span class="number">22</span></span><br><span class="line">写入文本内容：helo!I<span class="number">&#x27;</span>m liujiangyong </span><br><span class="line">读取长度：<span class="number">12</span></span><br><span class="line"> 文本内容是：helo!I<span class="number">&#x27;</span>m liu</span><br><span class="line">[Inferior <span class="number">1</span> (process <span class="number">19987</span>) exited normally]</span><br><span class="line">(gdb) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>gdb下设置断点：<code>break</code>+行号</p>
<p>该命令会在某一行设置一个断点,<code>info breakpoints</code>会显示所有断点信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) b <span class="number">5</span></span><br><span class="line">Breakpoint <span class="number">3</span> at <span class="number">0x400836</span>: file write.c, line <span class="number">5.</span></span><br><span class="line">(gdb) b <span class="number">26</span> </span><br><span class="line">Breakpoint <span class="number">4</span> at <span class="number">0x4008a6</span>: file write.c, line <span class="number">26.</span></span><br><span class="line">(gdb) b <span class="number">30</span></span><br><span class="line">Breakpoint <span class="number">5</span> at <span class="number">0x4008c6</span>: file write.c, line <span class="number">30.</span></span><br><span class="line">(gdb) info breakpoints </span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line"><span class="number">3</span>       breakpoint     keep y   <span class="number">0x0000000000400836</span> in main at write.c:<span class="number">5</span></span><br><span class="line"><span class="number">4</span>       breakpoint     keep y   <span class="number">0x00000000004008a6</span> in main at write.c:<span class="number">26</span></span><br><span class="line"><span class="number">5</span>       breakpoint     keep y   <span class="number">0x00000000004008c6</span> in main at write.c:<span class="number">30</span></span><br><span class="line">(gdb) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>num</th>
<th>type</th>
<th>disp</th>
<th>enb</th>
<th>address</th>
<th>what</th>
</tr>
</thead>
<tbody>
<tr>
<td>断点编号</td>
<td>类型</td>
<td>断点执行一次后是否有效，keep（有）</td>
<td>当前断点是否有效，y（有）</td>
<td>内存地址</td>
<td>在函数中的位置</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>gdb下单步执行：<code>continue</code>、<code>step</code>、<code>next</code>、<code>finish</code></p>
<ul>
<li>
<p><code>continue</code>：在断点处继续执行程序</p>
</li>
<li>
<p><code>next</code>：执行下一行代码（跳过函数内部）</p>
</li>
<li>
<p><code>step</code>：执行下一行代码（进入函数内部）</p>
</li>
<li>
<p><code>finish</code>：执行完当前函数并返回到父函数</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/eit/c_test/test </span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">3</span>, <span class="built_in">main</span> () at write.c:<span class="number">12</span></span><br><span class="line"><span class="number">12</span>	&#123;</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">14</span>	    <span class="type">char</span> *buf = <span class="string">&quot;helo!I&#x27;m liujiangyong &quot;</span>;</span><br><span class="line">(gdb) </span><br><span class="line"><span class="number">16</span>	    len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">(gdb) </span><br><span class="line"><span class="number">17</span>	    fd = <span class="built_in">open</span>(<span class="string">&quot;/home/hello.txt&quot;</span>,O_CREAT | O_TRUNC | O_RDWR,<span class="number">0666</span>);</span><br><span class="line">(gdb) <span class="function">s</span></span><br><span class="line"><span class="function"><span class="title">open64</span> <span class="params">()</span> at ../sysdeps/unix/syscall-<span class="keyword">template</span>.S:<span class="number">81</span></span></span><br><span class="line"><span class="function"><span class="number">81</span>	../sysdeps/unix/syscall-template.S: No such file or directory.</span></span><br><span class="line"><span class="function">(gdb) </span></span><br><span class="line"><span class="function">main () at write.c:<span class="number">18</span></span></span><br><span class="line"><span class="function"><span class="number">18</span>	    if (fd&lt;<span class="number">0</span>)</span></span><br><span class="line"><span class="function">(gdb) </span></span><br><span class="line"><span class="function"><span class="number">25</span>	        printf(<span class="string">&quot;open file:hello.txt %d\n&quot;</span>,fd);</span></span><br><span class="line">(gdb) </span><br><span class="line">__printf (format=<span class="number">0x400a26</span> <span class="string">&quot;open file:hello.txt %d\n&quot;</span>) at printf.c:<span class="number">28</span></span><br><span class="line"><span class="number">28</span>	printf.c: No such file <span class="keyword">or</span> directory.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">open file:hello.txt <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">4</span>, <span class="built_in">main</span> () at write.c:<span class="number">27</span></span><br><span class="line"><span class="number">27</span>	    size1 = <span class="built_in">write</span>(fd,buf,len);</span><br><span class="line">(gdb) </span><br><span class="line">Continuing.</span><br><span class="line">写入的长度：<span class="number">22</span></span><br><span class="line">写入文本内容：helo!I<span class="number">&#x27;</span>m liujiangyong </span><br><span class="line">读取长度：<span class="number">12</span></span><br><span class="line"> 文本内容是：helo!I<span class="number">&#x27;</span>m liu</span><br><span class="line">[Inferior <span class="number">1</span> (process <span class="number">20737</span>) exited normally]</span><br><span class="line">(gdb) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>gdb下查看变量：<code>print</code>、<code>whatis</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">main</span> () at write.c:<span class="number">28</span></span><br><span class="line"><span class="number">28</span>	    <span class="keyword">if</span> (fd&lt;<span class="number">0</span>)</span><br><span class="line">(gdb) </span><br><span class="line"><span class="number">35</span>	        <span class="built_in">printf</span>(<span class="string">&quot;写入的长度：%d\n写入文本内容：%s\n&quot;</span>,size1,buf);</span><br><span class="line">(gdb) print fd</span><br><span class="line">$<span class="number">10</span> = <span class="number">3</span></span><br><span class="line">(gdb) whatis fd</span><br><span class="line">type = <span class="built_in">int</span></span><br><span class="line">(gdb) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>gdb下退出gdb：<code>quit</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/eit/c_test/test </span><br><span class="line">open file:hello.txt <span class="number">3</span></span><br><span class="line">写入的长度：<span class="number">22</span></span><br><span class="line">写入文本内容：helo!I<span class="number">&#x27;</span>m liujiangyong </span><br><span class="line">读取长度：<span class="number">12</span></span><br><span class="line"> 文本内容是：helo!I<span class="number">&#x27;</span>m liu</span><br><span class="line">[Inferior <span class="number">1</span> (process <span class="number">20815</span>) exited normally]</span><br><span class="line">(gdb) q</span><br><span class="line">root@ubuntu:/home/eit/c_test# </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="常用命令">常用命令</h4>
<p>当使用表格来表示 <code>gdb</code> 的常用命令时，可以如下所示：</p>
<table>
<thead>
<tr>
<th>命令分类</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动和退出</td>
<td><code>gdb your_program</code></td>
<td>启动 GDB 并加载指定的程序</td>
</tr>
<tr>
<td></td>
<td><code>quit</code> 或 <code>q</code></td>
<td>退出 GDB</td>
</tr>
<tr>
<td>调试控制</td>
<td><code>run [arguments]</code> 或 <code>r [arguments]</code></td>
<td>运行程序并传递参数</td>
</tr>
<tr>
<td></td>
<td><code>continue</code> 或 <code>c</code></td>
<td>继续执行，直到遇到下一个断点或程序结束</td>
</tr>
<tr>
<td></td>
<td><code>next</code> 或 <code>n</code></td>
<td>执行下一行代码（不进入函数）</td>
</tr>
<tr>
<td></td>
<td><code>step</code> 或 <code>s</code></td>
<td>执行下一行代码（进入函数）</td>
</tr>
<tr>
<td></td>
<td><code>finish</code></td>
<td>执行完当前函数并返回到父函数</td>
</tr>
<tr>
<td>断点管理</td>
<td><code>break [location]</code> 或 <code>b [location]</code></td>
<td>在指定位置设置断点</td>
</tr>
<tr>
<td></td>
<td><code>info breakpoints</code> 或 <code>info b</code></td>
<td>显示所有断点信息</td>
</tr>
<tr>
<td></td>
<td><code>disable [breakpoint_number]</code></td>
<td>禁用指定编号的断点</td>
</tr>
<tr>
<td></td>
<td><code>enable [breakpoint_number]</code></td>
<td>启用指定编号的断点</td>
</tr>
<tr>
<td></td>
<td><code>delete [breakpoint_number]</code> 或 <code>d [breakpoint_number]</code></td>
<td>删除指定编号的断点</td>
</tr>
<tr>
<td>变量和内存查看</td>
<td><code>print [variable_name]</code> 或 <code>p [variable_name]</code></td>
<td>显示变量的值</td>
</tr>
<tr>
<td></td>
<td><code>ptype [variable_name]</code></td>
<td>显示变量的类型</td>
</tr>
<tr>
<td></td>
<td><code>set var [variable_name]=[newValue]</code></td>
<td>修改变量的值</td>
</tr>
<tr>
<td></td>
<td><code>x/NFU [address]</code></td>
<td>显示内存内容，N是数量，F是格式，U是单位，address是地址</td>
</tr>
<tr>
<td>其他常用命令</td>
<td><code>list [location]</code> 或 <code>l [location]</code></td>
<td>显示源代码</td>
</tr>
<tr>
<td></td>
<td><code>backtrace</code> 或 <code>bt</code></td>
<td>显示堆栈跟踪</td>
</tr>
<tr>
<td></td>
<td><code>watch [expression]</code></td>
<td>设置观察点，当表达式值改变时停止</td>
</tr>
<tr>
<td></td>
<td><code>catch [event]</code></td>
<td>捕获特定事件（如异常）</td>
</tr>
<tr>
<td></td>
<td><code>show path</code></td>
<td>显示GDB搜索源代码的路径</td>
</tr>
<tr>
<td></td>
<td><code>setargs [arguments]</code></td>
<td>设置传递给程序的命令行参数</td>
</tr>
<tr>
<td></td>
<td><code>show args</code></td>
<td>显示设置好的运行时参数</td>
</tr>
<tr>
<td></td>
<td><code>attach [process_id]</code></td>
<td>连接到正在运行的进程</td>
</tr>
<tr>
<td></td>
<td><code>detach</code></td>
<td>断开与已连接进程的连接</td>
</tr>
<tr>
<td></td>
<td><code>shell [command]</code></td>
<td>执行shell命令</td>
</tr>
<tr>
<td>自定义命令和脚本</td>
<td><code>define [cmd_name] [command_list]</code></td>
<td>定义自定义命令</td>
</tr>
<tr>
<td></td>
<td>脚本文件</td>
<td>使用脚本文件来自动化调试任务</td>
</tr>
<tr>
<td>多线程和多进程调试</td>
<td><code>info threads</code></td>
<td>显示所有线程信息</td>
</tr>
<tr>
<td></td>
<td><code>thread [tid]</code></td>
<td>切换到指定编号的线程</td>
</tr>
<tr>
<td></td>
<td>`set follow-fork-mode [child</td>
<td>parent]`</td>
</tr>
</tbody>
</table>
<p>请注意，这个表格只是提供了 <code>gdb</code> 的一些常用命令的概览，每个命令还有更多的选项和用法可以探索。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>gdb调试</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+butterfly+Github</title>
    <url>/2024/06/23/hexo-butterfly-Github/</url>
    <content><![CDATA[<h3 id="配置butterfly时总结出来的的经验">配置butterfly时总结出来的的经验</h3>
<ol>
<li>一步一步配，每配一次，<code>hexo s</code>一次，出问题了就查</li>
<li>出现报错的情况下，可以先试着<code>hexo clean&amp;hexo g&amp;hexo s</code>多来几次</li>
</ol>
<h3 id="我的文件结构注意事项">我的文件结构注意事项</h3>
<ol>
<li>在hexo根目录下的_config.yml和_config.butterfly.yml</li>
<li>没有特别提到的话，数据相关文件应该都是在/source/里面</li>
<li>文章的创建用<code>hexo new &quot;name&quot;</code>,页面的创建用的<code>hexo new page </code></li>
</ol>
<h3 id="用代码说话，两个配置文件最容易出问题">用代码说话，两个配置文件最容易出问题</h3>
<h4 id="config-butterfly-yml">_config.butterfly.yml</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果你用vs编程发现最后主页中文是乱码，</span></span><br><span class="line"><span class="comment">#是因为vs默认生成的文件不按照utf-8，请按照这个解决 https://blog.csdn.net/qq_41868108/article/details/105750175</span></span><br><span class="line"><span class="comment">#浏览器图标修改</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/image/luogic.jpg</span></span><br><span class="line"><span class="comment">#导航栏设置 最上面的一栏，logo是最左边的小圈圈</span></span><br><span class="line"><span class="attr">nav:</span></span><br><span class="line">  <span class="attr">logo:</span> <span class="string">/image/微信图片_202406231044301.jpg</span></span><br><span class="line">  <span class="attr">display_title:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">fixed:</span> <span class="literal">false</span> <span class="comment"># fixed navigation bar    </span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#这里是右上角的设置 格式是，/文件夹路劲/|| fas图标</span></span><br><span class="line"><span class="comment">#（一定要建立文件夹，不如找不到会报错） </span></span><br><span class="line"><span class="comment">#这里的fas图标 它用的是一个公司发行的标准图标图</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">时间轴:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="string">其他||fa</span> <span class="attr">fa-heartbeat:</span></span><br><span class="line">    <span class="string">音乐:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">    <span class="string">照片:</span> <span class="string">/Gallery/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-images</span></span><br><span class="line">    <span class="string">电影:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#网站副标题，中间标题下面一点点</span></span><br><span class="line"><span class="comment"># 主页subtitle</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Typewriter Effect (打字效果)</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">startDelay:</span> <span class="number">300</span> <span class="comment"># time before typing starts in milliseconds</span></span><br><span class="line">  <span class="attr">typeSpeed:</span> <span class="number">200</span> <span class="comment"># type speed in milliseconds</span></span><br><span class="line">  <span class="attr">backSpeed:</span> <span class="number">800</span> <span class="comment"># backspacing speed in milliseconds</span></span><br><span class="line">  <span class="comment"># loop (循环打字)</span></span><br><span class="line">  <span class="attr">loop:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># source 调用三方服务</span></span><br><span class="line">  <span class="comment"># source: false 开关调用</span></span><br><span class="line">  <span class="comment"># subtitle 会先显示 source , 再显示 sub 的內容</span></span><br><span class="line">  <span class="attr">source:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 如果关闭打字效果，subtitle 只会显示 sub 的第一行文字</span></span><br><span class="line">  <span class="attr">sub:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">飒飒西风满院栽，蕊寒香冷蝶难来</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">他年我若为青帝，报与桃花一处开</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#页面 右侧个人信息相关的设置</span></span><br><span class="line"><span class="comment">#头像 如果报错或者显示的是吃豆小人，检查你的名称，一定要正确</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">img:</span> <span class="string">/image/luogic.jpg</span></span><br><span class="line">  <span class="comment">#effect: true # 头像会一直转，转的贼快，太鬼畜了（emmm，超级抽象，别设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#顶部图片设置，就是主页的那张背景图，建议设置400px，默认的全屏容易让人找不到博客在哪里</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">index_img:</span> <span class="string">/image/流萤.jpg</span></span><br><span class="line"><span class="attr">default_top_img:</span> <span class="string">/image/流萤.jpg</span></span><br><span class="line"><span class="attr">index_top_img_height:</span>  <span class="comment">#顶部图高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#背景动态</span></span><br><span class="line"><span class="attr">canvas_fluttering_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span> <span class="comment"># false 手机端不显示 true 手机端显示</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#页面加载动画</span></span><br><span class="line"><span class="comment">#加载动画</span></span><br><span class="line"><span class="attr">preloader:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">source:</span> <span class="number">1</span> <span class="comment">#可选值1=fullpage或2=progress bar，可查看https://codebyzach.github.io/pace/</span></span><br><span class="line">  <span class="attr">pace_css_url:</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#池塘养鱼（最底部）+渐变色</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line"> <span class="attr">head:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;/styles/fish.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/styles/main.css&quot;&gt;</span>   </span><br><span class="line"> <span class="attr">bottom:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#搜索功能</span></span><br><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">3</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">CDN:</span></span><br><span class="line"><span class="comment">#数学公式支持</span></span><br><span class="line"><span class="attr">katex:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># true 表示每一页都加载katex.js</span></span><br><span class="line">  <span class="comment"># false 需要时加载，须在使用的Markdown Front-matter 加上 katex: true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">hide_scrollbar:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="config-yml">_config.yml</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">龙锦</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;买不起茅台 &#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">龙金伟</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://username.github.io</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># Apply to the whole site</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">syntax_highlighter:</span> <span class="string">highlight.js</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">prismjs:</span></span><br><span class="line">  <span class="attr">preprocess:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Metadata elements</span></span><br><span class="line"><span class="comment">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span></span><br><span class="line"><span class="attr">meta_generator:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="string">HH:mm:ss</span></span><br><span class="line"><span class="comment">## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;</span></span><br><span class="line"><span class="attr">updated_option:</span> <span class="string">&#x27;mtime&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Include / Exclude file(s)</span></span><br><span class="line"><span class="comment">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span></span><br><span class="line"><span class="attr">include:</span></span><br><span class="line"><span class="attr">exclude:</span></span><br><span class="line"><span class="attr">ignore:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="comment"># deploy:</span></span><br><span class="line"><span class="comment">#   type: &#x27;&#x27;</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/longjinw/longjinw.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br><span class="line">  <span class="comment"># message: Site updated: &#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125;)</span></span><br><span class="line"><span class="comment">#搜索</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line"><span class="comment">#数学支chi</span></span><br><span class="line"><span class="attr">markdown:</span></span><br><span class="line">    <span class="attr">plugins:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;@renbaoshuo/markdown-it-katex&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 命令使用</title>
    <url>/2024/06/23/hexo_%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>这个是官网（可以查看主题以及更新）：<a href="https://hexo.io/">Hexo</a><br>
这篇文章是hexo第一篇文章. 点击 <a href="https://hexo.io/docs/">documentation</a> 可以获得更多信息.<br>
可以在 <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> 找到绝大部分hexo相关问题，或者直接去 <a href="https://github.com/hexojs/hexo/issues">GitHub</a>评论留言.</p>
<h2 id="快速开始">快速开始</h2>
<h3 id="创建一个新的文章，文章默认在source-ports-目录下面">创建一个新的文章，文章默认在source/ _ports /目录下面</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>相关: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="在本地上启动">在本地上启动</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>相关: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="生成静态文件">生成静态文件</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>相关: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="部署到网站">部署到网站</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>相关: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>C++语言特性相关</title>
    <url>/2024/07/03/C-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h4 id="左值和右值">左值和右值</h4>
<p>左值和右值是C/C++编程语言中的两个重要概念，它们在赋值、引用以及类型转换等方面表现出明显的区别。</p>
<h5 id="定义：">定义：</h5>
<ul>
<li><strong>左值</strong>：表示存储在计算机内存中的对象，具有持久性和可寻址性。即，左值能够用“取地址&amp;”运算符获得其内存地址，且在表达式结束后依然存在。左值可以出现在赋值语句的左侧，也可以出现在右侧。</li>
<li><strong>右值</strong>：与左值相对，右值通常表示临时对象，它们不具有持久性和可寻址性。即，右值不能用“取地址&amp;”运算符获得其内存地址，且在表达式结束后就不再存在。右值只能出现在赋值语句的右侧。</li>
</ul>
<h5 id="左-右值引用">左/右值引用</h5>
<ul>
<li><strong>左值引用</strong>：左值引用是对左值的引用，即给左值取别名。左值引用在C++中的内部实现通常是一个常量指针，左值引用可以引用非常量左值和常量左值，但不能直接引用右值。</li>
<li><strong>右值引用</strong>：右值引用是C++11中引入的新特性，用于引用右值。它允许程序员延长临时对象的生命周期，并在需要时移动资源而不是复制资源。用 <code>&amp;&amp;</code> 表示，右值引用只能绑定到右值上，不能绑定到左值上（除非通过 <code>std::move</code> 强制转换）</li>
</ul>
<h5 id="转换">转换</h5>
<ul>
<li><strong>左值到右值的隐式转换</strong>：在大多数情况下，左值可以隐式地转化为右值。例如，在赋值操作中，左侧的左值会“退化”为右值，以便与右侧的右值进行匹配。</li>
<li><strong>右值到左值的显式转换</strong>：右值到左值的显式转化通常是不允许的，因为右值在表达式结束后就不再存在。然而，通过 <code>std::move</code> 可以将左值强制转化为右值引用，从而允许对其进行移动操作。</li>
</ul>
<h5 id="std-move">std::move</h5>
<ul>
<li>
<p><strong>类型转换</strong>： 并不实际移动任何数据，而是将其参数转换为右值引用，从而允许利用移动语义（如果可用）进行资源的转移，而不是复制。</p>
</li>
<li>
<p><strong>函数原型</strong>：<code>std::move()</code> 函数原型：<code>move</code> 函数是将任意类型的左值转为其类型的右值引用。</p>
</li>
</ul>
<h4 id="指针">指针</h4>
<p>在C++中，指针是一种非常基础且强大的特性，它允许你直接访问和操作内存地址。指针存储了变量的内存地址，而不是变量的值本身。</p>
<ul>
<li>大小：<code>sizeof</code>获得</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Size of pointer: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>*) &lt;&lt; std::endl; <span class="comment">// 输出指针大小  </span></span><br></pre></td></tr></table></figure>
<ul>
<li>用法：基本用法包括声明、初始化、解引用（或取值）、指针运算等</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明和初始化</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;  </span><br><span class="line"><span class="type">int</span>* ptr = &amp;a; <span class="comment">// ptr 是一个指向 int 类型的指针，它存储了变量 a 的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解引用,使用 * 运算符来访问指针所指向的值：</span></span><br><span class="line">std::cout &lt;&lt; *ptr &lt;&lt; std::endl; <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针运算，指针可以进行算术运算，但仅限于加上或减去整数（表示偏移量），以及指针之间的比较。</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  </span><br><span class="line"><span class="type">int</span>* p = arr; <span class="comment">// p 指向数组的第一个元素  </span></span><br><span class="line">std::cout &lt;&lt; *(p + <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 输出 3，因为 p+2 指向了数组的第三个元素</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意事项：</li>
</ul>
<ol>
<li><strong>空指针</strong>：未初始化的指针是未定义的，可能指向任意内存地址。通常将指针初始化为<code>nullptr</code>（C++11及以后）或<code>NULL</code>（C++11之前，但在C++11中已不推荐使用）来避免野指针问题。</li>
<li><strong>越界访问</strong>：指针运算时要小心，确保不要越界访问内存。</li>
<li><strong>悬挂指针</strong>：如果指针指向的对象被删除或释放，但该指针未被设置为<code>nullptr</code>，则该指针成为悬挂指针。尝试通过悬挂指针访问内存是未定义行为。</li>
<li><strong>内存泄漏</strong>：使用动态内存分配（如<code>new</code>）时，要确保在适当的时候释放内存（使用<code>delete</code>），以避免内存泄漏。</li>
<li><strong>智能指针</strong>：C++11及以后版本中引入了智能指针（如<code>std::unique_ptr</code>、<code>std::shared_ptr</code>等），它们可以自动管理动态分配的内存，减少内存泄漏的风险。</li>
<li><strong>指针和数组</strong>：在C++中，数组名在大多数情况下会被视为指向数组首元素的指针。但是，这种用法有一些陷阱，比如数组名本身不是一个可修改的左值。</li>
</ol>
<h4 id="指针和引用区别">指针和引用区别</h4>
<p>指针和引用的主要区别可以简单归纳如下：</p>
<ol>
<li>
<p><strong>定义与性质</strong>：</p>
<ul>
<li>指针：是一个变量，存储的是另一个变量的内存地址。</li>
<li>引用：是某个变量的别名，与原变量共享同一块内存空间，实质上是同一个东西。</li>
</ul>
</li>
<li>
<p><strong>内存分配</strong>：</p>
<ul>
<li>指针：需要分配内存空间来存储地址值。</li>
<li>引用：不需要分配额外的内存空间，它只是一个别名。</li>
</ul>
</li>
<li>
<p><strong>初始化和赋值</strong>：</p>
<ul>
<li>指针：可以在定义时不初始化，之后可以指向任何有效的内存地址，包括NULL。</li>
<li>引用：必须在定义时初始化，且之后不能再改变为引用另一个变量。</li>
</ul>
</li>
<li>
<p><strong>多级性</strong>：</p>
<ul>
<li>指针：可以有多级，例如指向指针的指针。</li>
<li>引用：只能是一级的，不能有多级引用。</li>
</ul>
</li>
<li>
<p><strong>空值</strong>：</p>
<ul>
<li>指针：可以为空（NULL或nullptr）。</li>
<li>引用：不能为NULL，必须始终引用一个有效的对象。</li>
</ul>
</li>
<li>
<p><strong>sizeof运算符</strong>：</p>
<ul>
<li>指针：使用sizeof返回的是指针本身的大小（通常是4字节或8字节，取决于系统架构）。</li>
<li>引用：使用sizeof返回的是被引用变量的大小。</li>
</ul>
</li>
<li>
<p><strong>运算操作</strong>：</p>
<ul>
<li>指针：支持算术运算（如加减）和比较运算。</li>
<li>引用：不支持算术运算，主要用于别名访问。</li>
</ul>
</li>
<li>
<p><strong>函数参数</strong>：</p>
<ul>
<li>指针和引用作为函数参数时，都可以改变实参的值，但引用在语法上更为简洁，且使用上更安全。</li>
</ul>
</li>
<li>
<p><strong>安全性</strong>：</p>
<ul>
<li>指针：使用时需要更加小心，因为错误的指针操作可能导致程序崩溃或安全问题。</li>
<li>引用：相对更安全，因为它在定义时必须初始化，并且不能改变为引用另一个变量。</li>
</ul>
</li>
</ol>
<h4 id="常量指针和指针常量">常量指针和指针常量</h4>
<p>常量指针和指针常量在C++中是两种常见的指针类型，尽管它们都涉及到<code>const</code>关键字，但它们的含义和应用场景存在明显的区别。以下是对这两种指针的详细比较：</p>
<h5 id="本质区别">本质区别</h5>
<ul>
<li><strong>常量指针</strong>：本质上是一个指针，<code>const</code>修饰的是指针指向的内容，表示该指针指向一个“常量”，即指针指向的变量的值不能通过该指针来改变。</li>
<li><strong>指针常量</strong>：本质上是一个常量，<code>const</code>修饰的是指针本身，表示该常量是一个指针类型的常量，即指针的值（即它所指向的地址）不能改变。</li>
</ul>
<h5 id="声明方式">声明方式</h5>
<ul>
<li><strong>常量指针</strong>：通常声明为<code>const 数据类型 *指针变量名</code>，例如<code>const int *p = &amp;a;</code>，这里<code>p</code>是一个指向整型常量的指针，不能通过<code>p</code>来修改<code>a</code>的值，但<code>p</code>可以指向另一个整型变量的地址。</li>
<li><strong>指针常量</strong>：通常声明为<code>数据类型 * const 指针变量名</code>，例如<code>int *const q = &amp;a;</code>，这里<code>q</code>是一个指针常量，它的值（即它指向的地址）不能被修改，但可以通过<code>q</code>来修改它所指向的变量的值（如果那个变量不是常量的话）。</li>
</ul>
<h5 id="应用场景">应用场景</h5>
<ul>
<li>
<p><strong>常量指针</strong>：常用于需要保护数据不被意外修改的场景，同时又想通过指针来访问这些数据。</p>
</li>
<li>
<p><strong>指针常量</strong>：常用于需要确保指针始终指向同一个地址的场景，比如某些资源的句柄或引用，一旦初始化后就不应该再指向其他地址。</p>
</li>
<li>
<p><strong>常量指针示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a; <span class="comment">// p 是常量指针，指向 a</span></span><br><span class="line"><span class="comment">// *p = 20; // 编译错误，不能通过 p 修改 a 的值</span></span><br><span class="line">p = &amp;b; <span class="comment">// 正确，p 可以指向另一个变量 b</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>指针常量示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> q = &amp;a; <span class="comment">// q 是指针常量，指向 a</span></span><br><span class="line">*q = <span class="number">20</span>; <span class="comment">// 正确，可以通过 q 修改 a 的值</span></span><br><span class="line"><span class="comment">// q = &amp;b; // 编译错误，q 不能指向其他地址</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="函数指针">函数指针</h4>
<p>函数指针是C和C++语言中的一个特性，它允许程序员将函数的地址存储在变量中，并通过这个变量来调用函数。函数指针的概念是高级且强大的，因为它提供了一种机制来动态地调用不同的函数，基于运行时条件。</p>
<h5 id="函数指针的声明">函数指针的声明</h5>
<p>函数指针的声明需要指定函数返回值的类型、函数名（在这里我们使用指针名代替）以及函数的参数列表（包括参数的类型和数量）。但是，在声明函数指针时，我们不需要函数名，而是使用指针名来引用这个函数。</p>
<p>例如，假设我们有一个函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure>
<p>要声明一个指向这个函数的指针，我们可以这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*ptrToAdd)(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<p>这里，<code>ptrToAdd</code>是一个指针，它指向一个函数，该函数接受两个<code>int</code>类型的参数并返回一个<code>int</code>类型的值。</p>
<h5 id="函数指针的赋值">函数指针的赋值</h5>
<p>一旦我们声明了函数指针，就可以将函数的地址赋给它。在C和C++中，函数名就代表了函数的地址，因此我们可以直接将函数名赋给函数指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ptrToAdd = add; <span class="comment">// 将add函数的地址赋给ptrToAdd</span></span><br></pre></td></tr></table></figure>
<h5 id="通过函数指针调用函数">通过函数指针调用函数</h5>
<p>有了函数指针之后，我们就可以通过这个函数指针来调用函数了。调用方式是通过解引用函数指针，并像调用普通函数一样传递参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> result = ptrToAdd(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 等同于调用 add(5, 3)</span></span><br></pre></td></tr></table></figure>
<h5 id="函数指针的应用">函数指针的应用</h5>
<p>函数指针在C和C++中有很多应用，包括但不限于：</p>
<ul>
<li><strong>回调函数</strong>：在某些API中，你可以将函数指针作为参数传递给另一个函数，这个被传递的函数指针指向的函数会在某个特定事件发生时被调用。</li>
<li><strong>排序函数</strong>：例如，在C标准库中的<code>qsort</code>函数，它接受一个比较函数的指针作为参数，这个比较函数用于定义排序的准则。</li>
<li><strong>动态函数表</strong>：通过函数指针数组，可以实现基于运行时条件的函数选择，这在实现多态或构建插件系统时非常有用。</li>
<li><strong>事件处理</strong>：在图形用户界面（GUI）编程中，事件处理函数通常是通过函数指针来指定的，这样当特定事件（如按钮点击）发生时，相应的函数就会被调用。</li>
</ul>
<h4 id="值-引用-指针传递">值/引用/指针传递</h4>
<p>在参数传递中，值传递、引用传递和指针传递是C++（以及C语言）中常见的三种方式，它们各自具有不同的特点和用途。以下是这三种传递方式的详细区别：</p>
<h5 id="值传递（Pass-by-Value）">值传递（Pass by Value）</h5>
<p><strong>定义</strong>：值传递时，形参是实参的副本（复制、拷贝）。即函数接收的是实参的一个拷贝，函数体内对形参的任何修改都不会影响到实参。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>单向性</strong>：数据只能从实参传递到形参，不能反向传递。</li>
<li><strong>独立性</strong>：形参和实参是两个独立的变量，它们占据不同的内存空间。</li>
<li><strong>效率</strong>：对于大型对象或结构体，值传递可能会导致较高的内存开销和性能损耗，因为需要复制整个对象。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    <span class="comment">// 这里a和b的交换不会影响实参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="引用传递（Pass-by-Reference）">引用传递（Pass by Reference）</h5>
<p><strong>定义</strong>：引用传递时，实参的引用（即内存地址）被传递给形参。形参和实参指向同一块内存地址，因此函数体内对形参的修改会直接影响到实参。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>双向性</strong>：数据可以在实参和形参之间双向传递。</li>
<li><strong>共享性</strong>：形参和实参共享同一块内存空间，对形参的修改会反映到实参上。</li>
<li><strong>效率</strong>：对于大型对象或结构体，引用传递可以避免不必要的复制，提高效率。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    <span class="comment">// 这里a和b的交换会影响实参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="指针传递（Pass-by-Pointer）">指针传递（Pass by Pointer）</h5>
<p><strong>定义</strong>：指针传递时，实参的地址（即指针）被传递给形参。形参是一个指针变量，它存储了实参的地址，因此函数体内可以通过解引用形参来修改实参的值。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>间接访问</strong>：通过指针可以间接访问和修改实参的值。</li>
<li><strong>灵活性</strong>：指针传递提供了更高的灵活性，可以动态地修改多个变量的值。</li>
<li><strong>风险</strong>：指针操作相对复杂，容易出错，如野指针、空指针解引用等问题。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">    <span class="comment">// 这里通过解引用指针来交换实参的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="适用">适用</h5>
<ul>
<li><strong>值传递</strong>：适用于不需要修改实参的场景，或者实参是基本数据类型时。</li>
<li><strong>引用传递</strong>：适用于需要修改实参的场景，特别是当实参是大型对象或结构体时，可以提高效率。</li>
<li><strong>指针传递</strong>：提供了更高的灵活性，但也需要更谨慎的操作，以避免指针相关的错误。</li>
</ul>
<h4 id="迭代器">迭代器</h4>
<p>迭代器模式（Iterator Pattern）是一种行为型设计模式，它提供了一种方法顺序访问一个容器对象中的各个元素，而又不暴露其内部的细节。</p>
<p>迭代器模式的核心思想是将集合的遍历功能从集合对象中分离出来，形成一个独立的迭代器对象来管理访问集合元素的逻辑。</p>
<ul>
<li>
<p>迭代器为不同数据结构提供统一的访问接口，使得遍历数据变得简单统一，同时支持高效处理大型数据集，通过逐个访问元素节省内存资源。</p>
</li>
<li>
<p>迭代器不仅限于遍历，还能与算法结合实现复杂数据处理，支持惰性计算，提升代码可读性和可维护性，是现代编程中不可或缺的工具。</p>
</li>
</ul>
<h4 id="野指针和悬空指针">野指针和悬空指针</h4>
<p>野指针和悬空指针是编程中常见的两种指针问题，它们通常会导致程序出现不可预测的行为和潜在的错误。</p>
<h5 id="野指针（Wild-Pointer）">野指针（Wild Pointer）</h5>
<p><strong>定义</strong>：<br>
野指针是指向一个已删除的对象或未申请访问受限内存区域的指针。野指针的值是不确定的，可能指向任何位置，包括操作系统不允许访问的内存区域。</p>
<p><strong>危害</strong>：<br>
访问野指针通常会导致程序崩溃或未定义行为，因为它可能指向任意内存地址，包括操作系统不允许访问的内存区域。</p>
<p><strong>成因</strong>：</p>
<ul>
<li><strong>指针变量未初始化</strong>：任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的。如果指针变量在创建时没有初始化，它将指向一个不确定的内存地址，从而成为野指针。</li>
<li><strong>指针释放之后未置空</strong>：有时指针在free或delete后未赋值NULL，此时指针仍然指向已被释放的内存地址，但该内存可能已经被系统重新分配给其他对象，因此该指针成为野指针。</li>
<li><strong>指针操作超越变量作用域</strong>：例如，函数返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放，返回的指针将成为野指针。</li>
</ul>
<p><strong>预防措施</strong>：</p>
<ul>
<li><strong>初始化时置NULL</strong>：指针变量在创建时应立即初始化为NULL或有效的内存地址。</li>
<li><strong>释放时置NULL</strong>：当指针指向的内存空间释放时，应立即将指针置为NULL，防止产生野指针。</li>
<li><strong>避免返回局部变量的地址</strong>：不要从函数中返回局部变量的地址，因为局部变量在函数返回后会被销毁。</li>
</ul>
<h5 id="悬空指针（Dangling-Pointer）">悬空指针（Dangling Pointer）</h5>
<p><strong>定义</strong>：<br>
悬空指针是指一个曾经指向有效内存区域，但由于该内存区域已经被释放或变得无效，因此现在指向一个不再可用的内存地址的指针。</p>
<p><strong>危害</strong>：<br>
尝试通过悬空指针访问内存通常会导致程序崩溃或未定义行为，因为指针指向的内存区域已经不再可用。</p>
<p><strong>成因</strong>：</p>
<ol>
<li><strong>内存释放后继续使用</strong>：动态分配的内存被释放（如使用free()函数），但指针仍然指向原来的内存地址。</li>
<li><strong>函数返回局部变量的地址</strong>：与野指针类似，但悬空指针特指在内存被释放后仍然指向该内存地址的情况。</li>
<li><strong>使用已经释放的资源</strong>：例如，文件被关闭后，仍然使用指向该文件的指针。</li>
</ol>
<p><strong>预防措施</strong>：</p>
<ul>
<li><strong>释放内存后置空指针</strong>：在使用free()或delete释放动态分配的内存后，立即将指针置为NULL。</li>
<li><strong>避免返回局部变量的地址</strong>：同上，不要从函数中返回局部变量的地址。</li>
<li><strong>谨慎使用动态内存分配</strong>：尽量减少动态内存分配的使用，特别是在不需要的情况下。如果必须使用，确保正确管理内存的生命周期。</li>
</ul>
<h4 id="nullptr-与-NULL">nullptr 与 NULL</h4>
<ul>
<li>NULL：预处理变量，是一个宏，它的值是 0，定义在头文件 <cstdlib> 中，即 #define NULL 0。</li>
<li>nullptr：C++ 11 中的关键字，是一种特殊类型的字面值，可以被转换成任意其他类型。</li>
</ul>
<h5 id="nullptr优势：">nullptr优势：</h5>
<ul>
<li>有类型，类型是 typdef decltype(nullptr) nullptr_t;，使用 nullptr 提高代码的健壮性。</li>
<li>函数重载：因为 NULL 本质上是 0，在函数调用过程中，若出现函数重载并且传递的实参是 NULL，可能会出现不知和哪一个函数匹配的情况；但是传递实参 nullptr 就不会出现这种情况。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++语言特性</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo文章主题头内各个数据的意义</title>
    <url>/2024/06/24/hexo%E6%96%87%E7%AB%A0%E4%B8%BB%E9%A2%98%E5%A4%B4%E9%87%8C%E5%A1%AB%E5%86%99%E7%9A%84%E6%84%8F%E6%80%9D/</url>
    <content><![CDATA[<h3 id="页面编写（page）">页面编写（page）</h3>
<table>
<thead>
<tr>
<th style="text-align:left">写法</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">title</td>
<td style="text-align:left">【必需】页面标题</td>
</tr>
<tr>
<td style="text-align:left">date</td>
<td style="text-align:left">【必需】页面创建日期</td>
</tr>
<tr>
<td style="text-align:left">type</td>
<td style="text-align:left">【必需】标签、分类和友情链接三个页面需要配置</td>
</tr>
</tbody>
</table>
<h3 id="文章编辑（port1）">文章编辑（port1）</h3>
<table>
<thead>
<tr>
<th style="text-align:left">写法</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">title</td>
<td style="text-align:left">【必需】文章标题</td>
</tr>
<tr>
<td style="text-align:left">date</td>
<td style="text-align:left">【必需】文章创建日期</td>
</tr>
<tr>
<td style="text-align:left">tagas</td>
<td style="text-align:left">【可选】文章标签</td>
</tr>
<tr>
<td style="text-align:left">categories</td>
<td style="text-align:left">【可选】文章分类</td>
</tr>
<tr>
<td style="text-align:left">keywords</td>
<td style="text-align:left">【可选】文章关键字</td>
</tr>
<tr>
<td style="text-align:left">description</td>
<td style="text-align:left">【可选】文章描述</td>
</tr>
<tr>
<td style="text-align:left">cover</td>
<td style="text-align:left">【可选】文章图标</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客编写</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown建议上手之-图表绘制</title>
    <url>/2024/07/01/markdown%E5%BB%BA%E8%AE%AE%E4%B8%8A%E6%89%8B%E4%B9%8B-%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6/</url>
    <content><![CDATA[<h3 id="流程图绘制相关">流程图绘制相关</h3>
<h4 id="mermaid简述">mermaid简述</h4>
<p>特性：Mermaid制图是一种基于文本的图表绘制方法，它使用类似于Markdown的语法来描述图表，并可以将其转换为SVG或其他图形格式进行展示。特点是简单易学功能强大，能够满足大部分简易制图要求，（要是太难了为什么不直接贴图呢）</p>
<p>其他：</p>
<ul>
<li>Mermaid支持通过CSS样式来自定义图表的外观和布局。（不建议，太复杂不如贴图）</li>
<li>Mermaid图表可以导出为PNG、SVG等常见的图像格式。（不会，遇到了在学）</li>
<li>Mermaid支持插件和编辑器的集成，使得用户可以更加高效地使用和管理Mermaid图表。</li>
<li><strong>在Markdown编辑器中，可以直接使用Mermaid语法来创建和渲染图表。</strong>（Typora可以）。</li>
<li><strong>支持流程图、序列图、甘特图。</strong></li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>在markdown编辑中，要写在代码框里，所以要先在最开始打出<code>```mermaid</code> 唤醒这个对应代码（Typora里）。</li>
</ul>
<h4 id="简单的流程图：">简单的流程图：</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">graph TB  </span><br><span class="line">A[开始] --&gt; B[处理]  </span><br><span class="line">B --&gt; C&#123;判断&#125;  </span><br><span class="line">C -- 是 --&gt; D[结束]  </span><br><span class="line">C -- 否 --&gt; E[处理]  </span><br><span class="line">E --&gt; B</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB  </span><br><span class="line">A[开始] --&gt; B[处理]  </span><br><span class="line">B --&gt; C&#123;判断&#125;  </span><br><span class="line">C -- 是 --&gt; D[结束]  </span><br><span class="line">C -- 否 --&gt; E[处理]  </span><br><span class="line">E --&gt; B</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="简单的序列图：">简单的序列图：</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sequenceDiagram  </span><br><span class="line">A-&gt;&gt;B: 消息<span class="number">1</span>  </span><br><span class="line">B-&gt;&gt;C: 消息<span class="number">2</span>  </span><br><span class="line">C--&gt;&gt;A: 响应  </span><br><span class="line">loop 循环操作  </span><br><span class="line">  A-&gt;&gt;B: 消息<span class="number">3</span>  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram  </span><br><span class="line">A-&gt;&gt;B: 消息1  </span><br><span class="line">B-&gt;&gt;C: 消息2  </span><br><span class="line">C--&gt;&gt;A: 响应  </span><br><span class="line">loop 循环操作  </span><br><span class="line">  A-&gt;&gt;B: 消息3  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="简单的甘特图">简单的甘特图</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gantt  </span><br><span class="line">dateFormat  YYYY-MM-DD  </span><br><span class="line">title       项目进度  </span><br><span class="line">section SectionA  </span><br><span class="line">TaskA       :active,    a1, <span class="number">2023</span><span class="number">-01</span><span class="number">-01</span>, <span class="number">30</span>d  </span><br><span class="line">TaskB       :           b1, after a1, <span class="number">20</span>d</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gantt  </span><br><span class="line">dateFormat  YYYY-MM-DD  </span><br><span class="line">title       项目进度  </span><br><span class="line">section SectionA  </span><br><span class="line">TaskA       :active,    a1, 2023-01-01, 30d  </span><br><span class="line">TaskB       :           b1, after a1, 20d</span><br></pre></td></tr></table></figure>
<h4 id="具体语法">具体语法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">主要分成三层：</span><br><span class="line">标志层：选择graph、sequenceDiagram 、gantt选择你要制的图</span><br><span class="line">语法层：中间填入对应语法</span><br><span class="line">结束层：end表示结束</span><br></pre></td></tr></table></figure>
<h4 id="流程图（Flowchart）">流程图（Flowchart）</h4>
<ul>
<li>使用<code>graph</code>关键词定义图表类型，如<code>graph TB</code>（从上到下）或<code>graph RL</code>（从右到左）。</li>
<li>使用<code>A --&gt; B</code>表示从节点A到节点B的箭头。</li>
<li>支持条件判断，如<code>C -- 是 --&gt; D[结果1]</code>。</li>
</ul>
<h5 id="序列图（Sequence-Diagram）">序列图（Sequence Diagram）</h5>
<ul>
<li>使用<code>sequenceDiagram</code>关键词定义。</li>
<li>通过<code>-&gt;&gt;</code>表示参与者之间的消息传递。</li>
<li>可以使用<code>loop</code>、<code>alt</code>等关键词描述循环和选择结构。</li>
</ul>
<h5 id="甘特图（Gantt-Chart）">甘特图（Gantt Chart）</h5>
<ul>
<li>使用<code>gantt</code>关键词定义。</li>
<li>定义任务和时间轴，如<code>section SectionName</code>和<code>TaskName :crit, active, x-day1, x3-day4</code>。</li>
</ul>
<h5 id="节点形状">节点形状</h5>
<ul>
<li>节点可以通过不同的括号和关键词来定义形状，如：
<ul>
<li><code>[方形]</code></li>
<li><code>(圆边矩形)</code></li>
<li><code>((圆形))</code></li>
<li><code>&#123;菱形&#125;</code></li>
<li>// 注释</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown简易上手</title>
    <url>/2024/06/23/markdown%E7%AE%80%E6%98%93%E4%B8%8A%E6%89%8B/</url>
    <content><![CDATA[<h1>markdown简易上手</h1>
<h3 id="编写渠道">编写渠道</h3>
<ul>
<li>软件：收费：<a href="https://typora.ymzhxing.cn/index.html?bd_vid=12314572084174744930%22%E4%B8%AD%E6%96%87%E7%BD%91%E7%AB%99%22">Typora</a>  不收费：<a href="https://apps.microsoft.com/detail/xp9khm4bk9fz7q?launch=true&amp;mode=full&amp;hl=zh-cn&amp;gl=cn&amp;ocid=bingwebsearch%22%E5%AE%98%E7%BD%91%22">VS Code</a>。</li>
<li>网站：程序员聚集网站都有这个功能如<a href="https://www.csdn.net/">CSDN</a>、<a href="https://github.com/">Github</a>。</li>
</ul>
<h3 id="VS-studio配置编辑器的链接">VS studio配置编辑器的链接</h3>
<ul>
<li>这告诉你怎么增加一个Markdown的扩展：<a href="https://blog.csdn.net/qq_35504602/article/details/108054416%22%E9%85%8D%E7%BD%AE%E8%BF%9E%E6%8E%A5%22">VS studio</a></li>
</ul>
<h3 id="起源与定义">起源与定义</h3>
<ul>
<li>起源：由约翰·格鲁伯（John Gruber）创建，旨在简化纯文本格式的文档编写。</li>
<li>定义：一种纯文本格式的标记语言，可选择性地转换为有效的XHTML（或HTML）。</li>
<li>特性：语法简单，纯文本，可使用文本编辑器打开，并化成其他格式（HTML文档等）。</li>
</ul>
<h3 id="常用语法">常用语法</h3>
<ul>
<li>标题: #+“空格”+标题内容，得到标题，多个#号得到多级标题，最多6级；</li>
<li>引用：&gt;+“空格”+内容，得到引用内容</li>
<li>有序列表：序号+“空格”+内容<br>
 1 序列一<br>
 2 序列二<br>
 3 序列三</li>
<li>无序列表：-+“空格”+内容
<ul>
<li>a</li>
<li>b</li>
<li>c</li>
</ul>
</li>
<li>任务列表：-+‘‘空格’’+[ ],[]里面也要有空格
<ul>
<li>[ ] 任务一</li>
<li>[ ] 任务二</li>
<li>[ ] 任务三</li>
</ul>
</li>
<li>代码块：```c 三个反引号（键盘上和波浪线在一起）+语言  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">在这里插入代码 </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>数学公式：$$,中间加公式（不会也不打算学，就不做实列了</li>
<li>表格：|A|B|C|	表格头<br>
   |:—|—: | :—: |对齐方式：左。右。居中。<br>
   |qq|eee|wwww |打完按enter</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:right">B</th>
<th style="text-align:center">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">qqq</td>
<td style="text-align:right">eee</td>
<td style="text-align:center">www</td>
</tr>
</tbody>
</table>
<ul>
<li>脚注：ABC [ ^abc]————在文末或者下一行+[ ^abc]:注释内容就行<br>
ABC[^abc]<br>
[^abc]:skfkdsaif</li>
<li>横线：— 三个-生成一条横线，打完按enter</li>
</ul>
<hr>
<ul>
<li>链接：[ 百度]( caidu m&quot;注释&quot;) 会得到一个链接,中间的网址正确的话<br>
 <a href="baidu.com%22%E6%B3%A8%E9%87%8A%22"> 百度</a></li>
<li>图片：![百度]（）括号里面是图片链接</li>
<li>视频：直接找到网站上的视频，复制嵌入链接粘贴即可</li>
</ul>
<h3 id="行内格式">行内格式</h3>
<ul>
<li>斜体：**</li>
<li>加粗：****</li>
<li>编写行内代码：''反引号</li>
</ul>
<p><code>ssss</code></p>
<ul>
<li>下划线：&lt; u&gt;&lt; /u&gt;</li>
<li>行内数学公式：$$</li>
<li>高亮文字：== a==</li>
<li>首行缩进：&amp;emsp；</li>
</ul>
]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库——redis常见面试题</title>
    <url>/2024/07/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94redis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="redis">redis</h4>
<p>Redis是一个高性能的、基于内存的Key-Value数据库，支持多种数据结构，如字符串、哈希、列表、集合和有序集合。它提供快速读写能力，常用于缓存、消息队列、会话管理等场景。Redis支持持久化，保障数据不丢失，同时支持高可用性和可扩展性，通过主从复制和集群部署实现。尽管内存大小有限，但Redis的高性能和灵活性使其成为互联网应用中不可或缺的一部分。</p>
<h4 id="redis与mysql">redis与mysql</h4>
<p>Redis是一个高速的内存数据库，适用于需要快速访问的场景；而MySQL是一个功能强大的关系型数据库，适用于需要复杂查询和事务处理的应用程序。</p>
<ol>
<li>
<p><strong>类型与存储</strong>：</p>
<ul>
<li>Redis：非关系型（NoSQL），主要基于内存存储，读写速度极快。</li>
<li>MySQL：关系型数据库（RDBMS），数据存储在磁盘上，支持复杂查询和事务处理。</li>
</ul>
</li>
<li>
<p><strong>数据持久化</strong>：</p>
<ul>
<li>Redis：提供RDB和AOF两种机制，将数据从内存保存到磁盘以防止数据丢失。</li>
<li>MySQL：通过其存储引擎（如InnoDB）的日志和事务机制来保证数据的持久性。</li>
</ul>
</li>
<li>
<p><strong>数据结构</strong>：</p>
<ul>
<li>Redis：支持多种数据结构，如字符串、哈希、列表、集合和有序集合。</li>
<li>MySQL：主要支持表结构，包含行和列，以及丰富的数据类型。</li>
</ul>
</li>
<li>
<p><strong>应用场景</strong>：</p>
<ul>
<li>Redis：常用于缓存、消息队列、实时数据分析等需要高速访问的场景。</li>
<li>MySQL：适用于需要复杂查询、事务处理和数据持久化的应用程序数据库。</li>
</ul>
</li>
<li>
<p><strong>性能</strong>：</p>
<ul>
<li>Redis：因为数据存储在内存中，所以性能极高，适合处理大量并发读写操作。</li>
<li>MySQL：虽然性能也很强，但受限于磁盘I/O，相对于Redis来说读写速度较慢。</li>
</ul>
</li>
</ol>
<h4 id="Redis-和-MongoDB">Redis 和 MongoDB</h4>
<p>MongoDB 和 Redis 都是 NoSQL，采用结构型数据存储，二者之间的主要区别如下所示：</p>
<ol>
<li>
<p><strong>性能</strong>：</p>
<ul>
<li>Redis：作为一个内存数据库，其性能非常高，特别是对于读写操作。它适用于需要高速缓存和实时数据处理的场景。</li>
<li>MongoDB：虽然性能也很强，但更侧重于处理大规模数据集和复杂查询。它通过索引、查询优化和分片等技术来提高性能。</li>
</ul>
</li>
<li>
<p><strong>数据结构与查询</strong>：</p>
<ul>
<li>Redis：支持多种数据结构，如字符串、哈希、列表、集合和有序集合，但查询语言相对简单。</li>
<li>MongoDB：使用类似于JSON的BSON格式存储数据，支持丰富的查询语言和索引，操作灵活且强大，最接近于关系数据库。</li>
</ul>
</li>
<li>
<p><strong>存储与内存管理</strong>：</p>
<ul>
<li>Redis：主要依赖内存存储数据，但提供了虚拟内存功能（尽管在现代版本中可能不再常用）以突破物理内存限制。</li>
<li>MongoDB：将数据存储在磁盘上，但会利用内存缓存热点数据。它依赖操作系统的内存管理机制。</li>
</ul>
</li>
<li>
<p><strong>数据持久化与恢复</strong>：</p>
<ul>
<li>Redis：通过RDB快照和AOF日志来确保数据的持久化，但AOF可能会影响访问性能。</li>
<li>MongoDB：采用oplog（操作日志）来支持复制和恢复操作，增强了数据的可靠性。</li>
</ul>
</li>
<li>
<p><strong>事务支持</strong>：</p>
<ul>
<li>Redis：支持简单的事务，通过MULTI、EXEC等命令保证一系列命令的原子性执行。</li>
<li>MongoDB：从4.0版本开始支持多文档事务，能够在单个复制集的多个集合中保证数据的一致性。</li>
</ul>
</li>
<li>
<p><strong>数据分析</strong>：</p>
<ul>
<li>Redis：本身不支持数据分析功能，但可以与其他数据分析工具集成。</li>
<li>MongoDB：内置MapReduce框架，支持在数据库内部执行大规模数据分析。</li>
</ul>
</li>
<li>
<p><strong>应用场景</strong>：</p>
<ul>
<li>Redis：适用于需要高速缓存、实时数据处理、消息队列等场景，适合处理较小到中等规模的数据集。</li>
<li>MongoDB：适合处理大规模数据集，支持复杂查询、数据分析和高可扩展性，常用于Web应用的后端数据库、日志分析等场景。</li>
</ul>
</li>
</ol>
<h4 id="Redis支持的几种数据">Redis支持的几种数据</h4>
<p>Redis的常用数据类型主要包括五种基础数据类型和三种特殊数据类型。以下是这些数据类型的详细概述：</p>
<h5 id="五种基础数据类型">五种基础数据类型</h5>
<ol>
<li>
<p><strong>String（字符串）</strong></p>
<ul>
<li><strong>简介</strong>：String是Redis中最基础且最常用的数据类型。它是二进制安全的，可以用来存储任何类型的数据，如字符串、整数、浮点数、二进制数据（如图片、音频、视频等）的编码或路径，以及序列化后的对象。</li>
<li><strong>应用场景</strong>：常用于缓存、计数器、共享session、限速等场景。</li>
<li><strong>常用命令</strong>：包括SET、GET、INCR、DECR、MSET、MGET等。</li>
</ul>
</li>
<li>
<p><strong>List（列表）</strong></p>
<ul>
<li><strong>简介</strong>：List是一个简单的字符串列表，按照插入顺序排序。列表中的元素可以是有序的、唯一的，也可以重复。Redis的List底层实现是双向链表或QuickList（Redis 3.2后引入）。</li>
<li><strong>应用场景</strong>：可以用于实现队列、栈、分页查询等功能。</li>
<li><strong>常用命令</strong>：包括RPUSH、LPUSH、LPOP、RPOP、LRANGE等。</li>
</ul>
</li>
<li>
<p><strong>Set（集合）</strong></p>
<ul>
<li><strong>简介</strong>：Set是string类型的无序集合，集合成员是唯一的，不允许重复。Redis的Set是通过哈希表实现的，因此添加、删除和查找的复杂度都是O(1)。</li>
<li><strong>应用场景</strong>：常用于实现去重、交集、并集、差集等操作。</li>
<li><strong>常用命令</strong>：包括SADD、SREM、SMEMBERS、SINTER、SUNION等。</li>
</ul>
</li>
<li>
<p><strong>Hash（哈希）</strong></p>
<ul>
<li><strong>简介</strong>：Hash是string类型的field和value的映射表，特别适合用于存储对象。Redis的Hash内部实现类似于JDK 1.8前的HashMap，是数组加链表的组合。</li>
<li><strong>应用场景</strong>：常用于存储结构化数据，如用户信息、购物车等。</li>
<li><strong>常用命令</strong>：包括HSET、HGET、HMSET、HMGET、HDEL等。</li>
</ul>
</li>
<li>
<p><strong>Zset（有序集合）</strong></p>
<ul>
<li><strong>简介</strong>：Zset和Set一样也是string类型元素的集合，且不允许重复的成员。不同的是，Zset的每个元素都会关联一个double类型的分数，Redis正是通过分数来为集合中的成员进行从小到大的排序。</li>
<li><strong>应用场景</strong>：常用于实现排行榜、带权重的集合等功能。</li>
<li><strong>常用命令</strong>：包括ZADD、ZREM、ZRANGE、ZREVRANGE等。</li>
</ul>
</li>
</ol>
<h5 id="三种特殊数据类型">三种特殊数据类型</h5>
<ol>
<li>
<p><strong>HyperLogLog</strong></p>
<ul>
<li><strong>简介</strong>：HyperLogLog是一种用于基数统计的数据类型，能够在有限的空间内完成独立总数的统计，并且误差率极低。</li>
<li><strong>应用场景</strong>：适用于统计UV（独立访客数）等场景。</li>
</ul>
</li>
<li>
<p><strong>Bitmap</strong></p>
<ul>
<li><strong>简介</strong>：Bitmap是通过操作一系列的bit位来进行记录的数据类型，其最大优点是空间节省。</li>
<li><strong>应用场景</strong>：常用于统计用户是否在线、用户活跃度等场景。</li>
</ul>
</li>
<li>
<p><strong>Geospatial</strong></p>
<ul>
<li><strong>简介</strong>：Geospatial是Redis 3.2版本引入的，用于地理位置信息的数据类型。</li>
<li><strong>应用场景</strong>：适用于实现如附近的人、地理位置查询等功能。</li>
</ul>
</li>
</ol>
<h4 id="redis的定时机制实现">redis的定时机制实现</h4>
<p>Redis 服务器是一个 事件驱动程序，服务器需要处理以下两类事件：文件事件 （服务器对套接字操作的抽象）和 时间事件（服务器对定时操作的抽象）。Redis 的定时机制就是借助时间事件实现的。</p>
<p>一个时间事件主要由以下三个属性组成：id，时间事件标识号；when，记录时间事件的到达时间；timeProc，时间事件处理器，当时间事件到达时，服务器就会调用相应的处理器来处理时间。一个时间事件根据时间事件处理器的返回值来判断是定时事件还是周期性事件。</p>
<h4 id="单线程-Redis，为什么如此高效">单线程 Redis，为什么如此高效</h4>
<p>虽然 Redis 文件事件处理器以单线程方式运行，但是通过使用 I/O 多路复用程序 来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>shell脚本编写基础</title>
    <url>/2024/06/27/shell%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="shell脚本编辑">shell脚本编辑</h3>
<p>具体了解推荐：<a href="https://blog.csdn.net/weixin_53072519/article/details/125009092?ops_request_misc=%7B%22request%5Fid%22%3A%22171949229516777224488979%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171949229516777224488979&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125009092-null-null.142%5Ev100%5Econtrol&amp;utm_term=shell%E7%BC%96%E7%A8%8B&amp;spm=1018.2226.3001.4187">Linux实操篇——shell入门</a></p>
<h4 id="shell：">shell：</h4>
<ul>
<li>概念：Shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。</li>
<li>性质：一个命令行解释器，解释由用户输入的命令并把它们送到内核去执行。</li>
<li>作用：用户与内核进行交互的接口，负责接收用户输入的命令并送入内核执行</li>
</ul>
<h4 id="shell脚本：">shell脚本：</h4>
<ul>
<li>概念：用于编写自动化任务、批处理脚本和系统管理脚本的脚本语言</li>
<li>性质：利用Shell的功能所写的程序，写入到一个纯文本文件中。</li>
<li>作用：自动化执行一系列命令，减少手动操作的工作量，提高工作效率。</li>
</ul>
<h4 id="shell命令：">shell命令：</h4>
<p>Shell常见命令涵盖了文件目录操作、系统状态查看、网络配置与诊断、文件压缩与解压缩等多个方面。</p>
<h5 id="文件目录类">文件目录类</h5>
<h6 id="ls-列出目录内容"><code>ls</code> 列出目录内容</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l :显示详细的文件信息</span><br><span class="line">ls -a :显示隐藏文件</span><br><span class="line">ls -lS :以人类可读格式显示文件大小</span><br><span class="line">ls -lh :按文件大小排序</span><br></pre></td></tr></table></figure>
<h6 id="cd-切换目录"><code>cd</code> 切换目录</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd :切换到当前用户的home目录</span><br><span class="line">cd /path/bbb :切换到指定目录。</span><br><span class="line">cd .. :返回上一级目录。</span><br><span class="line">popd  :返回到前一个工作目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="pwd-显示当前目录路径。"><code>pwd</code> 显示当前目录路径。</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pwd :会显示当前工作目录</span><br></pre></td></tr></table></figure>
<h6 id="mkdir-创建目录。"><code>mkdir</code> 创建目录。</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir AAA :创建目录AAA</span><br><span class="line">mkdir AAA BBB CCC :创建多个目录，只有某些shell里面有</span><br><span class="line">mkdir -p A/B/C :创建三层目录A/B/C</span><br></pre></td></tr></table></figure>
<h6 id="cp-复制文件或目录"><code>cp</code> 复制文件或目录</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp A B :A被复制到B（B存在则覆盖，不存在则创建）</span><br><span class="line">cp A B KKK/:A B复制到KKK目录下面</span><br><span class="line">cp -r A B/ :复制A到B（B必须存在）</span><br></pre></td></tr></table></figure>
<h6 id="rm-删除文件或目录"><code>rm</code> 删除文件或目录</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm A :删除名为A的文件</span><br><span class="line">rm A B C :删除多个文件</span><br><span class="line">rm -r KKK :删除目录及其内容（一般是-rf,不用确认）</span><br></pre></td></tr></table></figure>
<h6 id="cat查看文件内容"><code>cat</code>查看文件内容</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat A :查看文件内容（-n对每一行输出加上行号，-s不显示多余空白行）</span><br><span class="line">cat A B&gt;C :合并A、B到C里去</span><br><span class="line">cat A&gt;&gt;B  :向B里面追加A的内容</span><br></pre></td></tr></table></figure>
<h6 id="more-less-分页查看文件内容"><code>more</code>,<code> less</code> 分页查看文件内容</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">more -5 A :显示A的前五行（内容超过终端大小的时候，按空格键翻页）</span><br><span class="line">less -N A :显示A，并添加行号(在less中使用/A 来搜索A)</span><br></pre></td></tr></table></figure>
<h6 id="head-tail查看文件的开头或结尾部分内容"><code>head</code>,<code>tail</code>查看文件的开头或结尾部分内容</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">head A :显示A前<span class="number">10</span>行(-n <span class="number">20</span>显示前<span class="number">20</span>行 -c <span class="number">20</span>显示前<span class="number">20</span>个字节)</span><br><span class="line">tail A :显示A后<span class="number">10</span>行(-n <span class="number">20</span>显示后<span class="number">20</span>行 -f 实时跟踪文件更新内容)</span><br></pre></td></tr></table></figure>
<h6 id="find-搜索文件"><code>find</code> 搜索文件</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find [路径][选项][表达式][操作]</span><br><span class="line">find /A/b -name&quot;*.log&quot; -ls :查找？、/A/b 目录先所有.log文件，并ls出来</span><br></pre></td></tr></table></figure>
<h6 id="ln-创建链接"><code>ln</code> 创建链接</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln [选项] 源文件 目标文件或者目录</span><br><span class="line">ln A B :B是A的一个硬链接（-s就是软连接）</span><br></pre></td></tr></table></figure>
<h6 id="du显示目录所占用的磁盘空间"><code>du</code>显示目录所占用的磁盘空间</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">du [选项][文件或者目录]</span><br><span class="line">du -h :显示当前目录及其子目录的磁盘使用情况（人类可读）</span><br><span class="line">du -sh /A/B :显示/A/B目录的磁盘使用情况</span><br></pre></td></tr></table></figure>
<h5 id="文件压缩和归档">文件压缩和归档</h5>
<h6 id="tar打包与压缩文件"><code>tar</code>打包与压缩文件</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar [选项] 归档文件 目标</span><br><span class="line">tar -czvf A.tar.gz AAA/ :创建一个gzip压缩的tar归档文件</span><br><span class="line">tar -xzvf A.tar.gz      :从gzip压缩的tar归档文件中提取内容</span><br></pre></td></tr></table></figure>
<h6 id="gzip-gunzip-压缩和解压-gz文件"><code>gzip</code>,<code>gunzip</code> 压缩和解压.gz文件</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gzip A :把A压缩成A.gz(-k 保留源文件，否则不保留)</span><br><span class="line">gzip -r A/ :压缩A目录中所有文件</span><br><span class="line">gunzip A.gz :把A.gz解压缩到A（-k保留源文件，否则不保留）</span><br><span class="line">gunzip -c A.gz&gt;A :这会将 A.gz 解压缩后的数据写入 A，而不会删除或覆盖任何文件。</span><br></pre></td></tr></table></figure>
<h5 id="系统状态类">系统状态类</h5>
<h6 id="top-监控系统资源利用情况"><code>top</code> 监控系统资源利用情况</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top 	:内容多，系统时间、运行时间、登录用户数、系统负载：进程列表：内存和交换空间信息：</span><br><span class="line">man top :获取更详细的信息和用法说明。</span><br></pre></td></tr></table></figure>
<h6 id="df显示磁盘空间使用情况"><code>df</code>显示磁盘空间使用情况</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df     :文件系统：1K-块：已用：可用：已用%：挂载点：</span><br><span class="line">man df :了解更多用法说明</span><br></pre></td></tr></table></figure>
<h6 id="uptime显示系统运行时间和负载"><code>uptime</code>显示系统运行时间和负载</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uptime  :当前时间 up 系统运行时间, 用户数, load average: 最近1分钟, 最近5分钟, 最近15分钟</span><br></pre></td></tr></table></figure>
<h6 id="who-w显示当前登录在系统上的用户信息"><code>who</code>,<code>w</code>显示当前登录在系统上的用户信息</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">who   :显示用户名、登录终端、登录时间以及从哪个主机登录（如果适用）</span><br><span class="line">w 	  :提供了更详细的信息</span><br></pre></td></tr></table></figure>
<h5 id="网络类">网络类</h5>
<h6 id="ping检查网络连通性"><code>ping</code>检查网络连通性</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping &lt;hostname-or-ip-address&gt;  :一个地址</span><br></pre></td></tr></table></figure>
<h6 id="ifconfig配置网络接口参数"><code>ifconfig</code>配置网络接口参数</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig:将显示系统上所有活动网络接口的信息，包括IP地址、子网掩码、广播地址、MAC地址等。</span><br></pre></td></tr></table></figure>
<h6 id="netstat显示网络连接、路由表、网卡统计数信息"><code>netstat</code>显示网络连接、路由表、网卡统计数信息</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat :是一个命令行工具，用于显示网络连接、路由表、接口统计等网络相关信息。</span><br></pre></td></tr></table></figure>
<h6 id="traceroute追踪网络数据包传输路径"><code>traceroute</code>追踪网络数据包传输路径</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">是一个网络诊断工具，用于跟踪和显示数据包从源主机到目标主机所经过的每一跳（路由器）的路径。</span><br></pre></td></tr></table></figure>
<h5 id="其他">其他</h5>
<h6 id="man，info查看命令的帮助文档"><code>man</code>，<code>info</code>查看命令的帮助文档</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man [命令]  :查看详细内容</span><br><span class="line">info [主题] :访问GUN项目的Info文档</span><br></pre></td></tr></table></figure>
<h6 id="alias创建命令别名"><code>alias</code>创建命令别名</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias :查看所有别名</span><br><span class="line">alias ll=&#x27;ls -l&#x27;:设置‘ll’为‘ls -l’的别名</span><br></pre></td></tr></table></figure>
<h6 id="chmod，chown，chgrp-修改文件权限，所属用户和组"><code>chmod</code>，<code>chown</code>，<code>chgrp</code> 修改文件权限，所属用户和组</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 750 文件名</span><br><span class="line">数字7代表所有者权限（4+2+1=7，即读/写/执行）。</span><br><span class="line">数字5代表组权限（4+1=5，即读/执行）。</span><br><span class="line">末尾的0代表其他用户无权限。</span><br><span class="line"></span><br><span class="line">sudo chown 新用户名 文件名</span><br><span class="line"></span><br><span class="line">sudo chgrp 新组名 文件名</span><br></pre></td></tr></table></figure>
<h6 id="history查看命令历史记录"><code>history</code>查看命令历史记录</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">history :显示所有历史命令</span><br></pre></td></tr></table></figure>
<h4 id="shell脚本编辑-2">shell脚本编辑</h4>
<p>Shell脚本本质上是纯文本文件(.sh)，其中包含一系列要由shell（如bash、sh、zsh等）执行的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span>  </span><br><span class="line">echo &quot;Hello, World!&quot;  </span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure>
<h5 id="shell变量">shell变量</h5>
<p>在Shell脚本中，变量是用于存储数据的占位符。Shell变量可以存储数字、字符串、文件名等任何类型的数据。Shell变量是区分大小写的，并且在使用时不需要声明其类型。</p>
<h6 id="定义变量">定义变量</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义一个字符串变量</span>  </span><br><span class="line">my_string=&quot;Hello, World!&quot;  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义一个数字变量</span>  </span><br><span class="line">my_number=42  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义一个特殊字符或空格的变量（需要使用引号）</span>  </span><br><span class="line">my_special_var=&quot;This is a string with spaces&quot;</span><br></pre></td></tr></table></figure>
<h6 id="使用变量">使用变量</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">引用变量</span>  </span><br><span class="line">echo $my_string  # 输出: Hello, World!  </span><br><span class="line">echo $my_number  # 输出: 42  </span><br><span class="line">echo $my_special_var  # 输出: This is a string with spaces  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以使用花括号来明确变量的边界（当变量名后紧跟其他字符时）</span>  </span><br><span class="line">echo $&#123;my_string&#125;World  # 输出: Hello, World!World  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变量名大小写敏感</span>  </span><br><span class="line">echo $MY_STRING  # 输出为空，因为MY_STRING未定义</span><br></pre></td></tr></table></figure>
<h6 id="变量赋值">变量赋值</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用反引号进行命令替换</span>  </span><br><span class="line">files_count=`ls | wc -l`  </span><br><span class="line">echo $files_count  # 输出当前目录下的文件数量  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用$(...)进行命令替换</span>  </span><br><span class="line">files_count=$(ls | wc -l)  </span><br><span class="line">echo $files_count  # 同样输出当前目录下的文件数量</span><br></pre></td></tr></table></figure>
<h5 id="shell运算符">shell运算符</h5>
<h6 id="算数运算符">算数运算符</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span>  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接赋值</span>  </span><br><span class="line">num1=10  </span><br><span class="line">num2=20  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加法</span>  </span><br><span class="line">sum=$((num1 + num2))  </span><br><span class="line">echo &quot;The sum is: $sum&quot;  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">乘法</span>  </span><br><span class="line">product=$((num1 * num2))  </span><br><span class="line">echo &quot;The product is: $product&quot;  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">幂运算（使用<span class="built_in">expr</span>命令）</span>  </span><br><span class="line">result=$(expr $num1 ** $num2)  </span><br><span class="line">echo &quot;The result of $num1 to the power of $num2 is: $result&quot;  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋值运算符</span>  </span><br><span class="line">num1+=5  </span><br><span class="line">echo &quot;After adding 5 to num1, it is: $num1&quot;</span><br></pre></td></tr></table></figure>
<h6 id="关系运算符">关系运算符</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span>  </span><br><span class="line">  </span><br><span class="line">num1=10  </span><br><span class="line">num2=20  </span><br><span class="line">  </span><br><span class="line">if [ $num1 -eq $num2 ]; then  </span><br><span class="line">    echo &quot;num1 is equal to num2&quot;  </span><br><span class="line">elif [ $num1 -gt $num2 ]; then  </span><br><span class="line">    echo &quot;num1 is greater than num2&quot;  </span><br><span class="line">else  </span><br><span class="line">    echo &quot;num1 is less than num2&quot;  </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h6 id="布尔运算符">布尔运算符</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span>  </span><br><span class="line">  </span><br><span class="line">num1=10  </span><br><span class="line">num2=20  </span><br><span class="line">  </span><br><span class="line">if [ $num1 -eq 10 ] &amp;&amp; [ $num2 -eq 20 ]; then  </span><br><span class="line">    echo &quot;Both num1 and num2 are correct&quot;  </span><br><span class="line">else  </span><br><span class="line">    echo &quot;At least one of the numbers is incorrect&quot;  </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h6 id="字符串运算符">字符串运算符</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span>  </span><br><span class="line">  </span><br><span class="line">str1=&quot;Hello&quot;  </span><br><span class="line">str2=&quot;World&quot;  </span><br><span class="line">  </span><br><span class="line">if [ $str1 = $str2 ]; then  </span><br><span class="line">    echo &quot;$str1 is equal to $str2&quot;  </span><br><span class="line">else  </span><br><span class="line">    echo &quot;$str1 is not equal to $str2&quot;  </span><br><span class="line">fi  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查字符串长度是否为零</span>  </span><br><span class="line">str3=&quot;&quot;  </span><br><span class="line">if [ -z &quot;$str3&quot; ]; then  </span><br><span class="line">    echo &quot;str3 is empty&quot;  </span><br><span class="line">else  </span><br><span class="line">    echo &quot;str3 is not empty&quot;  </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h6 id="文件测试运算符">文件测试运算符</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span>  </span><br><span class="line">  </span><br><span class="line">file=&quot;/path/to/some/file.txt&quot;  </span><br><span class="line">  </span><br><span class="line">if [ -e &quot;$file&quot; ]; then  </span><br><span class="line">    echo &quot;The file $file exists&quot;  </span><br><span class="line">elif [ -d &quot;$file&quot; ]; then  </span><br><span class="line">    echo &quot;The $file is a directory&quot;  </span><br><span class="line">else  </span><br><span class="line">    echo &quot;The file $file does not exist&quot;  </span><br><span class="line">fi  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查文件是否可读、可写、可执行</span>  </span><br><span class="line">if [ -r &quot;$file&quot; ]; then  </span><br><span class="line">    echo &quot;The file $file is readable&quot;  </span><br><span class="line">fi  </span><br><span class="line">  </span><br><span class="line">if [ -w &quot;$file&quot; ]; then  </span><br><span class="line">    echo &quot;The file $file is writable&quot;  </span><br><span class="line">fi  </span><br><span class="line">  </span><br><span class="line">if [ -x &quot;$file&quot; ]; then  </span><br><span class="line">    echo &quot;The file $file is executable&quot;  </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h6 id="命令替换运算符">命令替换运算符</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span>  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用命令替换获取当前日期</span>  </span><br><span class="line">today=$(date)  </span><br><span class="line">echo &quot;Today&#x27;s date is: $today&quot;  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用命令替换获取文件内容（假设文件为file.txt）</span>  </span><br><span class="line">content=$(cat file.txt)  </span><br><span class="line">echo &quot;The content of file.txt is:&quot;  </span><br><span class="line">echo &quot;$content&quot;</span><br></pre></td></tr></table></figure>
<h6 id="字符串引用">字符串引用</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span>  </span><br><span class="line">  </span><br><span class="line">name=&quot;John Doe&quot;  </span><br><span class="line">greeting=&quot;Hello, $&#123;name&#125;!&quot;  </span><br><span class="line">echo &quot;$greeting&quot;  # 输出: Hello, John Doe!  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用双引号保留特殊字符</span>  </span><br><span class="line">path=&quot;/home/$USER/Documents&quot;  </span><br><span class="line">echo &quot;$path&quot;  # 输出: /home/username/Documents（其中username是当前登录用户的用户名）</span><br></pre></td></tr></table></figure>
<h5 id="shell条件判断">shell条件判断</h5>
<p>在Shell脚本中，条件判断是非常重要的，它允许脚本根据某些条件执行不同的代码块。Shell提供了多种条件判断的方式，下面是一些常见的例子：</p>
<h6 id="测试命令">测试命令</h6>
<pre><code>* `[ ]` 或 `test` 命令用于执行条件测试。
* 常见的测试有文件测试（如 `-f` 检查文件是否存在且是一个普通文件）、字符串测试（如 `=`, `!=` 比较字符串）和数字测试（如 `-eq`, `-ne`, `-gt`, `-lt`, `-ge`, `-le` 比较数字）。
</code></pre>
<h6 id="if-语句">if 语句</h6>
<p>使用 <code>if</code>, <code>elif</code> 和 <code>else</code> 进行条件判断。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># code to execute if condition is true</span></span><br><span class="line"><span class="keyword">elif</span> [ another_condition ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># code to execute if another_condition is true</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># code to execute if none of the conditions are true</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h6 id="字符串比较">字符串比较</h6>
<pre><code>* `=`, `==`：检查两个字符串是否相等。
* `!=`：检查两个字符串是否不相等。
* `-z`：检查字符串长度是否为零。
* `-n`：检查字符串长度是否非零。
</code></pre>
<h6 id="数字比较">数字比较</h6>
<pre><code>* `-eq`：等于
* `-ne`：不等于
* `-gt`：大于
* `-lt`：小于
* `-ge`：大于或等于
* `-le`：小于或等于
</code></pre>
<h6 id="文件测试">文件测试</h6>
<pre><code>* `-e`：文件存在
* `-f`：是一个普通文件
* `-d`：是一个目录
* `-r`：文件可读
* `-w`：文件可写
* `-x`：文件可执行
* `-s`：文件大小非零
* `-L`：是一个符号链接
* 等等...
</code></pre>
<h6 id="逻辑操作符">逻辑操作符</h6>
<pre><code>* `!`：逻辑非
* `-a` 或 `&amp;&amp;`：逻辑与
* `-o` 或 `||`：逻辑或
</code></pre>
<h6 id="示例">示例</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查文件是否存在</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;/path/to/file.txt&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;File exists.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;File does not exist.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查两个数字是否相等</span></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -eq <span class="variable">$b</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;a is equal to b&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;a is not equal to b&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用逻辑操作符</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;/path/to/file1.txt&quot;</span> ] &amp;&amp; [ -f <span class="string">&quot;/path/to/file2.txt&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Both files exist.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;One or both files do not exist.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>注意：在 <code>[</code> 和 <code>]</code> 之间以及 <code>[</code> 之后和 <code>]</code> 之前都需要有空格。例如，<code>[ -f &quot;/path/to/file.txt&quot; ]</code> 是正确的，但 <code>[ -f&quot;/path/to/file.txt&quot;]</code> 是错误的。</p>
<h5 id="shell流程控制">shell流程控制</h5>
<p>在Shell脚本中，流程控制是非常重要的，它允许脚本根据条件或循环执行不同的代码块。除了前面提到的条件判断（如<code>if</code>、<code>elif</code>、<code>else</code>）外，Shell还提供了循环结构（如<code>for</code>、<code>while</code>、<code>until</code>）以及控制结构（如<code>break</code>、<code>continue</code>）。</p>
<h6 id="条件判断-if-elif-else">条件判断(<code>if</code>, <code>elif</code>, <code>else</code>)</h6>
<p>之前已经提到，<code>if</code>语句用于根据条件执行不同的代码块。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># code to execute if condition is true</span></span><br><span class="line"><span class="keyword">elif</span> [ another_condition ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># code to execute if another_condition is true</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># code to execute if none of the conditions are true</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h6 id="循环结构">循环结构</h6>
<ul>
<li>
<p><strong>for循环</strong>：用于遍历列表（如数组或字符串）中的元素。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> variable <span class="keyword">in</span> list</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># code to execute for each element in list</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>或者使用C风格的for循环：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (( i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># code to execute for each iteration</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>while循环</strong>：当条件为真时，重复执行代码块。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> [ condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># code to execute while condition is true</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>until循环</strong>：当条件为假时，重复执行代码块。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">until</span> [ condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># code to execute until condition is true</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="控制结构">控制结构</h6>
<ul>
<li>
<p><strong>break</strong>：用于立即终止循环（最内层循环）。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> [ <span class="literal">true</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># some code</span></span><br><span class="line">    <span class="keyword">if</span> [ some_condition ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>continue</strong>：用于跳过当前循环迭代，直接进入下一次迭代。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$file</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">continue</span>  <span class="comment"># skip directories</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="comment"># process files</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="函数：允许你定义可重用的代码块，并在脚本中多次调用。">函数：允许你定义可重用的代码块，并在脚本中多次调用。</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">my_function</span></span>() &#123;</span><br><span class="line">    <span class="comment"># code to execute when function is called</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># calling the function</span></span><br><span class="line">my_function</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p><strong>case语句</strong>：类似于其他编程语言中的switch语句，用于根据变量的值执行不同的代码块。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="variable">$variable</span> <span class="keyword">in</span></span><br><span class="line">    pattern1)</span><br><span class="line">        <span class="comment"># code to execute if $variable matches pattern1</span></span><br><span class="line">        ;;</span><br><span class="line">    pattern2)</span><br><span class="line">        <span class="comment"># code to execute if $variable matches pattern2</span></span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        <span class="comment"># code to execute if $variable doesn&#x27;t match any patterns</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>select语句</strong>：用于创建菜单，允许用户从一组选项中选择一个。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> option <span class="keyword">in</span> <span class="string">&quot;Option 1&quot;</span> <span class="string">&quot;Option 2&quot;</span> <span class="string">&quot;Quit&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$option</span> <span class="keyword">in</span></span><br><span class="line">        <span class="string">&quot;Option 1&quot;</span>)</span><br><span class="line">            <span class="comment"># code for Option 1</span></span><br><span class="line">            ;;</span><br><span class="line">        <span class="string">&quot;Option 2&quot;</span>)</span><br><span class="line">            <span class="comment"># code for Option 2</span></span><br><span class="line">            ;;</span><br><span class="line">        <span class="string">&quot;Quit&quot;</span>)</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Invalid option&quot;</span></span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这些流程控制结构使Shell脚本能够处理复杂的逻辑和场景。</p>
<h5 id="shell读取控制台输入">shell读取控制台输入</h5>
<p>在Shell脚本中，你可以使用<code>read</code>命令来读取控制台输入。<code>read</code>命令允许你从标准输入（通常是键盘）读取一行数据，并将其存储在变量中。</p>
<p>以下是如何使用<code>read</code>命令的基本示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示用户输入名字</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;请输入你的名字: &quot;</span></span><br><span class="line"><span class="built_in">read</span> name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出用户输入的名字</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;你好, <span class="variable">$name</span>!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以同时读取多个变量的值</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;请输入你的名字和年龄，用空格分隔: &quot;</span></span><br><span class="line"><span class="built_in">read</span> firstname lastname age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出用户输入的名字和年龄</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;你好, <span class="variable">$firstname</span> <span class="variable">$lastname</span>! 你的年龄是 <span class="variable">$age</span>。&quot;</span></span><br></pre></td></tr></table></figure>
<p>在上面的脚本中，<code>echo -n</code>命令用于打印提示信息，但是<code>-n</code>选项会阻止换行符的打印，这样提示信息就会和用户的输入在同一行显示。</p>
<p><code>read</code>命令后面跟着的变量名（如<code>name</code>、<code>firstname</code>、<code>lastname</code>和<code>age</code>）用于存储用户的输入。当用户输入数据后，这些数据会被存储在相应的变量中，然后你可以在你的脚本中使用这些变量。</p>
<p>如果你想要读取密码或其他敏感信息，并且不希望这些信息在输入时显示在屏幕上，你可以使用<code>read</code>命令的<code>-s</code>选项，这样用户的输入就会被隐藏：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;请输入密码: &quot;</span></span><br><span class="line"><span class="built_in">read</span> -s password</span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="comment"># 注意：这里我们加了一个echo命令来创建一个新的行，因为-s选项会阻止换行符的打印</span></span><br></pre></td></tr></table></figure>
<p>另外，如果你想要限制用户输入的字符数，你可以使用<code>-n</code>选项（注意这里的<code>-n</code>和前面用于禁止换行的<code>-n</code>不同）和一个数字来指定最大字符数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;请输入最多5个字符的字符串: &quot;</span></span><br><span class="line"><span class="built_in">read</span> -n 5 input_string</span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="comment"># input_string现在将包含用户输入的前5个字符（或更少的字符，如果用户输入少于5个字符）</span></span><br></pre></td></tr></table></figure>
<p>1</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库——事务管理</title>
    <url>/2024/07/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h4 id="事务管理">事务管理</h4>
<p>事务管理是对一系列数据库操作进行管理的过程，这些操作被视为一个不可分割的工作单元（原子单元）。事务管理在数据库系统中起着至关重要的作用，它确保了数据的一致性和完整性，防止了数据在并发操作中出现不一致或损坏的情况。</p>
<h4 id="事务的定义">事务的定义</h4>
<p>事务是数据库管理系统中的一个概念，用于管理一组数据库操作，使它们作为一个不可分割的工作单元执行。一个事务可以包含一个或多个SQL语句，这些语句要么全部执行成功，要么全部回滚（撤销），从而确保数据库的数据一致性和完整性。</p>
<h4 id="事务的特性（ACID）">事务的特性（ACID）</h4>
<p>事务具有四个基本特性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），这四个特性通常简称为ACID。</p>
<ul>
<li><strong>原子性</strong>：事务是一个原子操作，由一系列动作组成。事务的原子性确保这些动作要么全部完成，要么完全不起作用，从而避免了部分成功、部分失败的情况。</li>
<li><strong>一致性</strong>：事务必须使数据库从一个一致性状态转换到另一个一致性状态。这意味着事务的执行不会破坏数据库的约束和规则，确保数据的正确性。</li>
<li><strong>隔离性</strong>：事务的隔离性确保了多个并发事务之间的隔离，避免了数据交叉访问和干扰，保证了每个事务的独立性。不同的隔离级别会影响事务的并发性能和一致性保证程度。</li>
<li><strong>持久性</strong>：一旦事务被提交，其对数据库的更改就会持久保存，即使系统崩溃也不会丢失。这确保了事务的更改能够长期保存并供后续操作使用。</li>
</ul>
<h4 id="事务管理的作用">事务管理的作用</h4>
<p>事务管理的作用主要体现在以下几个方面：</p>
<ul>
<li><strong>保证数据的一致性</strong>：通过确保事务的原子性，事务管理可以防止因部分操作失败而导致的数据不一致问题。</li>
<li><strong>确保数据的完整性</strong>：事务的ACID特性共同作用，确保数据的完整性和正确性，防止数据丢失或损坏。</li>
<li><strong>提供隔离性</strong>：通过控制事务的隔离级别，事务管理可以避免不同事务之间的干扰和冲突，保证每个事务的独立性。</li>
<li><strong>支持并发操作</strong>：在并发环境下，事务管理通过并发控制和恢复机制，确保多个事务能够同时执行而不相互干扰。</li>
</ul>
<h4 id="事务管理的实现方式">事务管理的实现方式</h4>
<p>在不同的数据库管理系统中，事务管理的实现方式可能有所不同。但一般来说，事务管理包括并发控制和恢复两部分。</p>
<ul>
<li><strong>并发控制</strong>：并发控制涉及到多个事务对数据库的某个公共部分进行同时存取的自动控制。为了提高死锁检测的效率，尽早发现“隐藏”的死锁，并发控制机制会有效地表示各种等待关系，并处理死锁等并发问题。</li>
<li><strong>恢复</strong>：恢复机制用于在事务失败或系统崩溃时恢复数据库到一致性状态。这通常包括撤销（Undo）和重做（Redo）两个步骤。撤销操作用于回滚事务的更改，而重做操作则用于重新执行那些因系统崩溃而未能完成的事务。</li>
</ul>
<h4 id="事务状态">事务状态</h4>
<ol>
<li>数据库事务的状态描述了事务在其生命周期中所处的不同阶段。根据多个来源的信息，数据库事务的状态通常包括以下几种：</li>
</ol>
<ul>
<li><strong>活动的（Active）</strong>：事务对应的数据库操作正在执行过程中，此时事务处于活动的状态。这是事务的初始状态，表示事务已经开始执行，但尚未完成。</li>
<li><strong>部分提交的（Partially Committed）</strong>：事务内部最后一个操作执行结束，但此时数据更新处于内存级别，还未刷新到磁盘中，称事务处于部分提交的状态。在这个阶段，事务的修改已经在内存中完成，但还没有被永久保存到磁盘上。</li>
<li><strong>失败的（Failed）</strong>：当事务处在活动的或者部分提交状态时，可能遇到了某些错误（如数据库自身的错误、操作系统错误或直接断电）而无法继续执行，或者人为停止当前事务的执行，此时事务处于失败的状态。</li>
<li><strong>中止的（Aborted）</strong>：事务处于失败状态时，会进行回滚操作，即将数据库恢复到事务执行前的状态，回滚后事务处于中止的状态。这是事务处理失败后的最终状态，表示事务的所有修改都已被撤销，数据库回到了事务开始之前的状态。</li>
<li><strong>提交的（Committed）</strong>：当一个处在部分提交的状态的事务将修改过的数据从内存同步到磁盘之后，该事务就处于提交的状态。这是事务处理成功的最终状态，表示事务的所有修改都已被永久保存到数据库中。</li>
</ul>
<ol start="2">
<li>事务状态的转换通常遵循以下规则：</li>
</ol>
<ul>
<li>事务从活动的状态开始执行。</li>
<li>如果所有操作都成功完成并准备将结果写入磁盘，则事务进入部分提交的状态。</li>
<li>如果在部分提交之前遇到错误，事务将进入失败的状态，并随后被中止（回滚）。</li>
<li>如果所有操作都成功完成并成功将数据写入磁盘，则事务进入提交的状态。</li>
</ul>
<h4 id="事务之间的相互影响">事务之间的相互影响</h4>
<p>事务之间的相互影响主要体现在数据库操作中，特别是在并发环境下，多个事务可能同时访问和修改相同的数据，从而导致一系列问题。这些相互影响主要包括以下几种情况：</p>
<ul>
<li>
<p><strong>脏读（Dirty Read）</strong>：</p>
<p>脏读是指一个事务读取了另一个事务未提交的数据。由于这些数据尚未被提交，因此是有可能回滚的。如果读取数据的事务基于这些未提交的数据进行了进一步的操作，那么当这些未提交的数据被回滚时，基于这些数据的操作就会变得无效或错误。脏读破坏了事务的隔离性。</p>
</li>
<li>
<p><strong>不可重复读（Non-repeatable Read）</strong>：</p>
<p>不可重复读是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同的数据。这是由于查询时系统中其他事务修改的提交而引起的。即使两个查询完全相同，但由于其他事务的介入，导致查询结果发生了变化。不可重复读同样破坏了事务的隔离性，使得事务的多次读取结果不一致。</p>
</li>
<li>
<p><strong>幻读（Phantom Read）</strong>：</p>
<p>幻读是指当事务不是独立执行时发生的一种现象。例如，第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，但这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。幻读也是由于并发事务的介入导致的，它破坏了事务的隔离性，使得事务在多次读取同一数据集合时，看到的数据集合发生了变化。</p>
</li>
<li>
<p><strong>丢失更新（Lost Update）</strong>：</p>
<p>丢失更新是指两个事务同时读取同一条记录，A先修改记录，B也修改记录（B是不知道A修改过的），B提交数据后B的修改结果覆盖了A的修改结果。这种情况下，A的更新被B的更新所覆盖，导致A的更新丢失。丢失更新同样是由于并发事务的介入导致的，它破坏了事务的原子性和一致性。</p>
</li>
</ul>
<h4 id="事务的隔离级别">事务的隔离级别</h4>
<p>为了解决事务之间的相互影响，数据库系统提供了事务隔离级别的概念。事务隔离级别决定了事务之间的可见性和一致性程度。常见的事务隔离级别包括：</p>
<ul>
<li><strong>读未提交（Read Uncommitted）</strong>：允许事务读取未被其他事务提交的变更，这可能导致脏读、不可重复读和幻读。</li>
<li><strong>读已提交（Read Committed）</strong>：确保事务只能读取已经被其他事务提交的变更，这可以避免脏读，但不可重复读和幻读仍可能发生。</li>
<li><strong>可重复读（Repeatable Read）</strong>：确保在同一个事务中多次读取同样记录的结果是一致的，这可以避免脏读和不可重复读，但幻读仍可能发生（在某些数据库系统中，如MySQL的InnoDB存储引擎，通过多版本并发控制MVCC可以进一步避免幻读）。</li>
<li><strong>串行化（Serializable）</strong>：这是最高的隔离级别，它通过强制事务串行执行来避免脏读、不可重复读和幻读。但这种方式会大大降低数据库的并发性能。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令集合</title>
    <url>/2024/06/27/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h3 id="Linux命令">Linux命令</h3>
<p>Linux 是一个功能强大的操作系统，它提供了大量的命令来执行各种任务。以下是一些常用的 Linux 命令及其简要说明</p>
<h4 id="vim编辑器：">vim编辑器：</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim a.java   	进入一般模式</span><br><span class="line">i(按键)   		进入插入模式(编辑模式)</span><br><span class="line">ESC(按键)  		退出</span><br><span class="line">:wq 			保存退出（shift+：调起输入框）</span><br><span class="line">:q！			不保存退出（shift+：调起输入框）（内容有更改）(强制退出，不保留更改内容)</span><br><span class="line">:q				不保存退出（shift+：调起输入框）（没有内容更改）</span><br></pre></td></tr></table></figure>
<h4 id="文件和目录操作：">文件和目录操作：</h4>
<h5 id="ls-列出目录内容"><code>ls</code>: 列出目录内容</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ll				查看当前目录下内容（LL的小写）</span><br></pre></td></tr></table></figure>
<h5 id="cd-更改目录"><code>cd</code>: 更改目录</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~			当前用户目录</span><br><span class="line"><span class="built_in">cd</span> /			根目录</span><br><span class="line"><span class="built_in">cd</span> -			上一次访问的目录</span><br><span class="line"><span class="built_in">cd</span> ..			上一级目录</span><br></pre></td></tr></table></figure>
<h5 id="pwd-显示当前目录路径"><code>pwd</code>: 显示当前目录路径</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span>				查看当前工作目录</span><br></pre></td></tr></table></figure>
<h5 id="mkdir-创建目录"><code>mkdir</code>: 创建目录</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> aaa		在当前目录下创建aaa目录，相对路径；</span><br><span class="line"><span class="built_in">mkdir</span> ./bbb		在当前目录下创建bbb目录，相对路径；</span><br><span class="line"><span class="built_in">mkdir</span> /ccc		在根目录下创建ccc目录，绝对路径；</span><br><span class="line"><span class="built_in">mkdir</span> -p temp/nginx    创建递归目录，创建里面没有的目录文件</span><br></pre></td></tr></table></figure>
<h5 id="rmdir-删除空目录"><code>rmdir</code>: 删除空目录</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="rm-删除文件或目录（需谨慎使用）"><code>rm</code>: 删除文件或目录（需谨慎使用）</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /bbb			强制删除/目录下的bbb目录。如果bbb目录中还有子目录，也会被强制删除，不会提示；</span><br><span class="line"><span class="built_in">rm</span> -r /bbb			普通删除。会询问你是否删除每一个文件</span><br><span class="line"><span class="built_in">rmdir</span> test01		目录的删除</span><br></pre></td></tr></table></figure>
<h5 id="cp-复制文件或目录"><code>cp</code>: 复制文件或目录</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r /aaa /bbb			将/目录下的aaa目录复制到/bbb目录下，在/bbb目录下的名称为aaa</span><br><span class="line"><span class="built_in">cp</span> -r /aa /bbb/aaa		将/目录下的aa目录复制到/bbb目录下，且修改名为aaa;</span><br></pre></td></tr></table></figure>
<h5 id="mv-移动或重命名文件或目录"><code>mv</code>: 移动或重命名文件或目录</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> 原先目录 文件的名称   <span class="built_in">mv</span> tomcat001 tomcat    重命名</span><br><span class="line"><span class="built_in">mv</span>	/aaa /bbb		    将根目录下的aaa目录，移动到bbb目录下(假如没有bbb目录，则重命名为bbb)；</span><br><span class="line"><span class="built_in">mv</span>	bbbb usr/bbb		将当前目录下的bbbb目录，移动到usr目录下，并且修改名称为bbb；</span><br><span class="line"><span class="built_in">mv</span>	bbb usr/aaa			将当前目录下的bbbb目录，移动到usr目录下，并且修改名称为aaa；</span><br></pre></td></tr></table></figure>
<h5 id="touch-创建空文件或更新文件时间戳"><code>touch</code>: 创建空文件或更新文件时间戳</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> testFile    创建文件</span><br></pre></td></tr></table></figure>
<h5 id="ln-创建链接文件（硬链接或符号链接）"><code>ln</code>: 创建链接文件（硬链接或符号链接）</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /usr/local/app /data  创建软连接时，data目录后不加 / (加上后是查找其下一级目录)</span><br></pre></td></tr></table></figure>
<h5 id="find-在文件系统中查找文件"><code>find</code>: 在文件系统中查找文件</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="文本操作">文本操作</h4>
<h5 id="cat-显示文件内容"><code>cat</code>: 显示文件内容</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> a.java		查看a.java文件的最后一页内容；</span><br></pre></td></tr></table></figure>
<h5 id="more-分页显示文件内容"><code>more</code>: 分页显示文件内容</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">more a.java		从第一页开始查看a.java文件内容，按回车键一行一行进行查看，</span><br><span class="line">                    按空格键一页一页进行查看，q退出；</span><br></pre></td></tr></table></figure>
<h5 id="less-与-more-类似，但功能更强大"><code>less</code>: 与 <code>more</code> 类似，但功能更强大</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">less a.java		从第一页开始查看a.java文件内容，按回车键一行一行的看，</span><br><span class="line">                按空格键一页一页的看，支持使用PageDown和PageUp翻页，q退出；</span><br></pre></td></tr></table></figure>
<h5 id="head-显示文件开头内容"><code>head</code>: 显示文件开头内容</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">head</span> a.java				查看a.java文件的前10行内容；</span><br><span class="line"><span class="built_in">head</span> -n 7 a.java		查看a.java文件的前7行内容；</span><br></pre></td></tr></table></figure>
<h5 id="tail-显示文件末尾内容"><code>tail</code>: 显示文件末尾内容</h5>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">tail -<span class="keyword">f</span> <span class="keyword">a</span>.java			查看<span class="keyword">a</span>.java文件的后<span class="number">10</span>行内容；</span><br><span class="line">tail -n <span class="number">7</span> <span class="keyword">a</span>.java		查看<span class="keyword">a</span>.java文件的后<span class="number">7</span>行内容；</span><br></pre></td></tr></table></figure>
<h5 id="grep-在文件中搜索匹配的行"><code>grep</code>: 在文件中搜索匹配的行</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep under 123.txt			在123.txt文件中搜索under字符串，大小写敏感，显示行；</span><br><span class="line">grep -n under 123.txt		在123.txt文件中搜索under字符串，大小写敏感，显示行及行号；</span><br><span class="line">grep -v under 123.txt		在123.txt文件中搜索under字符串，大小写敏感，显示没搜索到的行；</span><br><span class="line">grep -i under 123.txt		在123.txt文件中搜索under字符串，大小写敏感，显示行；</span><br><span class="line">grep -ni under 123.txt		在123.txt文件中搜索under字符串，大小写敏感，显示行及行号；</span><br></pre></td></tr></table></figure>
<h5 id="sed-流编辑器，用于对输入流（文件或管道）进行基本文本转换"><code>sed</code>: 流编辑器，用于对输入流（文件或管道）进行基本文本转换</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/Jack/me/g/ replace.java    全文将Jack替换为me(g是全部替换,不加只替换首个)</span></span><br></pre></td></tr></table></figure>
<h5 id="awk-用于文本和数据提取的工具"><code>awk</code>: 用于文本和数据提取的工具</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk [options] <span class="string">&#x27;cmd&#x27;</span> file</span><br></pre></td></tr></table></figure>
<h4 id="权限和用户管理：">权限和用户管理：</h4>
<h5 id="chmod-更改文件或目录的权限"><code>chmod</code>: 更改文件或目录的权限</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="chown-更改文件或目录的所有者和组"><code>chown</code>: 更改文件或目录的所有者和组</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">##### `chgrp`: 更改文件或目录的组</span></span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<h5 id="useradd-添加新用户"><code>useradd</code>: 添加新用户</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd –d /usr/sum -m <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>
<h5 id="userdel-删除用户"><code>userdel</code>: 删除用户</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">##### `groupadd`: 添加新组</span></span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">groupadd groupname</span><br></pre></td></tr></table></figure>
<h5 id="groupdel-删除组"><code>groupdel</code>: 删除组</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupdel groupname</span><br></pre></td></tr></table></figure>
<h5 id="id-显示当前用户或指定用户的实际和有效用户ID和组ID"><code>id</code>: 显示当前用户或指定用户的实际和有效用户ID和组ID</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#### `su`: 切换到另一个用户账户</span></span></span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<h5 id="sudo-以另一个用户的身份执行命令（通常用于超级用户）"><code>sudo</code>: 以另一个用户的身份执行命令（通常用于超级用户）</h5>
<h4 id="进程管理：">进程管理：</h4>
<h5 id="ps-显示当前进程的快照。"><code>ps</code>: 显示当前进程的快照。</h5>
<h5 id="top-动态显示进程信息（实时）。"><code>top</code>: 动态显示进程信息（实时）。</h5>
<h5 id="htop-一个增强的-top-命令，具有更多的功能和更好的界面。"><code>htop</code>: 一个增强的 top 命令，具有更多的功能和更好的界面。</h5>
<h5 id="kill-发送信号以终止、继续或停止进程。"><code>kill</code>: 发送信号以终止、继续或停止进程。</h5>
<h5 id="pkill-和-killall-根据名称发送信号给进程。"><code>pkill</code> 和 <code>killall</code>: 根据名称发送信号给进程。</h5>
<h5 id="nohup-运行命令，忽略挂起（HUP）信号。"><code>nohup</code>: 运行命令，忽略挂起（HUP）信号。</h5>
<h5 id="fg-和-bg-将作业放到前台或后台执行。"><code>fg</code> 和 <code>bg</code>: 将作业放到前台或后台执行。</h5>
<h5 id="jobs-列出当前-shell-会话中的作业。"><code>jobs</code>: 列出当前 shell 会话中的作业。</h5>
<h4 id="系统信息：">系统信息：</h4>
<h5 id="uname-显示系统信息（内核名称、主机名、内核版本号等）。"><code>uname</code>: 显示系统信息（内核名称、主机名、内核版本号等）。</h5>
<h5 id="uptime-显示系统运行时间、用户数、负载等。"><code>uptime</code>: 显示系统运行时间、用户数、负载等。</h5>
<h5 id="w-显示已登录的用户和他们正在执行的命令。"><code>w</code>: 显示已登录的用户和他们正在执行的命令。</h5>
<h5 id="who-显示已登录的用户。"><code>who</code>: 显示已登录的用户。</h5>
<h5 id="last-显示最近登录的用户列表。"><code>last</code>: 显示最近登录的用户列表。</h5>
<h5 id="dmidecode-显示硬件信息（需要-root-权限）。"><code>dmidecode</code>: 显示硬件信息（需要 root 权限）。</h5>
<h5 id="lscpu-和-lshw-显示-CPU-和硬件的详细信息。"><code>lscpu</code> 和 <code>lshw</code>: 显示 CPU 和硬件的详细信息。</h5>
<h5 id="free-显示内存使用情况。"><code>free</code>: 显示内存使用情况。</h5>
<h5 id="vmstat-报告关于进程、内存、分页、块-IO、陷阱和-CPU-活动的信息。"><code>vmstat</code>: 报告关于进程、内存、分页、块 IO、陷阱和 CPU 活动的信息。</h5>
<h4 id="网络管理：">网络管理：</h4>
<h5 id="ifconfig-或-ip-显示和配置网络接口。"><code>ifconfig</code> 或 <code>ip</code>: 显示和配置网络接口。</h5>
<h5 id="netstat-显示网络连接、路由表、接口统计等。"><code>netstat</code>: 显示网络连接、路由表、接口统计等。</h5>
<h5 id="ss-另一个用于查看系统套接字统计信息的工具（比-netstat-更快）。"><code>ss</code>: 另一个用于查看系统套接字统计信息的工具（比 netstat 更快）。</h5>
<h5 id="ping-发送-ICMP-ECHO-REQUEST-到网络主机。"><code>ping</code>: 发送 ICMP ECHO_REQUEST 到网络主机。</h5>
<h5 id="traceroute-或-tracert-显示数据包从源主机到目标主机之间的路由。"><code>traceroute</code> 或 <code>tracert</code>: 显示数据包从源主机到目标主机之间的路由。</h5>
<h5 id="nslookup-和-dig-查询-DNS-记录。"><code>nslookup</code> 和 <code>dig</code>: 查询 DNS 记录。</h5>
<h5 id="telnet-用于登录到远程主机的-TELNET-会话。"><code>telnet</code>: 用于登录到远程主机的 TELNET 会话。</h5>
<h5 id="nc-netcat-一个小巧但功能强大的网络工具，可以读写-TCP-和-UDP-数据。"><code>nc</code> (netcat): 一个小巧但功能强大的网络工具，可以读写 TCP 和 UDP 数据。</h5>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库——常用SQL语句</title>
    <url>/2024/07/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8SQL%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h4 id="SQL语句">SQL语句</h4>
<p>SQL（Structured Query Language）是一种用于访问和操作数据库系统的标准编程语言。它允许用户执行各种数据管理任务，如查询、更新、插入和删除数据库中的数据。以下是一些基本的SQL语句示例：</p>
<h5 id="1-创建数据库（Create-Database）">1. 创建数据库（Create Database）</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE myDatabase;</span><br></pre></td></tr></table></figure>
<h5 id="2-创建表（Create-Table）">2. 创建表（Create Table）</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    age <span class="type">INT</span>,</span><br><span class="line">    grade <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h5 id="3-插入数据（Insert）">3. 插入数据（Insert）</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (name, age, grade) <span class="keyword">VALUES</span> (<span class="string">&#x27;Alice&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;A+&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (name, age, grade) <span class="keyword">VALUES</span> (<span class="string">&#x27;Bob&#x27;</span>, <span class="number">22</span>, <span class="string">&#x27;B&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h5 id="4-查询数据（Select）">4. 查询数据（Select）</h5>
<ul>
<li>查询所有记录</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询特定列</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure>
<ul>
<li>带条件的查询</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> grade <span class="operator">=</span> <span class="string">&#x27;A+&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h5 id="5-更新数据（Update）">5. 更新数据（Update）</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> students <span class="keyword">SET</span> grade <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Bob&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h5 id="6-删除数据（Delete）">6. 删除数据（Delete）</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h5 id="7-聚合函数（Aggregate-Functions）">7. 聚合函数（Aggregate Functions）</h5>
<ul>
<li>计数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure>
<ul>
<li>求和</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(age) <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure>
<ul>
<li>平均值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(age) <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure>
<h5 id="8-排序（Order-By）">8. 排序（Order By）</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<h5 id="9-分组（Group-By）">9. 分组（Group By）</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> grade, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> students <span class="keyword">GROUP</span> <span class="keyword">BY</span> grade;</span><br></pre></td></tr></table></figure>
<h5 id="10-连接（Join）">10. 连接（Join）</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 假设有另一个表grades，包含grade_id和grade_name</span></span><br><span class="line"><span class="keyword">SELECT</span> students.name, grades.grade_name</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">JOIN</span> grades <span class="keyword">ON</span> students.grade <span class="operator">=</span> grades.grade_id;</span><br></pre></td></tr></table></figure>
<h5 id="注意事项">注意事项</h5>
<ul>
<li>SQL语法可能因数据库系统的不同（如MySQL、PostgreSQL、SQL Server等）而略有差异。</li>
<li>在执行删除或更新操作时要格外小心，以避免数据丢失。</li>
<li>聚合函数和分组通常与<code>HAVING</code>子句结合使用来过滤分组后的结果。</li>
<li>连接操作（Join）是处理多个相关表时非常有用的技术。</li>
</ul>
<h4 id="SQL语句分类">SQL语句分类</h4>
<p>SQL（Structured Query Language）语言是一种用于管理关系型数据库系统的标准化语言。根据功能和应用领域的不同，SQL语言可以大致分为以下几类：</p>
<h5 id="1-数据查询语言（DQL-Data-Query-Language）">1. 数据查询语言（DQL, Data Query Language）</h5>
<ul>
<li><strong>主要功能</strong>：用于从数据库中检索所需的数据。</li>
<li><strong>核心命令</strong>：SELECT。</li>
<li><strong>特点</strong>：允许用户根据特定条件过滤数据，排序结果集以及执行数据聚合操作。</li>
<li><strong>应用领域</strong>：网站和应用程序的数据检索、报表生成和数据分析等。</li>
</ul>
<h5 id="2-数据操纵语言（DML-Data-Manipulation-Language）">2. 数据操纵语言（DML, Data Manipulation Language）</h5>
<ul>
<li><strong>主要功能</strong>：用于改变数据库中的数据。</li>
<li><strong>主要命令</strong>：INSERT（插入）、UPDATE（更新）、DELETE（删除）。</li>
<li><strong>特点</strong>：通过DML，用户可以向数据库中插入新的数据、修改已有的数据，或者删除不再需要的数据。</li>
<li><strong>应用领域</strong>：用户在应用程序中提交表单时的数据插入、数据库中记录的更新和修正等。</li>
</ul>
<h5 id="3-数据定义语言（DDL-Data-Definition-Language）">3. 数据定义语言（DDL, Data Definition Language）</h5>
<ul>
<li><strong>主要功能</strong>：用于定义数据库的结构和组件。</li>
<li><strong>主要命令</strong>：CREATE（创建）、ALTER（修改）、DROP（删除）。</li>
<li><strong>特点</strong>：通过DDL，用户可以创建新的表、修改表结构，或者删除已有的表。DDL操作通常是隐式提交的，不能回滚。</li>
<li><strong>应用领域</strong>：数据库的初始化和配置、数据库升级和维护等。</li>
</ul>
<h5 id="4-数据控制语言（DCL-Data-Control-Language）">4. 数据控制语言（DCL, Data Control Language）</h5>
<ul>
<li><strong>主要功能</strong>：用于控制数据库用户的访问权限和安全性。</li>
<li><strong>主要命令</strong>：GRANT（授权）、REVOKE（收回权限）。</li>
<li><strong>特点</strong>：通过DCL，数据库管理员可以对用户进行授权或者撤销权限，以保护数据库中的敏感信息。</li>
<li><strong>应用领域</strong>：用户账户管理、数据库安全审计、数据访问权限控制等。</li>
</ul>
<h5 id="5-事务控制语言（TCL-Transaction-Control-Language）（在某些分类中可能不直接列出）">5. 事务控制语言（TCL, Transaction Control Language）（在某些分类中可能不直接列出）</h5>
<ul>
<li><strong>主要功能</strong>：用于维护数据的一致性。</li>
<li><strong>主要命令</strong>：COMMIT（提交）、ROLLBACK（回滚）、SAVEPOINT（保存点）。</li>
<li><strong>特点</strong>：TCL允许用户将一系列操作组合成一个事务，并通过提交或回滚来确保数据的一致性。</li>
<li><strong>应用领域</strong>：在处理复杂业务逻辑时，确保数据的完整性和一致性。</li>
</ul>
<h4 id="超键和主键">超键和主键</h4>
<p>在数据库管理系统中，超键（Super Key）和主键（Primary Key）是两个重要的概念，它们对于数据的唯一性和完整性起着至关重要的作用。主键是超键的一个特例，具有更严格的唯一性约束和更少的冗余属性：</p>
<h5 id="一、超键（Super-Key）">一、超键（Super Key）</h5>
<ul>
<li>
<p><strong>定义</strong>：在关系中能唯一标识元组（即表中的一行）的属性集称为关系模式的超键。一个属性或多个属性的组合，只要它们能够唯一地确定表中的一行，就可以被视为超键。</p>
</li>
<li>
<p><strong>特点</strong>：超键不是唯一的，一个表可以有多个超键。超键包含候选键和主键，是它们的超集。超键中的属性可以是多余的，即去掉某些属性后，剩余的属性仍然能唯一标识元组。</p>
</li>
</ul>
<h5 id="二、主键（Primary-Key）">二、主键（Primary Key）</h5>
<ul>
<li>
<p><strong>定义</strong>：主键是用户选作元组标识的一个候选键。在数据库表中，主键是对储存数据对象予以唯一和完整标识的数据列或属性的组合。</p>
</li>
<li>
<p><strong>特点</strong>：一个表只能有一个主键。主键的值不能为空（NULL），且不能重复。主键是从候选键中选择的，而候选键是不含有多余属性的超键。主键的选取通常考虑查询的方便性、数据的完整性和系统的性能。</p>
</li>
</ul>
<h5 id="三、超键与主键的关系">三、超键与主键的关系</h5>
<ul>
<li><strong>包含关系</strong>：超键包含主键，即主键是超键的一个特例。</li>
<li><strong>冗余性</strong>：超键可能包含冗余属性，而主键则不含有多余属性。</li>
<li><strong>唯一性</strong>：超键和主键都能唯一标识表中的一行，但主键是更严格的唯一性约束。</li>
</ul>
<h5 id="四、示例">四、示例</h5>
<p>假设有一个学生表（Student），包含以下属性：学号（StudentID）、姓名（Name）、性别（Gender）、身份证号（IDCard）。</p>
<ul>
<li><strong>超键</strong>：可以是（学号）、（身份证号）、（学号，姓名）、（身份证号，性别）等。其中，（学号，姓名）虽然能唯一标识学生，但姓名是冗余的，因为学号已经足够唯一。</li>
<li><strong>候选键</strong>：根据候选键的定义（不含有多余属性的超键），学生表中的候选键可以是（学号）或（身份证号）。</li>
<li><strong>主键</strong>：在候选键中，我们通常会选择一个作为主键。例如，可以选择（学号）作为主键。</li>
</ul>
<h4 id="SQL约束">SQL约束</h4>
<p>SQL约束是在关系型数据库中用于保障数据完整性和一致性的重要工具。它们定义了表中数据的规则和限制条件，确保数据满足预期的要求，防止无效或不一致的数据进入数据库。SQL约束可以分为多种类型，主要包括以下几种：</p>
<h5 id="1-非空约束（NOT-NULL）">1. 非空约束（NOT NULL）</h5>
<ul>
<li><strong>定义</strong>：强制列不接受NULL值。</li>
<li><strong>用途</strong>：确保字段始终包含值，防止数据缺失。</li>
<li><strong>语法</strong>：在创建表时，通过在列定义后添加<code>NOT NULL</code>来指定。</li>
</ul>
<h5 id="2-唯一约束（UNIQUE）">2. 唯一约束（UNIQUE）</h5>
<ul>
<li><strong>定义</strong>：唯一标识数据库表中的每条记录或一组记录。</li>
<li><strong>用途</strong>：保证某一列或列组合的值在表中是唯一的。</li>
<li><strong>注意</strong>：唯一约束允许列中存在NULL值，但每个NULL值都被视为不同的值（除非在唯一索引上使用了<code>UNIQUE_NULLS</code>设置，这取决于具体的数据库系统）。</li>
<li><strong>语法</strong>：在创建表时，使用<code>UNIQUE</code>关键字或<code>UNIQUE(column_name)</code>来指定。</li>
</ul>
<h5 id="3-主键约束（PRIMARY-KEY）">3. 主键约束（PRIMARY KEY）</h5>
<ul>
<li><strong>定义</strong>：唯一标识表中的每一行数据，且不允许为空。</li>
<li><strong>用途</strong>：作为表的唯一索引，保证数据的唯一性和完整性。</li>
<li><strong>特点</strong>：主键列的值在表中必须是唯一的，且不能包含NULL值。每个表只能有一个主键，但主键可以包含多个列（称为复合主键）。</li>
<li><strong>语法</strong>：在创建表时，使用<code>PRIMARY KEY</code>关键字或<code>PRIMARY KEY(column_name)</code>来指定。</li>
</ul>
<h5 id="4-外键约束（FOREIGN-KEY）">4. 外键约束（FOREIGN KEY）</h5>
<ul>
<li><strong>定义</strong>：一个表中的外键指向另一个表的主键，用于建立表与表之间的关系。</li>
<li><strong>用途</strong>：确保一个表中的某个列或列组合的值必须是另一个表中主键列或主键列组合的值之一，从而维护表之间的引用完整性。</li>
<li><strong>注意</strong>：外键约束用于预防破坏表之间连接的动作，也能防止非法数据插入外键列。</li>
<li><strong>语法</strong>：在创建表时，使用<code>FOREIGN KEY (column_name) REFERENCES parent_table(parent_column_name)</code>来指定。</li>
</ul>
<h5 id="5-检查约束（CHECK）">5. 检查约束（CHECK）</h5>
<ul>
<li><strong>定义</strong>：定义一个布尔表达式来评估插入或更新的值是否满足特定条件。</li>
<li><strong>用途</strong>：限制列中的值的范围，确保数据的准确性。</li>
<li><strong>语法</strong>：在创建表时，使用<code>CHECK (condition)</code>来指定。</li>
</ul>
<h5 id="6-默认约束（DEFAULT）">6. 默认约束（DEFAULT）</h5>
<ul>
<li><strong>定义</strong>：为给定列提供默认值，如果插入或更新操作未指定该列的值，则将使用默认值。</li>
<li><strong>用途</strong>：简化数据输入，确保数据的完整性。</li>
<li><strong>语法</strong>：在创建表时，使用<code>DEFAULT value</code>来指定。</li>
</ul>
<h5 id="约束的创建、修改和删除">约束的创建、修改和删除</h5>
<ul>
<li><strong>创建约束</strong>：在创建表时，可以直接在列定义后指定约束。也可以使用<code>ALTER TABLE</code>语句在表创建后添加约束。</li>
<li><strong>修改约束</strong>：通常需要先删除原有的约束，然后添加新的约束。这可以通过<code>ALTER TABLE</code>语句来实现。</li>
<li><strong>删除约束</strong>：使用<code>ALTER TABLE</code>语句结合<code>DROP CONSTRAINT</code>选项来删除已定义的约束。</li>
</ul>
<h4 id="char和varchar">char和varchar</h4>
<p>char和varchar是数据库中常用的两种字符串数据类型，它们之间存在一些关键的区别，主要包括以下几个方面：</p>
<ol>
<li>
<p><strong>长度固定与可变</strong>：</p>
<ul>
<li><strong>char</strong>：长度固定。比如char(10)，无论存储的字符串多长，都会占用10个字符的空间。如果字符串不足10个字符，剩余部分会用空格填充（尽管在检索时这些空格可能不被显示）。</li>
<li><strong>varchar</strong>：长度可变。varchar(10)只会占用实际字符串长度加上一个或两个额外字节（用于记录长度）的空间。如果字符串是’abc’，则只占用4个字节（3个用于’abc’，1个用于长度）。</li>
</ul>
</li>
<li>
<p><strong>空间效率</strong>：</p>
<ul>
<li><strong>char</strong>：在存储长度固定的字符串时很有效，但可能会浪费空间，特别是当存储的字符串比定义的长度短时。</li>
<li><strong>varchar</strong>：更节省空间，因为它只占用实际需要的空间加上一点额外的记录长度的空间。</li>
</ul>
</li>
<li>
<p><strong>性能</strong>：</p>
<ul>
<li><strong>char</strong>：由于长度固定，可能在某些情况下性能稍好（如快速定位），但这也取决于具体的数据库实现和查询类型。</li>
<li><strong>varchar</strong>：当处理可变长度的字符串时，通常提供更好的空间效率，但可能需要更多的处理来管理不同长度的数据。</li>
</ul>
</li>
<li>
<p><strong>使用场景</strong>：</p>
<ul>
<li>使用<strong>char</strong>时，你知道字段的值将几乎总是具有相同的长度，如日期、电话号码或某些代码。</li>
<li>使用<strong>varchar</strong>时，你预期字段的值长度会有所不同，如名字、地址或描述性文本。</li>
</ul>
</li>
</ol>
<h4 id="关联查询">关联查询</h4>
<p>关联查询，也称为多表查询，是在数据库中使用多个表的数据来生成一个结果集的查询操作。这些一起查询的表之间通常是通过某些关联字段（如外键）建立关系的。在关联查询中，有多种不同的关联方式，每种方式适用于不同的业务需求和数据模型。以下是几种常见的关联查询方式及其介绍：</p>
<h5 id="1-内连接（INNER-JOIN）">1. 内连接（INNER JOIN）</h5>
<p><strong>定义</strong>：在两个或多个表中查找匹配的行，并返回这些匹配行的数据。如果表之间有至少一个匹配，则返回行。</p>
<p><strong>SQL语句示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.column1, b.column2</span><br><span class="line"><span class="keyword">FROM</span> table1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2 <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">ON</span> a.id <span class="operator">=</span> b.id;</span><br></pre></td></tr></table></figure>
<p><strong>使用场景</strong>：当只需要返回两个表中符合条件的交集数据时使用。</p>
<h5 id="2-左连接（LEFT-JOIN-或-LEFT-OUTER-JOIN）">2. 左连接（LEFT JOIN 或 LEFT OUTER JOIN）</h5>
<p><strong>定义</strong>：返回左表中的所有行，即使右表中没有匹配的行。如果右表中没有匹配的行，则结果中右表的部分将包含NULL。</p>
<p><strong>SQL语句示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.column1, b.column2</span><br><span class="line"><span class="keyword">FROM</span> table1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2 <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">ON</span> a.id <span class="operator">=</span> b.id;</span><br></pre></td></tr></table></figure>
<p><strong>使用场景</strong>：当需要返回左表中的所有数据，以及右表中与左表满足条件的数据时使用。</p>
<h5 id="3-右连接（RIGHT-JOIN-或-RIGHT-OUTER-JOIN）">3. 右连接（RIGHT JOIN 或 RIGHT OUTER JOIN）</h5>
<p><strong>定义</strong>：与左连接相反，返回右表中的所有行，即使左表中没有匹配的行。如果左表中没有匹配的行，则结果中左表的部分将包含NULL。</p>
<p><strong>SQL语句示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.column1, b.column2</span><br><span class="line"><span class="keyword">FROM</span> table1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table2 <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">ON</span> a.id <span class="operator">=</span> b.id;</span><br></pre></td></tr></table></figure>
<p><strong>使用场景</strong>：当需要返回右表中的所有数据，以及左表中与右表满足条件的数据时使用。</p>
<h5 id="4-全连接（FULL-JOIN-或-FULL-OUTER-JOIN）">4. 全连接（FULL JOIN 或 FULL OUTER JOIN）</h5>
<p><strong>定义</strong>：返回左表和右表中的所有行。当某行在另一个表中没有匹配时，则对应的结果集部分将包含NULL。</p>
<p><strong>注意</strong>：并非所有数据库系统都直接支持FULL JOIN，但可以通过UNION操作结合LEFT JOIN和RIGHT JOIN来实现类似的效果。</p>
<p><strong>SQL语句示例（假设支持FULL JOIN）</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.column1, b.column2</span><br><span class="line"><span class="keyword">FROM</span> table1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> table2 <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">ON</span> a.id <span class="operator">=</span> b.id;</span><br></pre></td></tr></table></figure>
<p><strong>使用场景</strong>：当需要返回左表和右表中的所有数据，以及两个表中满足条件的数据时使用。</p>
<h5 id="5-交叉连接（Cross-Join）">5. 交叉连接（Cross Join）</h5>
<p><strong>定义</strong>：返回两个表中所有可能的行组合。结果集的行数等于左表的行数乘以右表的行数。</p>
<p><strong>SQL语句示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.column1, b.column2</span><br><span class="line"><span class="keyword">FROM</span> table1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> table2 <span class="keyword">AS</span> b;</span><br></pre></td></tr></table></figure>
<p><strong>使用场景</strong>：当需要返回两个表的笛卡尔积时使用。</p>
<h5 id="6-自连接（Self-Join）">6. 自连接（Self Join）</h5>
<p><strong>定义</strong>：在同一表中进行连接操作的过程，主要用于解决表中字段之间的关联问题。</p>
<p><strong>SQL语句示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.column1, b.column2</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">JOIN</span> <span class="keyword">table</span> <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">ON</span> a.parent_id <span class="operator">=</span> b.id;</span><br></pre></td></tr></table></figure>
<p><strong>使用场景</strong>：当需要在同一个表中比较不同行的数据时使用，例如，查找员工及其经理的关系。</p>
<h5 id="7-自然连接（Natural-Join）">7. 自然连接（Natural Join）</h5>
<p><strong>定义</strong>：自动匹配两个表中相同的字段，并返回它们的交集。注意，由于它依赖于字段名相同这一条件，因此在实际应用中可能会因为字段名相同但含义不同而导致错误的结果。</p>
<p><strong>SQL语句示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.column1, b.column2</span><br><span class="line"><span class="keyword">FROM</span> table1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> table2 <span class="keyword">AS</span> b;</span><br></pre></td></tr></table></figure>
<p><strong>使用场景</strong>：由于自然连接存在潜在的问题，因此在实际应用中并不推荐使用。如果确实需要类似的功能，建议使用INNER JOIN并明确指定连接条件。</p>
<h4 id="子查询">子查询</h4>
<p>子查询（Subquery）是嵌套在另一个查询中的查询。子查询可以出现在SELECT、FROM、WHERE等子句中，用于执行更复杂的查询操作。子查询可以返回一个值（标量子查询）、一行多列（行子查询）、多行一列（列子查询）或多行多列（表子查询），具体取决于其使用方式和上下文。</p>
<h5 id="子查询的类型">子查询的类型</h5>
<ol>
<li>
<p><strong>标量子查询</strong>：返回一个单一值（如数字、字符串等），通常用于比较操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees);</span><br></pre></td></tr></table></figure>
<p>这个例子中，子查询计算了员工的平均薪资，然后外层查询选择了薪资高于平均薪资的员工。</p>
</li>
<li>
<p><strong>列子查询</strong>：返回一列多行的数据，通常与IN、ANY、ALL等操作符结合使用。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> department_id <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> location_id <span class="operator">=</span> <span class="number">1700</span>);</span><br></pre></td></tr></table></figure>
<p>这个例子中，子查询找出了位于特定地点的部门ID，然后外层查询选择了属于这些部门的员工。</p>
</li>
<li>
<p><strong>行子查询</strong>：返回单行多列的数据，通常与ROW操作符结合使用进行比较。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees e1</span><br><span class="line"><span class="keyword">WHERE</span> (e1.salary, e1.department_id) <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary), department_id <span class="keyword">FROM</span> employees e2 <span class="keyword">GROUP</span> <span class="keyword">BY</span> e2.department_id);</span><br></pre></td></tr></table></figure>
<p>注意：这个例子可能不完全正确，因为它试图找出每个部门薪资最高的员工，但实际的SQL可能需要更复杂的逻辑（如使用窗口函数）。然而，它展示了行子查询的基本用法。</p>
</li>
<li>
<p><strong>表子查询</strong>：返回一个表，可以作为另一个查询的FROM子句中的表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line">      <span class="keyword">FROM</span> employees</span><br><span class="line">      <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id) <span class="keyword">AS</span> dept_avg</span><br><span class="line"><span class="keyword">WHERE</span> avg_salary <span class="operator">&gt;</span> <span class="number">50000</span>;</span><br></pre></td></tr></table></figure>
<p>这个例子中，子查询计算了每个部门的平均薪资，然后外层查询选择了平均薪资高于50,000的部门。</p>
</li>
</ol>
<h5 id="子查询的注意事项">子查询的注意事项</h5>
<ul>
<li><strong>性能</strong>：复杂的子查询可能会降低查询性能，特别是在处理大量数据时。考虑使用JOIN或其他优化技术来提高性能。</li>
<li><strong>可读性</strong>：过度使用或嵌套过深的子查询可能会降低SQL语句的可读性。在可能的情况下，尝试将复杂的查询分解为更简单的部分。</li>
<li><strong>兼容性</strong>：不同的数据库系统（如MySQL、PostgreSQL、SQL Server等）在子查询的支持和语法上可能存在差异。编写跨数据库兼容的SQL时，请注意这些差异。</li>
</ul>
<h4 id="DROP、DELETE-与-TRUNCATE-的区别">DROP、DELETE 与 TRUNCATE 的区别</h4>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">DROP</th>
<th style="text-align:center">DELETE</th>
<th style="text-align:center">TRUNCATE</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">操作对象</td>
<td style="text-align:center">表或数据库</td>
<td style="text-align:center">表中的数据行</td>
<td style="text-align:center">表中的所有数据行（不针对视图）</td>
</tr>
<tr>
<td style="text-align:center">执行速度</td>
<td style="text-align:center">较快（直接删除）</td>
<td style="text-align:center">较慢（逐行删除）</td>
<td style="text-align:center">较快（释放数据页）</td>
</tr>
<tr>
<td style="text-align:center">事务与回滚</td>
<td style="text-align:center">DDL操作，自动提交，不可回滚</td>
<td style="text-align:center">DML操作，可回滚（除非已提交）</td>
<td style="text-align:center">DDL操作，自动提交，不可回滚</td>
</tr>
</tbody>
</table>
<p>因此，在不再需要一张表的时候，采用 <code>DROP</code>；在想删除部分数据行时候，用 <code>DELETE</code>；在保留表而删除所有数据的时候用 <code>TRUNCATE</code>。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库——数据库性能优化</title>
    <url>/2024/07/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h4 id="数据库优化">数据库优化</h4>
<p>系统的吞吐量瓶颈往往出现在数据库的 访问速度 上，随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢，因为其数据是存放在 磁盘 上的，读写速度无法和内存相比，所以使用数据库时，十分有必要了解数据库优化问题。其优化原则为：减少系统瓶颈，减少资源占用，增加系统的反应速度。</p>
<h4 id="数据库结构优化">数据库结构优化</h4>
<h5 id="优化目标：">优化目标：</h5>
<ol>
<li><strong>减少数据冗余</strong>：确保相同的数据不会在多个地方重复存储，减少数据更新和维护的复杂性。</li>
<li><strong>避免数据维护异常</strong>：包括插入异常、更新异常和删除异常，确保数据库操作的正确性和一致性。</li>
<li><strong>节约存储空间</strong>：通过合理设计表结构和数据类型，减少不必要的存储空间浪费。</li>
<li><strong>提高查询效率</strong>：优化表结构和索引，加快数据检索速度，提升系统性能。</li>
</ol>
<h5 id="优化策略：">优化策略：</h5>
<p>在数据库设计中，针对字段很多或查询复杂的情况，采用表分解、增加中间表（以及合理添加冗余字段是常见的优化策略。</p>
<ol>
<li>
<p><strong>表分解（Normalization）</strong>：<br>
将大表分解成多个小表，每个表专注于一组相关的数据，通过外键关联。这有助于减少数据冗余，提高数据一致性，并使数据库结构更清晰。</p>
</li>
<li>
<p><strong>增加中间表（Denormalization for Query Optimization）</strong>：<br>
为优化查询性能，可以创建中间表来存储频繁联合查询的结果。这样做可以减少查询时的连接操作，提高查询速度，但会增加数据冗余和更新维护的复杂性。</p>
</li>
<li>
<p><strong>合理添加冗余字段</strong>：<br>
在不影响数据一致性的前提下，为了减少查询时的连接操作，可以在表中添加一些冗余字段。这些字段存储了原本需要通过联合查询才能获得的数据，从而提高了查询效率，但增加了数据更新的复杂性和存储成本。</p>
</li>
</ol>
<h4 id="分库分表">分库分表</h4>
<p>分库分表是数据库架构设计的一种策略，旨在通过将大量数据分散存储到多个数据库或表中，以提升系统的性能、可扩展性和可用性。这种方法主要用于处理海量数据和高并发访问的情况。</p>
<p>分库分表通过“垂直切分”或“水平切分”的方式，将数据库或表拆分成多个较小的部分。垂直切分通常按业务模块划分，将不同业务的数据放在不同的数据库或表中。水平切分则根据数据的某种特征（如用户ID、时间等）将数据分散到多个数据库或表中。</p>
<p>这种策略的主要目的是减轻单一数据库或表的压力，提高查询和写入速度，同时支持系统的水平扩展，即通过增加更多的数据库或表来应对数据量的增长。此外，分库分表还能提高系统的可用性，因为即使某个数据库或表出现问题，其他部分仍然可以正常工作。</p>
<h4 id="垂直切分和水平切分">垂直切分和水平切分</h4>
<ul>
<li>
<p><strong>垂直切分</strong>：将表中的字段按照业务逻辑进行拆分，将相关的字段放在一起，形成一个新表。这种方式适用于按业务模块划分数据的场景。</p>
</li>
<li>
<p><strong>水平切分</strong>：将表中的数据按照某个规则（如用户ID、时间范围等）分散到多个数据库中，每个数据库存储部分数据。这种方式适用于数据量大的场景，可以有效缓解单一数据库的性能瓶颈。</p>
</li>
</ul>
<h4 id="可能的问题">可能的问题</h4>
<ul>
<li><strong>跨节点查询和事务一致性问题</strong>：分库分表后可能会面临跨节点查询和事务一致性的问题。这需要通过合理的设计和优化来解决，如使用分布式事务、数据一致性校验等机制。</li>
<li><strong>数据迁移和扩容问题</strong>：在分库分表后，随着业务的发展可能需要进行数据迁移和扩容。这需要提前规划好数据迁移和扩容的策略和方案，以确保系统的平稳运行。</li>
</ul>
<h4 id="MySQL主从复制">MySQL主从复制</h4>
<p>主从复制是指将 主数据库（Master）中的 DDL 和 DML 操作通过二进制日志传输到 从数据库（Slave） 上，然后将这些日志重新执行（重做），从而使得从数据库的数据与主数据库保持一致。MySQL 支持单向、异步复制，复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。</p>
<p><strong>主从复制原理</strong>：</p>
<p>MySQL 的主从复制是一个 异步 的复制过程（一般情况下感觉是实时的），数据将从一个 MySQL 数据库（Master）复制到另外一个 MySQL 数据库（Slave），在 Master 与 Slave 之间实现整个主从复制的过程是由三个线程参与完成的，其中有两个线程（SQL 线程和 I/O 线程）在 Slave 端，另外一个线程（ I/O 线程）在 Master 端。</p>
<p><strong>主从复制的作用有</strong>：</p>
<ul>
<li>当主数据库出现问题时，可以切换到从数据库；</li>
<li>可以进行数据库层面的读写分离，实现负载均衡；</li>
<li>可以在从数据库上进行实时数据备份。</li>
</ul>
<h4 id="MySQL读写分离的实施方案">MySQL读写分离的实施方案</h4>
<p>MySQL 读写分离的实现方式主要基于 主从复制，通过 路由的方式 使应用对数据库的写请求只在 Master 上进行，读请求在 Slave 上进行。</p>
<p>具体地，有以下四种实现方案：</p>
<ul>
<li>
<p><strong>方案一：基于 MySQL proxy 代理</strong></p>
<p>在应用和数据库之间增加 代理层，代理层接收应用对数据库的请求，根据不同请求类型（即是读 read 还是写 write）转发到不同的实例，在实现读写分离的同时可以实现负载均衡。MySQL 的代理最常见的是 mysql-proxy、cobar、mycat、Atlas 等。</p>
</li>
<li>
<p><strong>方案二：基于应用内路由</strong></p>
<p>基于应用内路由的方式即为在应用程序中实现，针对不同的请求类型去不同的实例执行 SQL。具体实现可基于 spring 的 aop：用 aop 来拦截 spring 项目的 dao 层方法，根据方法名称就可以判断要执行的类型，进而动态切换主从数据源。</p>
</li>
<li>
<p><strong>方案三：基于 MySQL-Connector-Java 的 JDBC 驱动方式</strong></p>
<p>Java 程序通过在连接 MySQL 的 JDBC 中配置主库与从库等地址，JDBC 会自动将读请求发送给从库，将写请求发送给主库，此外， MySQL 的 JDBC 驱动还能够实现多个从库的负载均衡。</p>
</li>
<li>
<p><strong>方案四：基于 sharding-jdbc 的方式</strong></p>
<p>sharding-sphere 是强大的读写分离、分表分库中间件，sharding-jdbc 是 sharding-sphere 的核心模块。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库——索引</title>
    <url>/2024/07/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h4 id="数据库索引">数据库索引</h4>
<p>数据库索引是数据库表中的一种数据结构，用于提高数据检索的效率。主要有以下五个特性：</p>
<ol>
<li>
<p><strong>提高检索速度</strong>：通过索引，数据库可以快速定位到数据，显著减少查询响应时间。</p>
</li>
<li>
<p><strong>数据结构优化</strong>：通常采用B树或B+树结构，这些结构支持高效的数据插入、检索和排序。</p>
</li>
<li>
<p><strong>唯一性约束</strong>：唯一索引确保数据项的唯一性，防止数据重复。</p>
</li>
<li>
<p><strong>支持复合索引</strong>：允许基于表中多个列的组合创建索引，提高特定查询的效率。</p>
</li>
<li>
<p><strong>维护成本</strong>：虽然索引可以加快查询速度，但它们也需要额外的存储空间，并且在数据更新时需要维护，这可能会影响性能。</p>
</li>
</ol>
<h4 id="索引优缺点">索引优缺点</h4>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>显著减少查询响应时间，特别是对于大型数据集。</td>
<td>索引需要额外的存储空间，随着数据量的增加，需求也会增长。</td>
</tr>
<tr>
<td>索引通常是有序的，可以加快排序操作。</td>
<td>索引更新可能降低数据插入、更新或删除的性能。</td>
</tr>
<tr>
<td>使搜索操作更迅速，特别是范围查询和模糊查询。</td>
<td>索引的动态维护增加了数据库的维护成本。</td>
</tr>
<tr>
<td>唯一索引确保数据项的唯一性，防止数据重复。</td>
<td>需要深入了解查询模式和数据使用情况，设计有效的索引策略。对表结构的更改可能需要相应地更新索引。</td>
</tr>
<tr>
<td>加快表之间的连接操作，尤其是在处理大量数据时。</td>
<td>需要深入了解查询模式和数据使用情况，设计有效的索引策略。</td>
</tr>
</tbody>
</table>
<h4 id="索引的数据结构">索引的数据结构</h4>
<table>
<thead>
<tr>
<th>结构</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>B树</td>
<td>平衡树结构，允许在对数时间内进行搜索、顺序访问、插入和删除操作。</td>
</tr>
<tr>
<td>B+树</td>
<td>B树的变种，所有数据都存储在叶子节点，内部节点只存储键值和指向子节点的指针，叶子节点形成链表，便于范围查询。</td>
</tr>
<tr>
<td>哈希表</td>
<td>通过哈希函数将键映射到表中的位置，适用于等值查询，但不适合范围查询。</td>
</tr>
<tr>
<td>R树</td>
<td>一种平衡树，用于空间数据索引，如地理信息系统（GIS）。</td>
</tr>
<tr>
<td>T树</td>
<td>一种多维数据索引树，适用于多维查询。</td>
</tr>
<tr>
<td>位图索引</td>
<td>使用位图来表示数据的存在或不存在，适合于列存储数据库，特别是对于具有低基数（少量不同值）的列。</td>
</tr>
<tr>
<td>倒排索引</td>
<td>通常用于全文搜索引擎，将单词映射到包含该单词的文档列表。</td>
</tr>
<tr>
<td>组合索引</td>
<td>结合了两种或以上的索引结构，以适应特定的查询需求。</td>
</tr>
</tbody>
</table>
<p>每种数据结构都有其优势和适用场景：</p>
<ul>
<li><strong>B树和B+树</strong>：由于它们的平衡性质，非常适合用作数据库索引，特别是在需要支持范围查询和顺序访问的场景中。</li>
<li><strong>哈希表</strong>：在等值查询中非常高效，但在范围查询和顺序访问方面表现不佳。</li>
<li><strong>R树</strong>：特别适用于空间数据索引，如地理坐标数据。</li>
<li><strong>T树</strong>：适用于多维数据的索引，可以处理复杂的多维查询。</li>
<li><strong>位图索引</strong>：在数据仓库和列存储数据库中非常有效，特别是在进行位运算和聚合操作时。</li>
<li><strong>倒排索引</strong>：是全文搜索的关键技术，允许快速检索包含特定单词的文本。</li>
</ul>
<h4 id="B-树的优势">B+树的优势</h4>
<p>B+树是关系型数据库中索引的首选数据结构之一，特别是在需要频繁执行范围查询和顺序访问的场景中。</p>
<ol>
<li>
<p><strong>高效的范围查询</strong>：B+树的叶子节点存储了全部数据，并且叶子节点之间通过指针相连，这使得范围查询非常高效。</p>
</li>
<li>
<p><strong>平衡树结构</strong>：B+树是一种平衡树，保持了数据的有序性，支持快速的插入、删除和查找操作。</p>
</li>
<li>
<p><strong>减少I/O操作</strong>：B+树的设计使得相关数据更可能位于相邻的节点，减少了磁盘I/O操作的次数。</p>
</li>
<li>
<p><strong>优化的节点利用率</strong>：B+树的内部节点可以拥有更多的子节点，这提高了节点的空间利用率，减少了树的高度。</p>
</li>
<li>
<p><strong>快速定位最小值和最大值</strong>：由于B+树的叶子节点形成链表，定位最小值和最大值非常迅速。</p>
</li>
<li>
<p><strong>适应大数据量</strong>：B+树的结构适合处理大量数据，因为它可以通过增加节点来扩展，而不需要频繁地重新平衡。</p>
</li>
<li>
<p><strong>顺序访问性能</strong>：B+树的叶子节点链表结构使得顺序访问（如全表扫描）非常高效。</p>
</li>
<li>
<p><strong>高效的页存储</strong>：在数据库系统中，数据通常存储在页中，B+树的结构可以很好地适应页的边界，减少页的分裂。</p>
</li>
<li>
<p><strong>支持高并发</strong>：B+树的结构使得多个事务可以并发地访问索引，提高了系统的并发性能。</p>
</li>
<li>
<p><strong>易于维护</strong>：B+树的插入和删除操作相对简单，易于维护和更新。</p>
</li>
<li>
<p><strong>稳定的查询性能</strong>：由于B+树的高度较低，查询性能不会因为树的高度增长而显著下降。</p>
</li>
</ol>
<h4 id="Hash索引和B">Hash索引和B+</h4>
<table>
<thead>
<tr>
<th>特性/方面</th>
<th>哈希索引</th>
<th>B+树索引</th>
</tr>
</thead>
<tbody>
<tr>
<td>查询效率</td>
<td>等值查询非常快</td>
<td>等值查询快，范围查询更优</td>
</tr>
<tr>
<td>索引结构</td>
<td>哈希表</td>
<td>平衡树（B树或其变种）</td>
</tr>
<tr>
<td>顺序访问</td>
<td>不支持顺序访问</td>
<td>支持顺序访问（B+树的叶子节点链表结构）</td>
</tr>
<tr>
<td>范围查询</td>
<td>不适合范围查询</td>
<td>适合范围查询（特别是B+树）</td>
</tr>
<tr>
<td>存储空间</td>
<td>通常较小</td>
<td>通常较大</td>
</tr>
<tr>
<td>数据组织</td>
<td>通过哈希函数直接定位</td>
<td>有序存储，支持顺序和范围访问</td>
</tr>
<tr>
<td>写操作性能</td>
<td>插入和删除可能更快（无重组需求）</td>
<td>插入和删除可能较慢（需要维护树的平衡）</td>
</tr>
<tr>
<td>索引维护</td>
<td>简单，但可能需要再散列</td>
<td>复杂，需要保持树的平衡</td>
</tr>
<tr>
<td>适用场景</td>
<td>适合等值查询密集的应用</td>
<td>适合需要范围查询和顺序访问的应用</td>
</tr>
<tr>
<td>并发控制</td>
<td>较难实现高效的并发控制</td>
<td>更易于实现高效的并发控制</td>
</tr>
<tr>
<td>索引覆盖</td>
<td>较难实现覆盖索引</td>
<td>易于实现覆盖索引</td>
</tr>
<tr>
<td>页存储适应性</td>
<td>可能需要额外处理以适应数据库的页结构</td>
<td>与数据库页结构天然适应</td>
</tr>
</tbody>
</table>
<h4 id="前缀索引">前缀索引</h4>
<p>前缀索引是一种特殊的索引技术，它不是对整个列的值进行索引，而是只对列中每个值的前几个字符建立索引。这种技术可以用于优化文本数据的查询性能，尤其是在以下方面：</p>
<ol>
<li>
<p><strong>空间效率</strong>：只对字符串的一部分进行索引，可以减少索引占用的存储空间。</p>
</li>
<li>
<p><strong>查询性能</strong>：对于以特定前缀开始的查询，前缀索引可以快速定位到可能匹配的记录，然后数据库可以进一步检查剩余的字符串部分。</p>
</li>
<li>
<p><strong>适用性</strong>：适用于那些经常根据前缀进行搜索的列，如电子邮件地址、URLs或特定格式的编码。</p>
</li>
<li>
<p><strong>索引选择性</strong>：前缀索引的选择性可能不如全列索引，因为多个值可能共享相同的前缀。</p>
</li>
<li>
<p><strong>限制</strong>：前缀索引可能不适用于需要精确匹配整个字符串的查询，或者那些不以前缀为搜索条件的查询。</p>
</li>
<li>
<p><strong>数据库支持</strong>：不同的数据库系统对前缀索引的支持程度不同，有些数据库允许用户指定索引的前缀长度。</p>
</li>
<li>
<p><strong>使用场景</strong>：在某些情况下，如文本搜索或自动完成功能，前缀索引可以显著提高性能。</p>
</li>
<li>
<p><strong>维护考虑</strong>：与全列索引相比，前缀索引可能需要更多的维护，以确保索引的效率和准确性。</p>
</li>
<li>
<p><strong>性能权衡</strong>：使用前缀索引时，需要权衡索引的大小和查询性能之间的关系，选择合适的前缀长度。</p>
</li>
</ol>
<h4 id="最左前缀匹配原则">最左前缀匹配原则</h4>
<p>最左前缀匹配原则（也称为最左匹配原则）是在使用复合索引时的一个重要概念。这个原则指的是，数据库查询优化器只会利用复合索引的左侧连续列。以下是最左前缀匹配原则的几个要点：</p>
<ol>
<li>
<p><strong>索引顺序</strong>：复合索引的有效性取决于查询条件中列的顺序是否与索引定义中的列顺序一致。</p>
</li>
<li>
<p><strong>连续性</strong>：只有从索引最左侧的列开始的连续列才能被索引利用。如果查询条件中缺少了索引列的前导部分，则索引的其余部分将不会被使用。</p>
</li>
<li>
<p><strong>查询优化</strong>：数据库查询优化器会根据最左前缀匹配原则来决定是否可以使用索引，以及如何使用索引来优化查询。</p>
</li>
<li>
<p><strong>索引使用</strong>：如果查询条件中包含了索引的前导列，即使后续列的条件是范围查询（如使用了<code>&gt;</code>或<code>&lt;</code>操作符），索引仍然可以被部分使用。</p>
</li>
<li>
<p><strong>性能影响</strong>：不遵守最左前缀匹配原则可能导致查询无法有效利用索引，从而影响查询性能。</p>
</li>
<li>
<p><strong>索引设计</strong>：在设计复合索引时，应该考虑查询模式，将最常用于搜索的列放在索引的左侧。</p>
</li>
<li>
<p><strong>示例</strong>：如果有一个由<code>(A, B, C)</code>三列组成的复合索引，有效的查询条件可能是<code>WHERE A = value</code>，<code>WHERE A = value AND B = value2</code>，或者<code>WHERE A = value AND B = value2 AND C = value3</code>。但如果查询条件是<code>WHERE B = value2</code>，而没有包含列A，则无法使用该复合索引。</p>
</li>
<li>
<p><strong>例外</strong>：某些数据库系统可能通过查询优化技术，如索引扫描的合并，来在某些情况下使用非最左前缀的索引部分，但这通常不如遵循最左前缀匹配原则的查询效率高。</p>
</li>
</ol>
<h4 id="添加索引原则">添加索引原则</h4>
<p>添加数据库索引时应遵循以下五个主要原则：</p>
<ol>
<li>
<p><strong>针对高频查询列</strong>：为经常作为查询条件的列添加索引，以提高这些查询的效率。</p>
</li>
<li>
<p><strong>考虑查询模式</strong>：根据实际的查询模式来决定索引的类型和列的组合，例如复合索引的顺序应与查询条件中的顺序相匹配。</p>
</li>
<li>
<p><strong>避免过度索引</strong>：虽然索引可以提高查询速度，但过多的索引会增加写操作的负担和存储成本，需要平衡索引的数量和查询性能。</p>
</li>
<li>
<p><strong>选择性高的索引</strong>：优先为具有高选择性的列创建索引，即列中不同值的数量占总记录数的比例较高的列。</p>
</li>
<li>
<p><strong>维护数据完整性</strong>：使用索引来强制数据完整性，如唯一索引可以保证数据的唯一性，外键索引可以维护引用完整性。</p>
</li>
</ol>
<p>遵循这些原则可以帮助你有效地使用索引，提高数据库的性能和数据的一致性。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库——锁</title>
    <url>/2024/07/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E9%94%81/</url>
    <content><![CDATA[<h4 id="锁">锁</h4>
<p>在数据库管理和并发编程中，锁（Locks）是一种重要的同步机制，用于控制多个用户对共享资源的访问，以避免数据的不一致性和冲突。锁的主要目的是确保在给定时间内，只有一个事务（或进程、线程）可以访问特定的数据或资源。</p>
<h4 id="锁的类型">锁的类型</h4>
<ol>
<li>
<p><strong>共享锁（Shared Locks, S锁）</strong>：</p>
<ul>
<li>允许多个事务同时读取同一资源，但禁止任何事务写入该资源。也称为读锁。</li>
<li>当事务对数据加上S锁后，其他事务可以继续加S锁，但如果其他事务想加排他锁（X锁）则必须等待该事务释放S锁。</li>
</ul>
</li>
<li>
<p><strong>排他锁（Exclusive Locks, X锁）</strong>：</p>
<ul>
<li>允许事务独占访问特定资源，即加锁期间既不允许其他事务读取，也不允许写入。也称为写锁。</li>
<li>当事务对数据加上X锁后，其他事务不能对其加任何类型的锁，直到该锁被释放。</li>
</ul>
</li>
<li>
<p><strong>意向锁（Intention Locks）</strong>：</p>
<ul>
<li>是一种特殊的表级锁，表示事务将来可能对表中的行加锁。意向锁分为意向共享锁（IS锁）和意向排他锁（IX锁）。</li>
<li>意向锁的主要目的是表明事务的锁定意向，以提高锁定的效率。例如，在添加行级X锁之前，需要先在表上加IX锁，这样其他事务在尝试对表加S锁或X锁时就可以快速判断是否有冲突。</li>
</ul>
</li>
<li>
<p><strong>记录锁（Record Locks）</strong>：</p>
<ul>
<li>锁定数据库表中的一条记录。</li>
</ul>
</li>
<li>
<p><strong>间隙锁（Gap Locks）</strong>：</p>
<ul>
<li>锁定一个范围，但不包括记录本身。主要用于防止幻读。</li>
</ul>
</li>
<li>
<p><strong>临键锁（Next-Key Locks）</strong>：</p>
<ul>
<li>是记录锁和间隙锁的组合，锁定一个范围并包括记录本身。MySQL的InnoDB存储引擎默认使用临键锁来防止幻读。</li>
</ul>
</li>
</ol>
<h4 id="锁的特性">锁的特性</h4>
<ul>
<li><strong>互斥性</strong>：任何时刻，只有一个事务可以持有锁。</li>
<li><strong>可见性</strong>：锁定的资源对其他事务是不可见的，直到锁被释放。</li>
<li><strong>死锁</strong>：两个或多个事务在执行过程中，因争夺资源而造成的一种相互等待的现象。数据库管理系统需要检测和解决死锁问题。</li>
</ul>
<h3 id="锁的管理">锁的管理</h3>
<ul>
<li><strong>锁的粒度</strong>：决定了锁定资源的大小，可以是数据库、表、页或行。锁的粒度越小，系统的并发性越高，但管理锁的开销也越大。</li>
<li><strong>锁的策略</strong>：包括悲观锁（Pessimistic Locking）和乐观锁（Optimistic Locking）两种。悲观锁假定最坏的情况，在数据处理前就加锁；乐观锁则假设不会发生并发冲突，只在更新数据时检查是否有冲突。</li>
</ul>
<p>在数据库设计中，合理地使用锁机制是保证数据一致性和完整性的关键。然而，过度的锁定会导致性能下降，因此需要根据具体的应用场景和需求来选择合适的锁策略和粒度。</p>
<h4 id="事务隔离级别与锁">事务隔离级别与锁</h4>
<ul>
<li>
<p>在 读取未提交 隔离级别下，读取数据不需要加 共享锁，这样就不会跟被修改的数据上的 排他锁 冲突；</p>
</li>
<li>
<p>在 读取已提交 隔离级别下，读操作需要加 共享锁，但是在语句执行完以后释放共享锁；</p>
</li>
<li>
<p>在 可重复读 隔离级别下，读操作需要加 共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁；</p>
</li>
<li>
<p>可串行化 是限制性最强的隔离级别，因为该级别 锁定整个范围的键，并一直持有锁，直到事务完成</p>
</li>
</ul>
<h4 id="死锁与解决">死锁与解决</h4>
<h5 id="死锁简述">死锁简述</h5>
<p>死锁是指两个或多个进程在执行过程中，因争夺资源而造成的一种相互等待的现象，若无外力作用，这些进程都将无法向前推进。具体来说，当一组进程中的每个进程都在等待另一个进程所占有的资源时，这组进程就发生了死锁。</p>
<p>死锁的产生通常源于多个进程对资源的争夺，主要包括以下几点：</p>
<ol>
<li><strong>系统资源不足</strong>：系统分配给进程的资源不足以满足所有进程的需求。</li>
<li><strong>进程运行推进的顺序不当</strong>：进程推进顺序不当也可能导致死锁。</li>
<li><strong>资源分配不当</strong>：资源分配策略不合理，如资源分配不均匀或过于集中。</li>
</ol>
<h5 id="死锁产生的必要条件">死锁产生的必要条件</h5>
<ol>
<li><strong>互斥条件</strong>：进程在运行中对资源进行排他性使用，即一个资源仅能被一个进程使用，此时其他进程请求资源时，只能等待其释放。</li>
<li><strong>请求与保持条件</strong>：某进程已经保持了一个资源，但又请求另一个资源，若该资源被其他进程占有，此时请求阻塞，且对已经占有的资源不释放。</li>
<li><strong>不可抢占条件</strong>：进程获得的资源在未使用完时不可被抢占，只能在进程使用完时自己释放。</li>
<li><strong>循环等待条件</strong>：发生死锁时，必然存在这样一个循环，一个进程p1等待p2占有的资源，进程p2等待p3占有的资源……进程pn等待p1占有的资源。</li>
</ol>
<h5 id="死锁的解决办法">死锁的解决办法</h5>
<ol>
<li>
<p><strong>死锁预防</strong></p>
<ul>
<li>这是一种较简单和直观的事先预防的方法。通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。但这种方法可能会导致系统资源利用率和系统吞吐量降低。</li>
</ul>
</li>
<li>
<p><strong>死锁避免</strong></p>
<ul>
<li>系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源。如果分配后系统可能发生死锁，则不予分配，否则予以分配。这是一种保证系统不进入死锁状态的动态策略。</li>
</ul>
</li>
<li>
<p><strong>死锁检测和解除</strong></p>
<ul>
<li>先检测：不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区。允许系统在运行过程中发生死锁，但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源。检测方法包括定时检测、效率低时检测、进程等待时检测等。</li>
<li>然后解除死锁：采取适当措施，从系统中将已发生的死锁清除掉。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。</li>
</ul>
</li>
<li>
<p><strong>其他具体方法</strong></p>
<ul>
<li><strong>按序加锁</strong>：确保所有的线程都是按照相同的顺序获得锁，这样可以有效防止循环等待条件的出现。</li>
<li><strong>尝试加锁超时</strong>：线程在尝试获取锁时设置一个超时时间，如果超时则放弃对该锁的请求，并释放已经占有的锁，然后等待一段时间后重试。</li>
<li><strong>锁排序和分组</strong>：将锁按照一定的规则进行排序或分组，并规定严格的加锁顺序，以减少死锁的发生。</li>
<li><strong>使用无锁数据结构</strong>：通过原子操作等无锁机制来实现并发控制，从而避免死锁的发生。</li>
</ul>
</li>
</ol>
<h4 id="乐观锁和悲观锁">乐观锁和悲观锁</h4>
<h5 id="乐观锁">乐观锁</h5>
<ul>
<li>
<p><strong>核心思想</strong>：乐观锁认为数据在多个事务之间很少会发生冲突，因此在读取数据时不对其加锁。当更新数据时，会检查数据是否自上次读取后已被其他事务修改（通常通过版本号或时间戳）。</p>
</li>
<li>
<p><strong>优点</strong>：并发性能好，因为读取数据时不加锁。</p>
</li>
<li>
<p><strong>缺点</strong>：在高并发情况下，可能会出现较多的更新冲突，需要重试。</p>
</li>
</ul>
<h5 id="悲观锁">悲观锁</h5>
<ul>
<li>
<p><strong>核心思想</strong>：悲观锁认为数据在多个事务之间很容易发生冲突，因此在读取数据时立即加锁，以防止其他事务修改数据。</p>
</li>
<li>
<p><strong>优点</strong>：数据一致性好，能够防止数据在并发环境下被多个事务同时修改。</p>
</li>
<li>
<p><strong>缺点</strong>：并发性能较低，因为读取数据时就需要加锁，可能阻塞其他事务的访问。</p>
</li>
</ul>
<p>简而言之，乐观锁适合读多写少的场景，而悲观锁适合写多读少的场景。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库基础概念</title>
    <url>/2024/07/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h4 id="数据库概念">数据库概念</h4>
<p>数据库是一种存储、检索和管理数据的系统。它允许用户以结构化的方式存储数据，并且可以通过各种查询和操作来访问这些数据。</p>
<h5 id="数据库基本特征：">数据库基本特征：</h5>
<ul>
<li><strong>结构化</strong>：数据库中的数据通常是以表格（表）的形式存储的，每张表由行（记录）和列（字段）组成。</li>
<li><strong>持久性</strong>：数据库中的数据是持久存储的，即使系统关闭，数据也不会丢失。</li>
<li><strong>组织性</strong>：数据在数据库中是有序存储的，便于快速检索和更新。</li>
<li><strong>安全性</strong>：数据库管理系统提供了多种安全措施，如用户认证、权限控制等，以保护数据不被未授权访问。</li>
<li><strong>并发控制</strong>：数据库能够处理多个用户同时访问和修改数据的情况，确保数据的一致性和完整性。</li>
<li><strong>数据完整性</strong>：数据库通过各种约束（如主键、外键、唯一性约束等）来维护数据的准确性和可靠性。</li>
<li><strong>灵活性</strong>：用户可以通过SQL（结构化查询语言）等查询语言来执行复杂的数据操作。</li>
<li><strong>可扩展性</strong>：数据库系统通常可以随着数据量的增加而扩展，以适应不断增长的存储和处理需求。</li>
</ul>
<h5 id="两种数据库">两种数据库</h5>
<ul>
<li>
<p><strong>关系型数据库</strong>：使用表格模型来组织数据，数据之间通过关系（如外键）相互关联。常见的关系型数据库有MySQL、PostgreSQL、Oracle和SQL Server等。</p>
</li>
<li>
<p><strong>非关系型数据库</strong>（NoSQL）：不使用传统的表格模型，而是使用其他数据模型，如键值对、文档、宽列存储或图形数据库。常见的非关系型数据库有MongoDB、Cassandra、Redis和Neo4j等。</p>
</li>
</ul>
<p>下面是一个表格，概述了关系型数据库（RDBMS）和非关系型数据库（NoSQL）之间的一些关键差异：</p>
<table>
<thead>
<tr>
<th>特性/方面</th>
<th>关系型数据库 (RDBMS)</th>
<th>非关系型数据库 (NoSQL)</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据模型</td>
<td>表格模型</td>
<td>键值对、文档、宽列、图形等</td>
</tr>
<tr>
<td>查询语言</td>
<td>SQL</td>
<td>多样，可能不是统一的</td>
</tr>
<tr>
<td>扩展性</td>
<td>垂直扩展为主</td>
<td>水平扩展</td>
</tr>
<tr>
<td>一致性模型</td>
<td>ACID (强一致性)</td>
<td>BASE (最终一致性)</td>
</tr>
<tr>
<td>事务支持</td>
<td>支持复杂事务</td>
<td>事务支持有限</td>
</tr>
<tr>
<td>数据关系</td>
<td>支持复杂关系</td>
<td>不存储或以不同方式存储关系</td>
</tr>
<tr>
<td>适用场景</td>
<td>需要复杂查询和事务处理</td>
<td>需要高扩展性和灵活数据模型</td>
</tr>
<tr>
<td>数据结构</td>
<td>固定，需预先定义</td>
<td>灵活，可存储不同结构数据</td>
</tr>
<tr>
<td>性能</td>
<td>高性能读写，但可能受限于扩展性</td>
<td>高性能读写，易于扩展</td>
</tr>
<tr>
<td>例子</td>
<td>MySQL, PostgreSQL, Oracle, SQL Server</td>
<td>MongoDB, Cassandra, Redis, Neo4j</td>
</tr>
</tbody>
</table>
<h4 id="为什么使用数据库">为什么使用数据库</h4>
<p>使用数据库的几个最重要的原因包括：</p>
<ol>
<li>
<p><strong>数据持久性</strong>：确保数据在系统关闭后依然安全存储，不会丢失。</p>
</li>
<li>
<p><strong>结构化存储</strong>：以表格形式组织数据，便于管理和访问。</p>
</li>
<li>
<p><strong>数据一致性</strong>：通过约束和事务管理，保持数据的准确性和可靠性。</p>
</li>
<li>
<p><strong>安全性</strong>：提供用户认证和权限控制，保护数据不被未授权访问。</p>
</li>
<li>
<p><strong>高效访问</strong>：通过索引和查询优化，快速检索大量数据。</p>
</li>
<li>
<p><strong>并发控制</strong>：允许多个用户同时访问，同时维护数据完整性。</p>
</li>
<li>
<p><strong>可扩展性</strong>：随着数据量的增长，数据库可以水平或垂直扩展以满足需求。</p>
</li>
<li>
<p><strong>支持复杂查询</strong>：使用SQL等查询语言，从大量数据中提取有用信息。</p>
</li>
<li>
<p><strong>促进决策</strong>：通过分析数据，帮助组织做出基于数据的决策。</p>
</li>
<li>
<p><strong>成本效益</strong>：对于需要处理大量数据的组织，数据库是一种经济高效的解决方案。</p>
</li>
</ol>
<h4 id="SQL">SQL</h4>
<p>SQL（结构化查询语言）是一种标准化的语言，用于在关系型数据库管理系统（RDBMS）中进行数据管理和操作。SQL的一些关键特性和用途：</p>
<ol>
<li>
<p><strong>查询</strong>：使用<code>SELECT</code>语句从数据库中检索数据。</p>
</li>
<li>
<p><strong>插入</strong>：使用<code>INSERT INTO</code>语句向数据库表中添加新数据。</p>
</li>
<li>
<p><strong>更新</strong>：使用<code>UPDATE</code>语句修改数据库中的数据。</p>
</li>
<li>
<p><strong>删除</strong>：使用<code>DELETE</code>语句从数据库中移除数据。</p>
</li>
<li>
<p><strong>数据定义</strong>：使用<code>CREATE</code>、<code>ALTER</code>和<code>DROP</code>语句来定义和管理数据库的结构，如创建新表、修改表结构或删除表。</p>
</li>
<li>
<p><strong>数据操纵</strong>：除了基本的CRUD（创建、读取、更新、删除）操作外，SQL还支持更复杂的数据操纵，如联结（JOIN）、子查询和集合操作。</p>
</li>
<li>
<p><strong>事务控制</strong>：使用<code>BEGIN TRANSACTION</code>、<code>COMMIT</code>和<code>ROLLBACK</code>语句来管理事务，确保数据的一致性和完整性。</p>
</li>
<li>
<p><strong>权限和安全性</strong>：使用<code>GRANT</code>和<code>REVOKE</code>语句来分配和撤销用户权限。</p>
</li>
<li>
<p><strong>数据完整性</strong>：通过设置主键、外键、唯一约束和非空约束等，确保数据的准确性和可靠性。</p>
</li>
<li>
<p><strong>数据类型</strong>：SQL定义了多种数据类型，如整数、浮点数、字符串、日期和时间等，以适应不同类型的数据存储需求。</p>
</li>
<li>
<p><strong>索引</strong>：创建索引以优化查询性能，加快数据检索速度。</p>
</li>
<li>
<p><strong>视图</strong>：使用<code>CREATE VIEW</code>语句创建视图，作为虚拟表，简化复杂的查询或保护数据。</p>
</li>
<li>
<p><strong>存储过程和函数</strong>：使用存储过程和函数封装复杂的操作，提高代码的重用性和效率。</p>
</li>
</ol>
<h4 id="MYSQL">MYSQL</h4>
<p>MySQL是一个广泛使用的开源关系型数据库管理系统（RDBMS），具有以下主要特点：</p>
<ol>
<li><strong>开源</strong>：免费使用，拥有活跃的开发者社区。</li>
<li><strong>跨平台</strong>：可在多种操作系统上运行，如Linux、Windows和macOS。</li>
<li><strong>高性能</strong>：优化了对大量数据的处理能力。</li>
<li><strong>可靠性</strong>：提供事务支持、备份和恢复功能，确保数据安全。</li>
<li><strong>可扩展性</strong>：支持垂直和水平扩展，适应不同规模的应用需求。</li>
<li><strong>灵活性</strong>：支持多种存储引擎，适应不同的数据存储和访问模式。</li>
<li><strong>标准SQL</strong>：使用标准的SQL语法，便于学习和使用。</li>
<li><strong>多用户环境</strong>：支持多用户并发访问，通过权限控制保障数据安全。</li>
<li><strong>丰富的数据类型</strong>：支持多种数据类型，满足不同存储需求。</li>
<li><strong>索引优化</strong>：支持多种索引类型，提高查询效率。</li>
<li><strong>复制和分区</strong>：支持数据复制和表分区，提高数据的可用性和性能。</li>
<li><strong>安全性</strong>：提供用户认证、权限控制和数据加密功能。</li>
<li><strong>广泛的应用</strong>：适用于从小型应用到大型企业级应用的多种场景。</li>
</ol>
<h4 id="数据库三大范式">数据库三大范式</h4>
<p>数据库的三大范式是一组设计原则，用于指导关系型数据库的结构设计，以避免数据冗余和维护数据的完整性。以下是三大范式的简述：</p>
<ol>
<li>
<p><strong>第一范式（1NF）- 原子性</strong>：</p>
<ul>
<li>要求数据库表的每一列都是不可分割的最小数据项，即表中的所有字段都应该只包含原子数据，即每个字段的值都是单一的、不可再分的数据项。</li>
</ul>
</li>
<li>
<p><strong>第二范式（2NF）- 完全性</strong>：</p>
<ul>
<li>在第一范式的基础上，要求表中的每一列都应完全依赖于主键。也就是说，如果一个表有多个字段可以共同作为主键，那么非主键字段不能只依赖于主键的一部分，而应该完全依赖于整个主键。</li>
</ul>
</li>
<li>
<p><strong>第三范式（3NF）- 非传递依赖</strong>：</p>
<ul>
<li>在第二范式的基础上，要求非主键字段不能依赖于其他非主键字段。即，如果存在非主键字段依赖于另一个非主键字段，那么应该将这些字段分离到不同的表中，并通过外键与主表关联。</li>
</ul>
</li>
</ol>
<p>遵循这三大范式可以帮助数据库设计者创建出结构良好、避免数据冗余和维护数据一致性的数据库模式。然而，实际应用中，为了性能或其他考虑，有时会有意违反某些范式。</p>
<h4 id="数据库链接泄露">数据库链接泄露</h4>
<p>数据库连接泄露是指应用程序未能正确关闭数据库连接，导致连接资源无法释放。这可能导致的问题和预防措施包括：</p>
<ol>
<li>
<p><strong>问题</strong>：随着时间推移，连接数耗尽，新操作无法执行，影响性能。</p>
</li>
<li>
<p><strong>原因</strong>：代码中未关闭连接，异常处理不当，或连接池管理错误。</p>
</li>
<li>
<p><strong>预防</strong>：确保代码中每个数据库连接都显式关闭，使用异常处理确保即使出错也能关闭连接，合理配置连接池。</p>
</li>
<li>
<p><strong>解决</strong>：修复代码错误，优化异常处理，监控连接使用情况。</p>
</li>
</ol>
<h4 id="触发器">触发器</h4>
<p>触发器（Trigger）是一种特殊的存储过程，它在数据库中特定的数据操作（如INSERT、UPDATE或DELETE）之前或之后自动执行。以下是触发器的一些基本要点：</p>
<ol>
<li><strong>自动执行</strong>：触发器在满足特定条件时自动触发，无需显式调用。</li>
<li><strong>事件驱动</strong>：触发器通常与数据表相关联，并由对表的特定操作（如数据插入、更新或删除）触发。</li>
<li><strong>时机</strong>：触发器可以在数据操作之前（BEFORE）或之后（AFTER）执行。</li>
<li><strong>用途</strong>：用于维护数据完整性、自动更新相关数据、实施复杂的业务规则等。</li>
<li><strong>类型</strong>：
<ul>
<li><strong>行触发器</strong>：对表中每一行数据的操作触发。</li>
<li><strong>语句触发器</strong>：对整个SQL语句的操作触发。</li>
</ul>
</li>
<li><strong>语言</strong>：触发器通常使用数据库支持的编程语言编写，如PL/SQL（Oracle）或T-SQL（SQL Server）。</li>
<li><strong>应用场景</strong>：适用于需要自动执行维护任务或复杂逻辑的场景，如自动填充字段、记录数据变更历史、同步更新关联表等。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络概述总结</title>
    <url>/2024/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="计算网络体系概述">计算网络体系概述</h3>
<h4 id="相关问题">相关问题</h4>
<ul>
<li>计算机网络为什么要分层？</li>
<li>计算机网络是怎么分层的？</li>
<li>三种计算机网络模型的关系是什么？每一层分别包含哪些协议？</li>
<li>计算机网络中，数据如何在各层中传播？数据在网络各层中的存在形式是怎么样的？</li>
</ul>
<h4 id="OSI七层模型">OSI七层模型</h4>
<p>OSI（Open Systems Interconnection）是开放系统互连参考模型的缩写，它是一个定义得非常好的协议规范集，它为各种系统定义了一个层次结构和一套用于协调与控制各层活动的规则，模型有七层结构。OSI模型的七层结构及其简要描述：</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>名称</th>
<th>简要描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>物理层 (Physical Layer)</td>
<td>定义了物理设备标准，如网络接口、传输介质等，负责传输原始比特流。</td>
</tr>
<tr>
<td>2</td>
<td>数据链路层 (Data Link Layer)</td>
<td>在物理层提供的服务基础上，建立相邻节点之间的数据链路，进行差错控制和流量控制。</td>
</tr>
<tr>
<td>3</td>
<td>网络层 (Network Layer)</td>
<td>负责为分组交换网上的不同主机提供通信服务，实现路由选择和分组转发。</td>
</tr>
<tr>
<td>4</td>
<td>传输层 (Transport Layer)</td>
<td>提供端到端的通信服务，负责数据的分段、重组和差错控制，确保数据的可靠传输。</td>
</tr>
<tr>
<td>5</td>
<td>会话层 (Session Layer)</td>
<td>负责建立、管理和终止会话过程，同步不同设备上的各种表示层实体。</td>
</tr>
<tr>
<td>6</td>
<td>表示层 (Presentation Layer)</td>
<td>对应用层数据进行表示和转换，如数据压缩、加密和解密、数据格式转换等。</td>
</tr>
<tr>
<td>7</td>
<td>应用层 (Application Layer)</td>
<td>为网络应用提供访问OSI环境的手段，定义应用进程间通信和交互的规则。</td>
</tr>
</tbody>
</table>
<p>这个表格简洁地概述了OSI模型的每一层及其主要功能。需要注意的是，虽然OSI模型在理论上是一个完善的参考模型，但在实际应用中，TCP/IP协议族由于其简洁性和高效性而被广泛采用。</p>
<h4 id="TCP-IP五层协议">TCP/IP五层协议</h4>
<p>五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层。其中应用层对应 OSI 的上三层，下四层和 OSI 相同。五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。TCP/IP五层协议栈：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>主要功能</th>
<th>主要协议/技术</th>
</tr>
</thead>
<tbody>
<tr>
<td>物理层</td>
<td>负责物理传输介质上比特流的传输</td>
<td>无（依赖于物理介质）</td>
</tr>
<tr>
<td>数据链路层</td>
<td>负责将数据封装成帧，进行差错控制和流量控制</td>
<td>以太网、PPP</td>
</tr>
<tr>
<td>网络层</td>
<td>负责数据包的路由和转发，实现不同网络之间的通信</td>
<td>IP、ICMP、IGMP、ARP、RARP</td>
</tr>
<tr>
<td>传输层</td>
<td>负责端到端的数据传输，提供可靠或不可靠的数据传输服务</td>
<td>TCP、UDP</td>
</tr>
<tr>
<td>应用层</td>
<td>提供网络应用服务，处理特定应用的数据格式</td>
<td>HTTP、FTP、SMTP、DNS、SSH</td>
</tr>
</tbody>
</table>
<p>这个表格简要地概括了TCP/IP五层协议栈中每一层的主要功能以及该层使用的主要协议或技术。这些协议共同协作，确保数据能够正确、高效地从源地址传输到目标地址。</p>
<h4 id="数据在各层之间的传输">数据在各层之间的传输</h4>
<p>在TCP/IP五层协议栈中，数据并不是直接在各层之间传输的，而是经历了一个封装和解封装的过程。这个过程确保了数据从源地址到目标地址的可靠传输。以下是数据在各层之间传输的详细步骤：</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>物理层</th>
<th>数据链路层</th>
<th>网络层</th>
<th>传输层</th>
<th>应用层</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据类型</td>
<td>比特流</td>
<td>帧、数据帧</td>
<td>数据报、数据包</td>
<td>报文段、数据段</td>
<td>报文</td>
</tr>
<tr>
<td>添加部分</td>
<td>前导码</td>
<td>MAC头部</td>
<td>IP头部</td>
<td>TCP头部</td>
<td>数据</td>
</tr>
</tbody>
</table>
<h5 id="应用层：">应用层：</h5>
<ul>
<li>应用层是TCP/IP模型的最上层，直接为用户的应用程序（如浏览器、电子邮件客户端等）提供服务。</li>
<li>在应用层，应用程序（如HTTP服务器或FTP客户端）生成数据，这些数据可能是文本、图片、音频或视频等。</li>
<li>应用层将数据封装成应用层协议所能理解的数据格式，如HTTP请求或FTP命令。</li>
</ul>
<h5 id="传输层：">传输层：</h5>
<ul>
<li>传输层负责提供端到端的数据传输服务，包括可靠性和流量控制。</li>
<li>在传输层，数据被封装成传输层协议的数据单元，对于TCP来说是TCP段（segment），对于UDP来说是UDP数据报（datagram）。</li>
<li>封装过程中，传输层会添加源端口号和目的端口号等信息，以便在接收端能够正确地将数据交付给相应的应用程序。</li>
</ul>
<h5 id="网络层：">网络层：</h5>
<ul>
<li>网络层负责网络间的通信，主要处理路由和转发。</li>
<li>在网络层，数据被封装成IP数据报（datagram）。封装过程中，会添加源IP地址和目的IP地址等信息。</li>
<li>网络层根据路由选择算法，将数据报从源主机发送到目的主机。</li>
</ul>
<h5 id="数据链路层：">数据链路层：</h5>
<ul>
<li>数据链路层负责处理本地网络的通信，包括帧的构造和解析。</li>
<li>在数据链路层，IP数据报被封装成帧（frame）。封装过程中，会添加帧头（包含源MAC地址和目的MAC地址）和帧尾（包含校验信息）。</li>
<li>数据链路层通过物理层提供的服务，将数据帧从一个节点传输到下一个节点。</li>
</ul>
<h5 id="物理层：">物理层：</h5>
<ul>
<li>物理层是TCP/IP模型的最底层，负责将比特流转换成物理信号，并在物理介质上进行传输。</li>
<li>物理层将数据帧转换成适合在物理介质上传输的比特流，如电信号或光信号。</li>
<li>比特流通过物理介质（如电缆、光纤等）传输到目的主机。</li>
</ul>
<h3 id="应用层">应用层</h3>
<h4 id="相关问题-2">相关问题</h4>
<ul>
<li>uri 和 url 的区别 ？</li>
<li>dns 是啥工作原理，主要解析过程是啥？</li>
<li>用户输入网址到显示对应页面的全过程是啥？</li>
<li>http 头部包含哪些信息？</li>
<li>http 方法了解哪些？</li>
<li>http 状态码了解哪些？</li>
<li>get 和 post 的区别？</li>
<li>https 和 https 的区别？</li>
<li>https 的加密方式？</li>
<li>http 是不保存状态的协议,如何保存用户状态？</li>
<li>http 不同版本的区别？</li>
</ul>
<h4 id="万维网和域名系统">万维网和域名系统</h4>
<p>万维网（简称WWW或Web）和域名系统（简称DNS）是互联网中两个重要的组成部分，它们各自在互联网的运作中扮演着关键角色。</p>
<h5 id="P2P和C-S">P2P和C/S</h5>
<p>P2P（Peer-to-Peer）与C/S（Client/Server）是计算机网络中两种常见的通信模式，P2P是一种去中心化的网络架构，适用于资源共享和实时通信；而C/S是一种中心化的架构，适用于需要集中管理和控制的应用场景。</p>
<h6 id="P2P（Peer-to-Peer）">P2P（Peer-to-Peer）</h6>
<p>定义：P2P是一种网络架构，其中每个设备（称为“对等点”或“节点”）都可以直接与其他设备通信，而不需要通过中央服务器。</p>
<p>特点：</p>
<ul>
<li>去中心化：没有中央控制点，每个节点都可以相互通信。</li>
<li>资源共享：节点可以共享文件、带宽等资源。</li>
<li>灵活：节点可以动态地加入或离开网络。</li>
</ul>
<p>应用场景：文件共享（如BitTorrent）、即时通讯（如Skype或某些在线游戏）。</p>
<h6 id="C-S（Client-Server）">C/S（Client/Server）</h6>
<p>定义：C/S架构中，有一个或多个服务器负责存储数据和处理请求，而客户端设备（如电脑、手机等）则发送请求给服务器并接收响应。</p>
<p>特点：</p>
<ul>
<li>集中管理：数据和服务由服务器集中提供。</li>
<li>安全性：服务器可以提供安全控制和数据完整性检查。</li>
<li>响应速度快：客户端与服务器直接通信，响应通常较快。</li>
</ul>
<p>应用场景：Web应用（如网站）、数据库系统、电子邮件服务等。</p>
<h5 id="Web结构组件">Web结构组件</h5>
<p>web结构组件指的是构成Web系统的基础元素，这些组件共同协作，使得Web应用能够正常运行并提供服务，以下是一些Web结构组件：</p>
<table>
<thead>
<tr>
<th>组件名称</th>
<th>定义</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>代理（Proxy）</td>
<td>中间服务器，用于转发客户端和服务器之间的请求和响应</td>
<td>提高性能、安全性或进行内容过滤</td>
</tr>
<tr>
<td>缓存（Cache）</td>
<td>存储常用页面副本的地方，以减少网络带宽使用和加快页面加载速度</td>
<td>提高Web应用的响应速度</td>
</tr>
<tr>
<td>网关（Gateway）</td>
<td>连接其他应用或服务的服务器，例如连接Web服务器到FTP服务器的中间件</td>
<td>协议转换和服务集成</td>
</tr>
<tr>
<td>Agent代理</td>
<td>发起HTTP请求的Web客户端，如浏览器、网络爬虫等</td>
<td>代表用户或系统发送HTTP请求</td>
</tr>
<tr>
<td>Web组件（Web Components）</td>
<td>封装好的可复用的自定义元素，用于构建Web应用</td>
<td>提高Web开发的效率和可维护性</td>
</tr>
<tr>
<td>网络协议（Network Protocols）</td>
<td>计算机之间通信的规则，如HTTP和HTTPS</td>
<td>确保客户端和服务器之间能够正确通信</td>
</tr>
<tr>
<td>域名系统（DNS）</td>
<td>将域名转换为IP地址的系统</td>
<td>使人们可以通过易记的域名来访问网站</td>
</tr>
</tbody>
</table>
<h5 id="DNS">DNS</h5>
<p>域名服务器（Domain Name Server，简称DNS）是互联网中至关重要的基础设施之一，它负责将人类可读的域名（<a href="http://xn--example-i22m.com">如example.com</a>）映射到与之对应的IP地址（如192.0.2.1）。</p>
<h6 id="工作原理">工作原理</h6>
<p>假设一个客户端 A，想要查询 <a href="http://a.leetcode.cn">a.leetcode.cn</a> 的 ip 地址，考虑缓存的情况。</p>
<ul>
<li>客户端 A 首先查询本地的 hosts 文件，查询是否有网址映射关系，如果没有，进行下一步查找。</li>
<li>查找本地的 dns 解析器缓存，如果没有进行下一步。</li>
<li>根据 tcp/ip 参数查找设置好的首选 dns 服务器 ip 地址，一般叫做本地 dns 服务器，查询本地 dns 服务器。本地 dns 服务器如果没有，它就会进行下一步操作。</li>
<li>本地dns会访问根服务器 ，然后根据后缀名，从根服务器中查找对应的顶级域名服务器的 ip ，然后以此向下查找域名服务器的 ip ，然后查找网址映射关系,直到找到为止。</li>
</ul>
<h4 id="http">http</h4>
<p>http（超文本传输协议）是互联网上应用最为广泛的一种网络协议。HTTP 协议是用于从 Web 服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p>
<p>HTTP 的工作原理是基于客户端-服务器架构。客户端（例如，Web 浏览器）向服务器（例如，Web 服务器）发送 HTTP 请求以获取资源（如 HTML 页面、图片、CSS 样式表、JavaScript 脚本等）。服务器响应这些请求，通过发送 HTTP 响应来提供所需的资源。</p>
<p>HTTPS（HTTP Secure）是在 HTTP 基础上加入了 SSL/TLS 加密技术，提供了安全的数据传输方式。</p>
<h5 id="主要特点包括：">主要特点包括：</h5>
<ul>
<li>
<p>无连接：HTTP 协议是无连接的，即每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
</li>
<li>
<p>无状态：HTTP 协议是无状态的，协议对于事务处理没有记忆能力。服务器不知道客户端之前发送过什么请求，也不知道客户端下一次会发送什么请求。</p>
</li>
<li>
<p>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、POST、PUT、DELETE 等。每种方法规定了客户端与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</p>
</li>
<li>
<p>支持 B/S 模式：HTTP 支持客户端/服务器模式，客户端可以通过 HTTP 协议向服务器发送请求，服务器也可以通过 HTTP 协议将请求的内容返回给客户端。</p>
</li>
</ul>
<h4 id="网络编程socket">网络编程socket</h4>
<p>网络编程中的 <code>socket</code> 是一种抽象层，它允许应用程序（通常称为“客户端”和“服务器”）通过计算机网络进行通信。<code>socket</code> 提供了一种跨平台、跨语言的网络编程接口，使得在不同的操作系统和编程语言中都可以使用类似的方式进行网络通信。</p>
<h5 id="基本概念">基本概念</h5>
<ol>
<li><strong>IP 地址</strong>：用于唯一标识网络中的设备。</li>
<li><strong>端口号</strong>：用于标识运行在同一台设备上的不同应用程序。每个端口号对应一个特定的服务或应用程序。</li>
<li><strong>TCP/UDP</strong>：两种主要的传输层协议。TCP 是面向连接的协议，提供可靠的数据传输服务；UDP 是无连接的协议，提供不可靠的数据传输服务，但速度更快。</li>
</ol>
<h5 id="工作原理-2">工作原理</h5>
<ol>
<li><strong>创建 socket</strong>：应用程序首先创建一个 socket 对象，指定使用的协议（TCP 或 UDP）和本地端口号（如果需要）。</li>
<li><strong>绑定 socket</strong>：对于服务器端的 socket，需要将其绑定到一个特定的 IP 地址和端口号上，以便客户端能够找到并连接到它。</li>
<li><strong>监听和接受连接</strong>（仅适用于 TCP）：服务器端的 socket 开始监听来自客户端的连接请求。当有客户端连接时，服务器接受连接并创建一个新的 socket 对象来处理与该客户端的通信。</li>
<li><strong>发送和接收数据</strong>：通过 socket 对象，应用程序可以发送和接收数据。对于 TCP，数据以字节流的形式传输；对于 UDP，数据以数据报的形式传输。</li>
<li><strong>关闭 socket</strong>：当通信完成后，应用程序关闭 socket 对象以释放资源。</li>
</ol>
<h5 id="示例（基于-Python）">示例（基于 Python）</h5>
<h6 id="服务器端">服务器端</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 TCP socket 对象</span></span><br><span class="line">server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定到 IP 地址和端口号</span></span><br><span class="line">server_address = (<span class="string">&#x27;localhost&#x27;</span>, <span class="number">12345</span>)</span><br><span class="line">server_socket.bind(server_address)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始监听连接请求</span></span><br><span class="line">server_socket.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 接受连接请求并返回一个新的 socket 对象和客户端地址</span></span><br><span class="line">    client_socket, client_address = server_socket.accept()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Accepted connection from <span class="subst">&#123;client_address&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 接收并处理数据（这里只是简单地回显数据）</span></span><br><span class="line">    data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> data:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Received: <span class="subst">&#123;data.decode()&#125;</span>&quot;</span>)</span><br><span class="line">        client_socket.sendall(data)  <span class="comment"># 回显数据给客户端</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 关闭连接</span></span><br><span class="line">    client_socket.close()</span><br></pre></td></tr></table></figure>
<h6 id="客户端">客户端</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 TCP socket 对象</span></span><br><span class="line">client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到服务器</span></span><br><span class="line">server_address = (<span class="string">&#x27;localhost&#x27;</span>, <span class="number">12345</span>)</span><br><span class="line">client_socket.connect(server_address)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 发送数据</span></span><br><span class="line">    message = <span class="string">b&#x27;Hello, server!&#x27;</span></span><br><span class="line">    client_socket.sendall(message)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 接收数据</span></span><br><span class="line">    data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Received: <span class="subst">&#123;data.decode()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 关闭连接</span></span><br><span class="line">    client_socket.close()</span><br></pre></td></tr></table></figure>
<p>在这个示例中，服务器端创建一个 TCP socket 对象并绑定到本地地址和端口号上，然后开始监听连接请求。客户端也创建一个 TCP socket 对象并连接到服务器。一旦连接建立，客户端发送数据给服务器，服务器接收数据并回显给客户端。最后，双方关闭连接以释放资源。</p>
<h3 id="传输层">传输层</h3>
<p>传输层（Transport Layer）是计算机网络体系结构中的关键层次之一，主要负责两台计算机之间（或更准确地说，是两个主机中进程之间）的数据通信服务。</p>
<ul>
<li>为什么要进行三次握手？两次握手可以吗?</li>
<li>为什么要四次挥手？</li>
<li>CTIME-WAIT 为什么是 2MSL？</li>
<li>TCP 和 UDP 的区别？</li>
<li>TCP 是如何保证可靠性的，UDP 为什么是不可靠的 ？</li>
<li>TCP 报文包含哪些信息 ？</li>
<li>UDP 包含哪些信息</li>
<li>三次握手和四次挥手过程中，网络断开会发生什么？</li>
</ul>
<h4 id="端口号的使用">端口号的使用</h4>
<ul>
<li>传输层使用端口号来区分不同的应用进程。端口号是一个16位的整数，范围从0到65535。其中，0到1023为知名端口（Well-Known Ports），由IANA注册，用于特定的服务；1024到65535为动态/私有端口，可由用户自由分配。</li>
<li>通过“IP地址+端口号”的组合，传输层能够唯一标识网络中的一个通信端口，从而实现数据的准确传输。</li>
</ul>
<h4 id="UDP协议">UDP协议</h4>
<p>UDP（User Datagram Protocol，用户数据报协议）是一种无连接的、不可靠的、面向数据报的传输层协议。它工作在OSI模型的传输层，为应用层提供了一种简单的、直接的数据传输服务。</p>
<h5 id="特点">特点:</h5>
<ol>
<li>无连接
<ul>
<li>UDP在发送数据之前不需要建立连接。发送方和接收方之间不保持连接状态，每个数据报都是独立传输的。</li>
</ul>
</li>
<li>不可靠
<ul>
<li>UDP不保证数据报的顺序、完整性或是否到达。如果数据报在传输过程中丢失或损坏，UDP不会进行重传或恢复。</li>
</ul>
</li>
<li>面向数据报
<ul>
<li>UDP将应用层交下来的数据封装成一个个的数据报（Datagram），并添加UDP头部信息，然后交给网络层进行传输。每个数据报都是一个独立的单元，携带完整的源地址和目的地址信息。</li>
</ul>
</li>
<li>开销小
<ul>
<li>UDP头部只有8个字节，相对于TCP的20字节头部来说更小，因此UDP的传输开销更低，传输效率更高。</li>
</ul>
</li>
<li>支持多播和广播
<ul>
<li>UDP支持向多个目的地址发送相同的数据报，即多播（Multicast）。同时，它还可以将数据报发送给网络中的所有主机，即广播（Broadcast）。</li>
</ul>
</li>
</ol>
<h5 id="注意事项">注意事项</h5>
<ul>
<li>由于UDP不提供可靠的数据传输服务，因此在使用UDP时，应用层需要自行处理数据的可靠性问题，如通过应用层协议来确认数据报的接收和重传等。</li>
<li>UDP不保证数据报的顺序性，因此接收方可能会以与发送方不同的顺序接收到数据报。如果应用需要保持数据的顺序性，那么应用层需要在发送和接收时进行相应的处理。</li>
</ul>
<h4 id="TCP协议">TCP协议</h4>
<p>TCP（Transmission Control Protocol，传输控制协议）是计算机网络中一种基于连接的、可靠的传输层协议。它提供了一系列机制来确保数据在端到端之间的可靠传输。</p>
<h5 id="特点-2">特点</h5>
<ol>
<li>面向连接
<ul>
<li>TCP在数据传输之前需要先建立连接，通过三次握手过程来确保双方都已准备好进行数据传输。</li>
</ul>
</li>
<li>可靠性
<ul>
<li>TCP通过序列号、确认应答、超时重传等机制来确保数据的完整性和顺序性。如果数据包在传输过程中丢失或损坏，TCP会负责重新发送。</li>
</ul>
</li>
<li>流控制
<ul>
<li>TCP使用滑动窗口机制来防止发送方发送速度过快，确保接收方能够处理并消化数据。这有助于避免接收方被数据淹没，提高传输效率。</li>
</ul>
</li>
<li>拥塞控制
<ul>
<li>TCP具有拥塞控制机制，用于适应网络的拥塞情况。当网络出现拥塞时，TCP会自动减少发送速率，以减轻网络负担，避免性能下降。</li>
</ul>
</li>
<li>面向字节流
<ul>
<li>TCP将传输的数据视为无边界的字节流，而不是像UDP那样按照消息边界进行划分。这意味着发送方可以连续发送数据，而接收方也可以连续接收数据，无需关心数据的原始边界。</li>
</ul>
</li>
<li>全双工通信
<ul>
<li>TCP连接允许双方在同一时间既能发送数据又能接收数据，提高了通信效率。</li>
</ul>
</li>
</ol>
<h5 id="工作机制">工作机制</h5>
<ol>
<li>三次握手
<ul>
<li>客户端发送SYN报文给服务器，请求建立连接。</li>
<li>服务器收到SYN报文后，回复SYN+ACK报文给客户端，表示同意建立连接。</li>
<li>客户端收到服务器的SYN+ACK报文后，回复ACK报文给服务器，完成三次握手过程，建立连接。</li>
<li>SYN表示标志位，seq表示序列号，ACK表示标志位，Ack表示确认号。</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">客户端-&gt;&gt;服务器:请求建立链接：SYN=1，seq=x</span><br><span class="line">服务器-&gt;&gt;客户端:同意建立链接：SYN=1，ACK=1，seq=y，Ack=x+1</span><br><span class="line">客户端-&gt;&gt;服务器:表示建立链接：ACK=1，Seq=x+1，Ack=y+1</span><br><span class="line"></span><br><span class="line">loop 传输信息</span><br><span class="line">	服务器-&gt;&gt;客户端:发送数据</span><br><span class="line">	客户端-&gt;&gt;服务器:发送数据</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ol>
<li>数据传输
<ul>
<li>连接建立后，双方可以开始传输数据。TCP通过序列号来标识每个数据包的顺序，并通过确认应答机制来确认数据包的接收情况。</li>
</ul>
</li>
<li>超时重传
<ul>
<li>如果客户端在规定时间内没有收到服务器的确认应答，则认为数据包丢失，会重新发送该数据包。</li>
</ul>
</li>
<li>四次挥手
<ul>
<li>当一方想要关闭连接时，会发送FIN报文给对方，表示没有数据要发送了。对方收到FIN报文后，会回复ACK报文确认收到，并继续发送完剩余的数据（如果有的话）。当对方也发送完所有数据并想要关闭连接时，也会发送FIN报文给对方。最后，双方通过ACK报文确认连接的关闭。</li>
<li>FIN：表示标志位，seq：表示序列号，ACK表示标志位，Ack表示确认号</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">客户端-&gt;&gt;服务器:请求关闭链接：FIN=1，seq=x</span><br><span class="line">服务器-&gt;&gt;客户端:同意关闭链接：ACK=1，seq=y，Ack=x+1</span><br><span class="line">服务器-&gt;&gt;客户端:结束发送，关闭链接：FIN=1，ACK=1，seq=z，Ack=x+1</span><br><span class="line">客户端-&gt;&gt;服务器:结束接受，关闭链接：ACK=1，seq=x+1，Ack=z+1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="三次握手与四次挥手">三次握手与四次挥手</h5>
<h6 id="三次握手：确认双方收发能力">三次握手：确认双方收发能力</h6>
<ul>
<li>第一次握手（SYN）：客户端发送一个SYN报文给服务器，表示客户端想要建立连接，并包含一个初始序列号seq=x。这个报文告诉服务器：“我想要连接你，这是我的初始序列号”。</li>
<li>第二次握手（SYN+ACK）：服务器收到客户端的SYN报文后，会回复一个SYN+ACK报文给客户端。这个报文包含服务器的初始序列号seq=y，以及对客户端SYN报文的确认号ack=x+1。这个报文告诉客户端：“我收到了你的请求，我想要连接你，这是我的初始序列号，并且我已经确认了你的序列号”。</li>
<li>第三次握手（ACK）：客户端收到服务器的SYN+ACK报文后，会回复一个ACK报文给服务器。这个报文包含对服务器SYN报文的确认号ack=y+1，但不包含序列号（因为这是一个纯确认报文）。这个报文告诉服务器：“我收到了你的回复，我已经准备好开始传输数据了”。</li>
</ul>
<h6 id="四次挥手：确保数据完整传输">四次挥手：确保数据完整传输</h6>
<ul>
<li>当一方想要关闭连接时，它不能直接断开连接，因为可能还有未发送或未接收的数据。因此，它需要发送一个FIN报文给对方，告诉对方：“我已经没有数据要发送了，但请允许我接收你的数据”。</li>
<li>对方收到FIN报文后，会回复一个ACK报文，表示已经收到对方的关闭请求，但自己可能还有数据要发送。此时，连接处于半关闭状态，即一方已经关闭发送通道，但另一方仍然可以发送数据。</li>
<li>当没有数据要发送时，另一方也会发送一个FIN报文给对方，表示自己也想要关闭连接。</li>
<li>最后，对方回复一个ACK报文，确认已经收到对方的FIN报文，此时连接才真正关闭。</li>
</ul>
<h5 id="确保可靠的机制">确保可靠的机制</h5>
<p>TCP（传输控制协议）通过一系列复杂的机制来确保数据的可靠传输。校验和、序列号和确认应答机制保证了数据的完整性和顺序性；超时重传机制避免了因网络原因导致的数据丢失；连接管理（三次握手与四次挥手）确保了连接的可靠建立和正确关闭；流量控制和拥塞控制机制则保证了网络的稳定性和高效性。以下是对这些机制的详细归纳：</p>
<h6 id="1-校验和">1. 校验和</h6>
<ul>
<li>计算方式：在数据传输过程中，TCP将发送的数据段当做一个16位的整数进行累加（进位不丢弃，补在后面），最后取反得到校验和。</li>
<li>作用：发送方在发送数据前计算校验和并填充在报文头中，接收方收到数据后同样计算校验和并与发送方的校验和进行比对。如果比对不一致，则数据一定传输有误。</li>
</ul>
<h6 id="2-序列号">2. 序列号</h6>
<ul>
<li>作用：TCP为每个字节的数据都进行了编号，这就是序列号。序列号用于确保数据的顺序性和去除重复数据。</li>
<li>确认应答：接收方收到数据后，会向发送方发送ACK报文，其中带有对应的确认序列号，告诉发送方哪些数据已经被成功接收。</li>
</ul>
<h6 id="3-确认应答与超时重传">3. 确认应答与超时重传</h6>
<ul>
<li>确认应答：TCP传输过程中，每次接收方收到数据后都会发送ACK报文进行确认。</li>
<li>超时重传：如果发送方在发送数据后等待一定时间（如Linux中以500ms为单位，超时时间呈指数增长）仍未收到ACK报文，则会重新发送该数据。这避免了因网络原因导致的数据丢失。</li>
</ul>
<h6 id="4-连接管理（三次握手与四次挥手）">4. 连接管理（三次握手与四次挥手）</h6>
<ul>
<li>三次握手：用于建立连接，确保双方都已准备好进行数据传输。
<ol>
<li>客户端发送SYN报文给服务器。</li>
<li>服务器回复SYN+ACK报文给客户端。</li>
<li>客户端回复ACK报文给服务器，连接建立成功。</li>
</ol>
</li>
<li>四次挥手：用于关闭连接，确保双方都已正确处理完所有数据。
<ol>
<li>客户端发送FIN报文给服务器，表示不再发送数据。</li>
<li>服务器回复ACK报文给客户端，表示收到FIN报文。</li>
<li>服务器发送FIN报文给客户端，表示也不再发送数据。</li>
<li>客户端回复ACK报文给服务器，连接关闭成功。</li>
</ol>
</li>
</ul>
<h6 id="5-流量控制">5. 流量控制</h6>
<ul>
<li>
<p>滑动窗口机制：TCP利用滑动窗口机制实现流量控制，通过限制发送方窗口大小来防止发送速度过快导致接收方处理不及时而丢包。</p>
<p>窗口大小：TCP报头中有一个16位的窗口大小字段，表示接收端接收数据缓冲区的剩余大小。发送方根据接收方发送的窗口大小来调整自己的发送速度。</p>
</li>
</ul>
<h6 id="6-拥塞控制">6. 拥塞控制</h6>
<ul>
<li>慢启动：TCP连接刚建立时，发送方限制自己的初始发送窗口大小，避免发送过多数据导致网络拥塞。窗口大小以指数级别增加，直到达到一个阈值。</li>
<li>拥塞避免：在拥塞避免状态下，TCP发送方每经过一轮传输就增加一个MSS（最大报文段长度）的窗口大小。</li>
<li>拥塞检测与快速恢复：当TCP发送方收到超时重传或失序的确认消息时，会认为网络中出现拥塞，并采取相应的措施（如减小窗口大小、进入慢启动状态或快速恢复状态）来避免拥塞加剧。</li>
</ul>
<h3 id="网络层">网络层</h3>
<p>网络层是计算机网络体系结构中至关重要的一层，它位于OSI参考模型的第三层，也被称为网络协议层。网络层的主要功能是在源主机和目标主机之间提供数据通信的路径选择和控制，确保数据包能够正确、高效地传输。</p>
<ul>
<li>IP 协议的定义和作用 ？</li>
<li>IPV4 地址不够如何解决 ？</li>
<li>ICMP 的应用 ？</li>
</ul>
<h4 id="常见协议">常见协议</h4>
<ol>
<li>IP（Internet Protocol）
<ul>
<li>IP协议是网络层的核心协议，负责数据包的寻址和路由。它定义了数据包的格式、寻址方式和路由规则，是互联网通信的基础。</li>
</ul>
</li>
<li>ICMP（Internet Control Message Protocol）
<ul>
<li>ICMP是IP协议的附属协议，用于在IP网络中传递控制消息和错误报告。它常用于网络诊断、错误通知和测量网络的可达性和延迟等。</li>
</ul>
</li>
<li>ARP（Address Resolution Protocol）
<ul>
<li>ARP协议用于将IP地址解析为MAC地址，在局域网中实现数据包的正确传输。</li>
</ul>
</li>
<li>RARP（Reverse Address Resolution Protocol）
<ul>
<li>RARP与ARP相反，用于将MAC地址解析为IP地址，通常用于无盘工作站等设备在启动时获取自己的IP地址。</li>
</ul>
</li>
<li>OSPF（Open Shortest Path First）
<ul>
<li>OSPF是一种链路状态路由协议，用于在IP网络中进行路由选择。它根据链路状态信息计算最短路径，是内部网关协议的一种。</li>
</ul>
</li>
<li>BGP（Border Gateway Protocol）
<ul>
<li>BGP是边界网关协议，用于在不同自治系统之间进行路由选择。它是一种路径矢量协议，用于互联网中的路由选择。</li>
</ul>
</li>
</ol>
<h4 id="IP协议">IP协议</h4>
<p>IP协议，全称为网际互连协议（Internet Protocol），是TCP/IP体系中的网络层协议。它负责数据在网络中的传输，确保数据能够从一台主机正确地传送到另一台主机。</p>
<h5 id="功能特点">功能特点</h5>
<ul>
<li>路由与转发：IP协议通过IP地址和路由表实现数据包的路由和转发，确保数据包能够跨越多个网络到达目标主机。</li>
<li>分片与重组：当数据包的大小超过网络的最大传输单元（MTU）时，IP协议会将数据包进行分片，并在接收端进行重组。</li>
<li>错误检测与报告：通过ICMP协议，IP协议能够检测网络中的错误，并向发送方报告错误信息。</li>
<li>流量控制：虽然流量控制主要是传输层的任务，但IP协议通过路由选择和拥塞控制机制间接参与流量控制。</li>
</ul>
<h5 id="IP地址">IP地址</h5>
<p>IP地址是互联网中用于唯一标识每一台设备（如计算机、打印机、智能手机等）的逻辑地址。</p>
<h6 id="IPv4-IPv6">IPv4/IPv6</h6>
<p>历史上，IP地址被分为几个版本，目前最常用的是IPv4和IPv6。</p>
<ol>
<li>IPv4：
<ul>
<li>IPv4地址由32位二进制数组成，通常用点分十进制表示法表示，即4个8位二进制数（每个数取值范围为0-255）用点号（.）分隔，如192.168.1.1。</li>
<li>IPv4地址空间有限，理论上只有约43亿个地址，随着互联网的快速发展，IPv4地址已经接近枯竭。</li>
</ul>
</li>
<li>IPv6：
<ul>
<li>为了解决IPv4地址耗尽的问题，IPv6被设计出来。IPv6地址由128位二进制数组成，比IPv4地址空间要大得多，几乎可以为地球上的每一粒沙子分配一个IP地址。</li>
<li>IPv6地址的表示方法更为复杂，通常使用十六进制数表示，并且采用了冒号分隔的八组四位数格式，如2001:0db8:85a3:0000:0000:8a2e:0370:7334。为了简化表示，IPv6地址允许使用零压缩法（将连续的零省略为一个“::”）来缩短地址长度。</li>
</ul>
</li>
</ol>
<h6 id="IP地址分类和划分">IP地址分类和划分</h6>
<p>IPv4地址根据用途被分为五类，其中A、B、C三类地址用于单播通信，D类地址用于多播（组播）通信，E类地址保留为未来使用。</p>
<ul>
<li><strong>A类地址</strong>：范围从1.0.0.0到126.255.255.255，主要用于大型网络。</li>
<li><strong>B类地址</strong>：范围从128.0.0.0到191.255.255.255，适用于中等规模的网络。</li>
<li><strong>C类地址</strong>：范围从192.0.0.0到223.255.255.255，主要用于小型网络。</li>
<li><strong>D类地址</strong>：范围从224.0.0.0到239.255.255.255，用于多播通信。</li>
<li><strong>E类地址</strong>：范围从240.0.0.0到255.255.255.255，保留为未来使用。</li>
</ul>
<p>在 IP 地址 3 种主要类型里，各保留了 3 个区域作为私有地址，其地址范围如下：</p>
<p>A 类地址：10.0.0.0～10.255.255.255</p>
<p>B 类地址：172.16.0.0～172.31.255.255</p>
<p>C 类地址：192.168.0.0～192.168.255.255</p>
<h4 id="ARP协议">ARP协议</h4>
<p>ARP协议，即地址解析协议（Address Resolution Protocol），是TCP/IP协议族中的一个重要协议，主要用于将网络层（IP层）的IP地址解析为数据链路层（MAC层）的MAC地址。</p>
<h5 id="工作原理-3">工作原理</h5>
<ol>
<li>请求阶段
<ul>
<li>当主机需要发送数据给另一个主机时，它首先会检查自己的ARP缓存表中是否已存在目标IP地址到MAC地址的映射。</li>
<li>如果不存在，主机将生成一个ARP请求广播包，该包中包含目标IP地址和源IP地址，并广播到局域网上的所有主机。</li>
</ul>
</li>
<li>响应阶段
<ul>
<li>收到ARP请求的主机会检查自己的IP地址是否与请求中的目标IP地址相匹配。</li>
<li>如果匹配，该主机将发送一个ARP响应包给源主机，响应包中包含自己的MAC地址。</li>
</ul>
</li>
<li>更新ARP缓存
<ul>
<li>源主机收到ARP响应包后，将目标IP地址和MAC地址的映射关系存入自己的ARP缓存中，并保留一定时间（通常为几分钟到几小时不等）。</li>
<li>下次发送数据给同一目标时，将直接查询ARP缓存以节约资源。</li>
</ul>
</li>
</ol>
<h3 id="数据链路层">数据链路层</h3>
<p>数据链路层（Data Link Layer）是OSI参考模型中的第二层，位于物理层和网络层之间。它负责在物理层提供的服务基础上，向网络层提供服务，负责将物理层传输的原始比特流封装成帧（Frame），并通过控制帧的传输来确保数据的可靠传输。</p>
<ul>
<li>MAC 地址和 IP 地址分别有什么作用 ？</li>
<li>数据链路层上的三个基本问题 ?</li>
</ul>
<h4 id="主要功能">主要功能</h4>
<ol>
<li>帧的封装与解封
<ul>
<li><strong>成帧（帧同步）</strong>：将数据组合成数据块，并封装成帧。帧是数据链路层的传送单位，通过帧同步技术来识别帧的开始与结束。</li>
<li><strong>帧格式</strong>：帧通常包含帧头（包含源地址、目标地址、控制信息等）、数据部分和帧尾（校验序列等）。</li>
</ul>
</li>
<li>差错控制
<ul>
<li>通过在帧中加入校验序列（如CRC校验）来检测传输中的错误，并在发现错误时请求重传。</li>
<li>差错控制方式包括前向纠错（FEC）、反馈检测（ARQ）、混合纠错（HEC）和信息反馈（IRQ）等。</li>
</ul>
</li>
<li>流量控制
<ul>
<li>控制数据的发送速率，以匹配接收方的处理能力，避免数据丢失。</li>
<li>通过滑动窗口协议、停止等待协议等机制来实现。</li>
</ul>
</li>
<li>链路控制
<ul>
<li>包括数据链路的建立、维持和释放。</li>
<li>在通信开始时建立连接，在通信过程中维持连接，在通信结束时释放连接。</li>
</ul>
</li>
<li>MAC寻址
<ul>
<li>使用MAC地址（物理地址、硬件地址）来识别网络中的设备。</li>
<li>MAC地址被烧入每个以太网网卡中，用于在多点连接的网络中确保每一帧都能准确地送到正确的地址。</li>
</ul>
</li>
</ol>
<h3 id="物理层">物理层</h3>
<p>物理层（Physical Layer）是计算机网络体系结构中的最底层，它直接面向实际的物理传输介质，如双绞线、同轴电缆、光纤等，负责比特流（即0和1的二进制数据）的透明传输。物理层的主要任务是确定与传输媒体的接口有关的一些特性，确保数据能够在物理链路上正确地、有效地传输。</p>
<h4 id="主要功能-2">主要功能</h4>
<ol>
<li>数据编码（Data Encoding）：物理层负责将来自数据链路层的数据比特流转换成适合在物理介质上传输的信号。这包括数字信号的调制和编码过程，以及模拟信号的转换。</li>
<li>物理接口（Physical Interface）：定义物理设备之间连接的机械、电气、功能和规程特性。例如，网络接口卡（NIC）和电缆之间的插头和插座规格，信号电压水平，以及数据传输速率等。</li>
<li>比特同步（Bit Synchronization）：物理层需要解决接收方如何从接收到的信号中准确地恢复出原始的比特流，即比特同步问题。这通常涉及到时钟信号的提取和同步。</li>
<li>数据速率（Data Rate）：物理层还涉及到数据传输速率的控制，即每秒传输的比特数（bps）。不同的物理介质和技术支持不同的数据传输速率。</li>
<li>传输模式（Transmission Modes）：物理层支持多种传输模式，如单工（Simplex）、半双工（Half-Duplex）和全双工（Full-Duplex）等。这些模式决定了数据在物理链路上传输的方向和方式。</li>
<li>错误检测（Error Detection）：虽然物理层的主要任务是比特流的透明传输，但在某些情况下，物理层也会实现一些简单的错误检测机制，如奇偶校验位等，以帮助上层进行更复杂的错误控制。</li>
</ol>
<h4 id="信道复用">信道复用</h4>
<p>信道复用技术是一种在有限的通信资源中，通过合理地分配和利用信道资源，使多个用户或信号能够同时进行通信的技术。</p>
<ol>
<li>时分复用（TDM, Time Division Multiplexing）
<ul>
<li><strong>原理</strong>：将时间分割成若干个时隙，不同用户在各自的时隙中进行通信。</li>
<li>特点
<ul>
<li>灵活性高：可以根据不同用户的需求灵活分配时隙。</li>
<li>实时性强：保证用户间信息传输的实时性要求。</li>
<li>设备成本低：只需在时间维度上进行划分，无需额外设备。</li>
<li>缺点：在某些时刻只能有一个用户传输数据，时间资源无法完全共享。</li>
</ul>
</li>
</ul>
</li>
<li>频分复用（FDM, Frequency Division Multiplexing）
<ul>
<li><strong>原理</strong>：将通信频谱分成若干个子信道，每个子信道分配给不同的用户或信号进行传输。</li>
<li>特点
<ul>
<li>带宽高效：充分利用通信频谱资源，提高频谱利用率。</li>
<li>抗干扰性强：不同子信道之间相互隔离，不会干扰对方。</li>
<li>灵活性低：子信道数量固定，不能根据需求灵活调整。</li>
</ul>
</li>
</ul>
</li>
<li>码分复用（CDM, Code Division Multiplexing）
<ul>
<li><strong>原理</strong>：利用不同的扩频码将通信信号进行扩频处理，然后在频域上进行叠加传输。</li>
<li>特点
<ul>
<li>抗干扰性强：不同扩频码使信号相互隔离。</li>
<li>安全性高：可通过加密扩频码增强通信安全性。</li>
<li>复杂性高：需要频谱扩展和解扩处理，对系统硬件和算法要求高。</li>
<li>频谱利用率高：支持大量用户同时通信。</li>
</ul>
</li>
</ul>
</li>
<li>波分复用（WDM, Wavelength Division Multiplexing）
<ul>
<li><strong>原理</strong>：将不同波长的光信号通过光复用器复用在同一光纤上进行传输。</li>
<li>特点
<ul>
<li>带宽大：利用不同波长的光信号传输大量数据。</li>
<li>扩展性强：通过增加波长可提高系统容量。</li>
<li>灵活性低：光信号频率固定，不适用于频谱的灵活配置。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="计算机网络安全小叙">计算机网络安全小叙</h3>
<p>计算机网络安全是一个复杂而重要的领域，它涉及到保护计算机硬件、软件、数据不因偶然和恶意的原因而遭到破坏、更改和泄露。</p>
<ul>
<li><code>dos</code> 攻击 和 <code>ddos</code> 攻击是什么，如何防范 ？</li>
<li><code>ARP</code> 攻击的原理 ？</li>
<li><code>AES</code>加密 和 <code>RSA</code>加密 ？</li>
</ul>
<h4 id="dos和ddos">dos和ddos</h4>
<p>DoS（Denial of Service，拒绝服务）和DDoS（Distributed Denial of Service，分布式拒绝服务）是两种常见的网络攻击方式，它们通过向目标服务器发送大量的无效或高流量的网络请求，从而耗尽服务器的资源，使其无法正常处理有效的请求</p>
<p>DoS（拒绝服务）和DDoS（分布式拒绝服务）之间的主要区别：</p>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">DoS（拒绝服务）</th>
<th style="text-align:center">DDoS（分布式拒绝服务）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">定义</td>
<td style="text-align:center">通过单点攻击向目标服务器发送大量请求，使其无法处理而崩溃</td>
<td style="text-align:center">利用多个计算机或网络僵尸（Botnet）向目标发送大量无效或高流量请求，耗尽服务器资源</td>
</tr>
<tr>
<td style="text-align:center">攻击源</td>
<td style="text-align:center">单个设备或少量设备</td>
<td style="text-align:center">分布式，来自多个源（如僵尸网络）</td>
</tr>
<tr>
<td style="text-align:center">技术要求</td>
<td style="text-align:center">较高，需要针对特定目标进行攻击</td>
<td style="text-align:center">复杂，需要组织和控制多个攻击源</td>
</tr>
<tr>
<td style="text-align:center">攻击效果</td>
<td style="text-align:center">相对有限，针对单个目标</td>
<td style="text-align:center">影响广泛，可针对多个目标进行大规模攻击</td>
</tr>
<tr>
<td style="text-align:center">防御难度</td>
<td style="text-align:center">适中，可通过网络设备和安全策略进行防御</td>
<td style="text-align:center">较高，需要更复杂的防御措施和策略</td>
</tr>
<tr>
<td style="text-align:center">常见攻击手段</td>
<td style="text-align:center">Ping of Death, TearDrop, UDP flood, SYN flood, Land Attack, IP Spoofing等</td>
<td style="text-align:center">流量攻击（如TCP、UDP洪水）、应用层攻击（如HTTP请求）、协议攻击（如SYN Flood）等</td>
</tr>
<tr>
<td style="text-align:center">防御方法</td>
<td style="text-align:center">维护系统安全，安装防火墙，限制特定IP请求</td>
<td style="text-align:center">增加网络带宽，使用DDoS防护产品，部署防火墙和IDS，准备恢复计划和业务连续性</td>
</tr>
</tbody>
</table>
<h4 id="ARP攻击">ARP攻击</h4>
<p>ARP攻击，全称“地址解析协议攻击”，是一种针对以太网地址解析协议(ARP)的网络攻击方式，又称为ARP欺骗。ARP攻击的原理主要是基于ARP的漏洞进行欺骗。攻击者会发送伪造的ARP数据包，将自己的IP地址伪装成网络中的其他设备IP地址，同时将自己的MAC地址伪装成目标设备的MAC地址。当网络中的其他设备收到这些伪造的数据包时，由于ARP缓存表采用的是机械制原理，如果表中的某一列长时间不使用，就会被删除。因此，这些伪造的数据包有可能被错误地记录到ARP缓存表中，从而导致网络通信中断或数据泄露等安全问题。</p>
<p>以下是防御ARP攻击最主要的5个手段：</p>
<table>
<thead>
<tr>
<th>防御手段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态ARP绑定</td>
<td>将IP地址与MAC地址手动绑定在网络设备上，防止ARP欺骗。</td>
</tr>
<tr>
<td>DHCP Snooping</td>
<td>启用DHCP Snooping功能，限制只有经过认证的DHCP服务器才能分配IP地址，防止ARP欺骗攻击者伪造DHCP服务器。</td>
</tr>
<tr>
<td>端口安全/MAC地址绑定</td>
<td>在交换机上配置端口安全或MAC地址绑定功能，限制每个端口只能学习到一个或特定的MAC地址，防止ARP欺骗者接入网络。</td>
</tr>
<tr>
<td>防火墙与入侵检测</td>
<td>部署防火墙和入侵检测系统，对网络流量进行监控和过滤，及时发现并阻止ARP欺骗攻击。</td>
</tr>
<tr>
<td>定期更新与修补</td>
<td>定期更新操作系统、网络设备固件和安全软件，修补已知的安全漏洞，减少被ARP欺骗攻击的风险。</td>
</tr>
</tbody>
</table>
<h4 id="AES和RSA">AES和RSA</h4>
<p><strong>AES</strong>：AES是一种广泛采用的对称加密算法，以其高效性和强大的安全性著称。它使用固定长度的密钥（128位、192位或256位）对数据进行快速加密和解密，非常适合用于保护大量数据的机密性。无论是文件加密、网络通信还是数据存储，AES都能提供可靠的安全保障。</p>
<p><strong>RSA</strong>：RSA是一种基于非对称加密原理的算法，它使用一对密钥——公钥和私钥——来进行加密和解密操作。公钥可以公开分享，用于加密数据或验证数字签名；而私钥则保密持有，用于解密数据或生成签名。RSA算法特别适用于需要高安全性的场景，如数字签名、密钥交换和身份验证等。尽管其加密速度相对较慢，但RSA在保护关键数据和确保通信安全方面发挥着不可替代的作用。</p>
]]></content>
      <categories>
        <category>计算机四大件</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
